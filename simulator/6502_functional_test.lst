AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
---------------------------------------------------- 6502_functional_test.a65 ----------------------------------------------------

6111 lines read, no errors in pass 1.
                        ;
                        ; 6 5 0 2   F U N C T I O N A L   T E S T
                        ;
                        ; Copyright (C) 2012-2020  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all opcodes of a 6502 emulator using all
                        ; addressing modes with focus on propper setting of the processor status
                        ; register bits.
                        ; 
                        ; version 05-jan-2020
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 written by Frank A. Kingswood
                        ; The assembler as65_142.zip can be obtained from my GitHub repository 
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original NMOS 6502 only! No unofficial
                        ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
                        ; not be tested. Decimal ops will only be tested with valid BCD operands and
                        ; N V Z flags will be ignored.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   28-jul-2012  1st version distributed for testing
                        ;   29-jul-2012  fixed references to location 0, now #0
                        ;                added license - GPLv3
                        ;   30-jul-2012  added configuration options
                        ;   01-aug-2012  added trap macro to allow user to change error handling
                        ;   01-dec-2012  fixed trap in branch field must be a branch
                        ;   02-mar-2013  fixed PLA flags not tested
                        ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
                        ;                added test sequence check to detect if tests jump their fence
                        ;   23-jul-2013  added RAM integrity check option
                        ;   16-aug-2013  added error report to standard output option
                        ;   13-dec-2014  added binary/decimal opcode table switch test
                        ;   14-dec-2014  improved relative address test
                        ;   23-aug-2015  added option to disable self modifying tests
                        ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
                        ;                added small branch offset pretest
                        ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
                        ;   04-dec-2017  fixed BRK only tested with interrupts enabled
                        ;                added option to skip the remainder of a failing test
                        ;                in report.i65
                        ;   05-jan-2020  fixed shifts not testing zero result and flag when last 1-bit
                        ;                is shifted out
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0000 =                  ROM_vectors = 0
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0001 =                  load_data_direct = 1
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
                        ;tested if you allow changing the interrupt status (I_flag = 3)
0000 =                  I_flag = 0
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $52 (82) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
000a =                  zero_page = $a  
                        
                        ;data_segment memory start address, $7B (123) consecutive Bytes required
0200 =                  data_segment = $200  
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif  
                        
                        ;code_segment memory start address, 13.1kB of consecutive space required
                        ;                                   add 2.5 kB if I_flag = 2
0400 =                  code_segment = $400  
                        
                        ;self modifying code may be disabled to allow running in ROM
                        ;0=part of the code is self modifying and must reside in RAM
                        ;1=tests disabled: branch range
0000 =                  disable_selfmod = 0
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3.5 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
ffff =                  ram_top = -1
                        
                        ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
                        ;2=disable including decimal flag in processor status
0002 =                  disable_decimal = 2
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                                endm
                        trap_ne macro
                                bne *           ;failed not equal (non zero)
                                endm
                        trap_cs macro
                                bcs *           ;failed carry set
                                endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                                endm
                        trap_mi macro
                                bmi *           ;failed minus (bit 7 set)
                                endm
                        trap_pl macro
                                bpl *           ;failed plus (bit 7 clear)
                                endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                                endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
0038 =                  faod    equ fao+decmode     ;+ ignore decimal
003c =                  faid    equ fai+decmode     ;+ ignore decimal
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking test of decimal bit
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                            if disable_decimal < 2
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                            else
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faid)&m8   ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1|faid)      ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8   ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #\1|faod        ;invert expected flags + always on bits
                                    endm
                                endif
                            endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    pla         ;use stack to retrieve status
                                    pha
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                                    
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                                
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                                    
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro 
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                  if disable_selfmod = 0
                                    sta range_adr   ;reset self modifying code
                                  endif
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(abs1)   ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(abs1)   ;data after write & execute test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm            
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                        
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
                        ;        org zero_page
0000 =                           org 0               ;edited to provide binaries loading from 0
0000 : 4c0004                    jmp $400
0003 : 00000000000000            ds  zero_page-3
                        ;break test interrupt save
000a : 00               irq_a   ds  1               ;a register
000b : 00               irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags   
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
000c :                  zpt                         ;6 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
000c : 00               adfc    ds  1               ;carry flag before op
000d : 00               ad1     ds  1               ;operand 1 - accumulator
000e : 00               ad2     ds  1               ;operand 2 - memory / immediate
000f : 00               adrl    ds  1               ;expected result bits 0-7
0010 : 00               adrh    ds  1               ;expected result bit 8 (carry)
0011 : 00               adrf    ds  1               ;expected flags NV0000ZC (only binary mode)
0012 : 00               sb2     ds  1               ;operand 2 complemented for subtract
0013 :                  zp_bss
0013 : 8001             zps     db  $80,1           ;additional shift pattern to test zero result & flag
0015 : c3824100         zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
0019 : 7f               zp7f    db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
001a : 001f7180         zpOR    db  0,$1f,$71,$80   ;test pattern for OR
001e : 0fff7f80         zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0022 : ff0f8f8f         zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
0026 : 1802             ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
0028 : 1902                     dw  abs1+1
002a : 1a02                     dw  abs1+2
002c : 1b02                     dw  abs1+3
002e : 1c02                     dw  abs7f
0030 : 2001             inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0032 : 0302             indt    dw  abst            ;indirect pointer to store area in absolute memory
0034 : 0402                     dw  abst+1
0036 : 0502                     dw  abst+2
0038 : 0602                     dw  abst+3
003a : 0b01             inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
003c : 5f02             indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
003e : 6002                     dw  absAN+1
0040 : 6102                     dw  absAN+2
0042 : 6202                     dw  absAN+3
0044 : 6302             indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
0046 : 6402                     dw  absEO+1
0048 : 6502                     dw  absEO+2
004a : 6602                     dw  absEO+3
004c : 5b02             indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
004e : 5c02                     dw  absOR+1
0050 : 5d02                     dw  absOR+2
0052 : 5e02                     dw  absOR+3
                        ;add/subtract indirect pointers
0054 : 0302             adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
0056 : 0402             sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
0058 : 0401             adiy2   dw  ada2-$ff        ;with offset for indirect indexed
005a : 0501             sbiy2   dw  sba2-$ff
005c :                  zp_bss_end
                           
0200 =                          org data_segment
0200 : 00               test_case   ds  1           ;current test number
0201 : 0000             ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0203 :                  abst                        ;6 bytes store/modify test area
0203 : 00               ada2    ds  1               ;operand 2
0204 : 00               sba2    ds  1               ;operand 2 complemented for subtract
0205 : 00000000                 ds  4               ;fill remaining bytes
0209 :                  data_bss
                            if load_data_direct = 1
0209 : 2900             ex_andi and #0              ;execute immediate opcodes
020b : 60                       rts
020c : 4900             ex_eori eor #0              ;execute immediate opcodes
020e : 60                       rts
020f : 0900             ex_orai ora #0              ;execute immediate opcodes
0211 : 60                       rts
0212 : 6900             ex_adci adc #0              ;execute immediate opcodes
0214 : 60                       rts
0215 : e900             ex_sbci sbc #0              ;execute immediate opcodes
0217 : 60                       rts
                            else
                        ex_andi ds  3
                        ex_eori ds  3
                        ex_orai ds  3
                        ex_adci ds  3
                        ex_sbci ds  3
                            endif
                        ;zps    db  $80,1           ;additional shift patterns test zero result & flag
0218 : c3824100         abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
021c : 7f               abs7f   db  $7f             ;test pattern for compare
                        ;loads
021d : 80800002         fLDx    db  fn,fn,0,fz              ;expected flags for load
                        ;shifts
0221 :                  rASL                                ;expected result ASL & ROL -carry
0221 : 000286048200     rROL    db  0,2,$86,$04,$82,0
0227 : 010387058301     rROLc   db  1,3,$87,$05,$83,1       ;expected result ROL +carry
022d :                  rLSR                                ;expected result LSR & ROR -carry
022d : 400061412000     rROR    db  $40,0,$61,$41,$20,0
0233 : c080e1c1a080     rRORc   db  $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
0239 :                  fASL                                ;expected flags for shifts
0239 : 030081018002     fROL    db  fzc,0,fnc,fc,fn,fz      ;no carry in
023f : 010081018000     fROLc   db  fc,0,fnc,fc,fn,0        ;carry in 
0245 :                  fLSR 
0245 : 000301000102     fROR    db  0,fzc,fc,0,fc,fz        ;no carry in
024b : 808181808180     fRORc   db  fn,fnc,fnc,fn,fnc,fn    ;carry in
                        ;increments (decrements)
0251 : 7f80ff0001       rINC    db  $7f,$80,$ff,0,1         ;expected result for INC/DEC
0256 : 0080800200       fINC    db  0,fn,fn,fz,0            ;expected flags for INC/DEC
                        ;logical memory operand
025b : 001f7180         absOR   db  0,$1f,$71,$80           ;test pattern for OR
025f : 0fff7f80         absAN   db  $0f,$ff,$7f,$80         ;test pattern for AND
0263 : ff0f8f8f         absEO   db  $ff,$0f,$8f,$8f         ;test pattern for EOR
                        ;logical accu operand
0267 : 00f11f00         absORa  db  0,$f1,$1f,0             ;test pattern for OR
026b : f0ffffff         absANa  db  $f0,$ff,$ff,$ff         ;test pattern for AND
026f : fff0f00f         absEOa  db  $ff,$f0,$f0,$0f         ;test pattern for EOR
                        ;logical results
0273 : 00ff7f80         absrlo  db  0,$ff,$7f,$80
0277 : 02800080         absflo  db  fz,fn,0,fn
027b :                  data_bss_end
                        
                        
                                code
0400 =                          org code_segment
0400 : d8               start   cld
0401 : a2ff                     ldx #$ff
0403 : 9a                       txs
0404 : a900                     lda #0          ;*** test 0 = initialize
0406 : 8d0002                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
                                sei
                            endif
                            
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                            
                        ;pretest small branch offset
0409 : a205                     ldx #5
040b : 4c3304                   jmp psb_test
040e :                  psb_bwok
040e : a005                     ldy #5
0410 : d008                     bne psb_forw
                                trap        ;branch should be taken
0412 : 4c1204          >        jmp *           ;failed anyway
                        
0415 : 88                       dey         ;forward landing zone
0416 : 88                       dey
0417 : 88                       dey
0418 : 88                       dey
0419 : 88                       dey
041a :                  psb_forw
041a : 88                       dey
041b : 88                       dey
041c : 88                       dey
041d : 88                       dey
041e : 88                       dey
041f : f017                     beq psb_fwok
                                trap        ;forward offset
0421 : 4c2104          >        jmp *           ;failed anyway
                        
                        
0424 : ca                       dex         ;backward landing zone
0425 : ca                       dex
0426 : ca                       dex
0427 : ca                       dex
0428 : ca                       dex
0429 :                  psb_back
0429 : ca                       dex
042a : ca                       dex
042b : ca                       dex
042c : ca                       dex
042d : ca                       dex
042e : f0de                     beq psb_bwok
                                trap        ;backward offset
0430 : 4c3004          >        jmp *           ;failed anyway
                        
0433 :                  psb_test
0433 : d0f4                     bne psb_back
                                trap        ;branch should be taken
0435 : 4c3504          >        jmp *           ;failed anyway
                        
0438 :                  psb_fwok
                                
                        ;initialize BSS segment
                            if load_data_direct != 1
                                ldx #zp_end-zp_init-1
                        ld_zp   lda zp_init,x
                                sta zp_bss,x
                                dex
                                bpl ld_zp
                                ldx #data_end-data_init-1
                        ld_data lda data_init,x
                                sta data_bss,x
                                dex
                                bpl ld_data
                              if ROM_vectors = 1
                                ldx #5
                        ld_vect lda vec_init,x
                                sta vec_bss,x
                                dex
                                bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                                
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
                                lda #0 
                                sta zpt         ;set low byte of indirect pointer
                                sta ram_chksm+1 ;checksum high byte
                              if disable_selfmod = 0
                                sta range_adr   ;reset self modifying code
                              endif
                                clc
                                ldx #zp_bss-zero_page ;zeropage - write test area
                        gcs3    adc zero_page,x
                                bcc gcs2
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs2    inx
                                bne gcs3
                                ldx #hi(abs1)   ;set high byte of indirect pointer
                                stx zpt+1
                                ldy #lo(abs1)   ;data after write & execute test area
                        gcs5    adc (zpt),y
                                bcc gcs4
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs4    iny
                                bne gcs5
                                inx             ;advance RAM high address
                                stx zpt+1
                                cpx #ram_top
                                bne gcs5
                                sta ram_chksm   ;checksum complete
                            endif
                                next_test            
0438 : ad0002          >            lda test_case   ;previous test
043b : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
043d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
043f : a901            >            lda #test_num   ;*** next tests' number
0441 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                            if disable_selfmod = 0
                        ;testing relative addressing with BEQ
0444 : a0fe                     ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
0446 :                  range_loop
0446 : 88                       dey             ;next relative address
0447 : 98                       tya
0448 : aa                       tax             ;precharge count to end of loop
0449 : 1008                     bpl range_fw    ;calculate relative address
044b : 18                       clc             ;avoid branch self or to relative address of branch
044c : 6902                     adc #2
044e : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
044f : ea                       nop
0450 : ea                       nop
0451 : ea                       nop
0452 : ea                       nop
0453 :                  range_fw
0453 : ea                       nop
0454 : ea                       nop
0455 : ea                       nop
0456 : ea                       nop
0457 : ea                       nop
0458 : 497f                     eor #$7f        ;complement except sign
045a : 8de604                   sta range_adr   ;load into test target
045d : a900                     lda #0          ;should set zero flag in status register
045f : 4ce504                   jmp range_op
                                
0462 : ca                       dex             ; offset landing zone - backward branch too far
0463 : ca                       dex
0464 : ca                       dex
0465 : ca                       dex
0466 : ca                       dex
                                ;relative address target field with branch under test in the middle
0467 : ca                       dex             ;-128 - max backward
0468 : ca                       dex
0469 : ca                       dex
046a : ca                       dex
046b : ca                       dex
046c : ca                       dex
046d : ca                       dex
046e : ca                       dex
046f : ca                       dex             ;-120
0470 : ca                       dex
0471 : ca                       dex
0472 : ca                       dex
0473 : ca                       dex
0474 : ca                       dex
0475 : ca                       dex
0476 : ca                       dex
0477 : ca                       dex
0478 : ca                       dex
0479 : ca                       dex             ;-110
047a : ca                       dex
047b : ca                       dex
047c : ca                       dex
047d : ca                       dex
047e : ca                       dex
047f : ca                       dex
0480 : ca                       dex
0481 : ca                       dex
0482 : ca                       dex
0483 : ca                       dex             ;-100
0484 : ca                       dex
0485 : ca                       dex
0486 : ca                       dex
0487 : ca                       dex
0488 : ca                       dex
0489 : ca                       dex
048a : ca                       dex
048b : ca                       dex
048c : ca                       dex
048d : ca                       dex             ;-90
048e : ca                       dex
048f : ca                       dex
0490 : ca                       dex
0491 : ca                       dex
0492 : ca                       dex
0493 : ca                       dex
0494 : ca                       dex
0495 : ca                       dex
0496 : ca                       dex
0497 : ca                       dex             ;-80
0498 : ca                       dex
0499 : ca                       dex
049a : ca                       dex
049b : ca                       dex
049c : ca                       dex
049d : ca                       dex
049e : ca                       dex
049f : ca                       dex
04a0 : ca                       dex
04a1 : ca                       dex             ;-70
04a2 : ca                       dex
04a3 : ca                       dex
04a4 : ca                       dex
04a5 : ca                       dex
04a6 : ca                       dex
04a7 : ca                       dex
04a8 : ca                       dex
04a9 : ca                       dex
04aa : ca                       dex
04ab : ca                       dex             ;-60
04ac : ca                       dex
04ad : ca                       dex
04ae : ca                       dex
04af : ca                       dex
04b0 : ca                       dex
04b1 : ca                       dex
04b2 : ca                       dex
04b3 : ca                       dex
04b4 : ca                       dex
04b5 : ca                       dex             ;-50
04b6 : ca                       dex
04b7 : ca                       dex
04b8 : ca                       dex
04b9 : ca                       dex
04ba : ca                       dex
04bb : ca                       dex
04bc : ca                       dex
04bd : ca                       dex
04be : ca                       dex
04bf : ca                       dex             ;-40
04c0 : ca                       dex
04c1 : ca                       dex
04c2 : ca                       dex
04c3 : ca                       dex
04c4 : ca                       dex
04c5 : ca                       dex
04c6 : ca                       dex
04c7 : ca                       dex
04c8 : ca                       dex
04c9 : ca                       dex             ;-30
04ca : ca                       dex
04cb : ca                       dex
04cc : ca                       dex
04cd : ca                       dex
04ce : ca                       dex
04cf : ca                       dex
04d0 : ca                       dex
04d1 : ca                       dex
04d2 : ca                       dex
04d3 : ca                       dex             ;-20
04d4 : ca                       dex
04d5 : ca                       dex
04d6 : ca                       dex
04d7 : ca                       dex
04d8 : ca                       dex
04d9 : ca                       dex
04da : ca                       dex
04db : ca                       dex
04dc : ca                       dex
04dd : ca                       dex             ;-10
04de : ca                       dex
04df : ca                       dex
04e0 : ca                       dex
04e1 : ca                       dex
04e2 : ca                       dex
04e3 : ca                       dex
04e4 : ca                       dex             ;-3
04e5 :                  range_op                ;test target with zero flag=0, z=1 if previous dex
04e6 =                  range_adr   = *+1       ;modifiable relative address
04e5 : f03e                     beq *+64        ;+64 if called without modification
04e7 : ca                       dex             ;+0
04e8 : ca                       dex
04e9 : ca                       dex
04ea : ca                       dex
04eb : ca                       dex
04ec : ca                       dex
04ed : ca                       dex
04ee : ca                       dex
04ef : ca                       dex
04f0 : ca                       dex
04f1 : ca                       dex             ;+10
04f2 : ca                       dex
04f3 : ca                       dex
04f4 : ca                       dex
04f5 : ca                       dex
04f6 : ca                       dex
04f7 : ca                       dex
04f8 : ca                       dex
04f9 : ca                       dex
04fa : ca                       dex
04fb : ca                       dex             ;+20
04fc : ca                       dex
04fd : ca                       dex
04fe : ca                       dex
04ff : ca                       dex
0500 : ca                       dex
0501 : ca                       dex
0502 : ca                       dex
0503 : ca                       dex
0504 : ca                       dex
0505 : ca                       dex             ;+30
0506 : ca                       dex
0507 : ca                       dex
0508 : ca                       dex
0509 : ca                       dex
050a : ca                       dex
050b : ca                       dex
050c : ca                       dex
050d : ca                       dex
050e : ca                       dex
050f : ca                       dex             ;+40
0510 : ca                       dex
0511 : ca                       dex
0512 : ca                       dex
0513 : ca                       dex
0514 : ca                       dex
0515 : ca                       dex
0516 : ca                       dex
0517 : ca                       dex
0518 : ca                       dex
0519 : ca                       dex             ;+50
051a : ca                       dex
051b : ca                       dex
051c : ca                       dex
051d : ca                       dex
051e : ca                       dex
051f : ca                       dex
0520 : ca                       dex
0521 : ca                       dex
0522 : ca                       dex
0523 : ca                       dex             ;+60
0524 : ca                       dex
0525 : ca                       dex
0526 : ca                       dex
0527 : ca                       dex
0528 : ca                       dex
0529 : ca                       dex
052a : ca                       dex
052b : ca                       dex
052c : ca                       dex
052d : ca                       dex             ;+70
052e : ca                       dex
052f : ca                       dex
0530 : ca                       dex
0531 : ca                       dex
0532 : ca                       dex
0533 : ca                       dex
0534 : ca                       dex
0535 : ca                       dex
0536 : ca                       dex
0537 : ca                       dex             ;+80
0538 : ca                       dex
0539 : ca                       dex
053a : ca                       dex
053b : ca                       dex
053c : ca                       dex
053d : ca                       dex
053e : ca                       dex
053f : ca                       dex
0540 : ca                       dex
0541 : ca                       dex             ;+90
0542 : ca                       dex
0543 : ca                       dex
0544 : ca                       dex
0545 : ca                       dex
0546 : ca                       dex
0547 : ca                       dex
0548 : ca                       dex
0549 : ca                       dex
054a : ca                       dex
054b : ca                       dex             ;+100
054c : ca                       dex
054d : ca                       dex
054e : ca                       dex
054f : ca                       dex
0550 : ca                       dex
0551 : ca                       dex
0552 : ca                       dex
0553 : ca                       dex
0554 : ca                       dex
0555 : ca                       dex             ;+110
0556 : ca                       dex
0557 : ca                       dex
0558 : ca                       dex
0559 : ca                       dex
055a : ca                       dex
055b : ca                       dex
055c : ca                       dex
055d : ca                       dex
055e : ca                       dex
055f : ca                       dex             ;+120
0560 : ca                       dex
0561 : ca                       dex
0562 : ca                       dex
0563 : ca                       dex
0564 : ca                       dex
0565 : ca                       dex
0566 : ea                       nop             ;offset landing zone - forward branch too far
0567 : ea                       nop
0568 : ea                       nop
0569 : ea                       nop
056a : ea                       nop
056b : f008                     beq range_ok    ;+127 - max forward
                                trap            ; bad range
056d : 4c6d05          >        jmp *           ;failed anyway
                        
0570 : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
0571 : ea                       nop
0572 : ea                       nop
0573 : ea                       nop
0574 : ea                       nop
0575 :                  range_ok
0575 : ea                       nop
0576 : ea                       nop
0577 : ea                       nop
0578 : ea                       nop
0579 : ea                       nop
057a : c000                     cpy #0
057c : f003                     beq range_end   
057e : 4c4604                   jmp range_loop
0581 :                  range_end               ;range test successful
                            endif
                                next_test
0581 : ad0002          >            lda test_case   ;previous test
0584 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0586 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
0588 : a902            >            lda #test_num   ;*** next tests' number
058a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;partial test BNE & CMP, CPX, CPY immediate
058d : c001                     cpy #1          ;testing BNE true
058f : d003                     bne test_bne
                                trap 
0591 : 4c9105          >        jmp *           ;failed anyway
                        
0594 :                  test_bne
0594 : a900                     lda #0 
0596 : c900                     cmp #0          ;test compare immediate 
                                trap_ne
0598 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
059a : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
059c : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
059e : c901                     cmp #1
                                trap_eq 
05a0 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05a2 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05a4 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
05a6 : aa                       tax 
05a7 : e000                     cpx #0          ;test compare x immediate
                                trap_ne
05a9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05ab : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05ad : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05af : e001                     cpx #1
                                trap_eq 
05b1 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05b3 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05b5 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
05b7 : a8                       tay 
05b8 : c000                     cpy #0          ;test compare y immediate
                                trap_ne
05ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05bc : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05be : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05c0 : c001                     cpy #1
                                trap_eq 
05c2 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05c4 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05c6 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                next_test
05c8 : ad0002          >            lda test_case   ;previous test
05cb : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
05cd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
05cf : a903            >            lda #test_num   ;*** next tests' number
05d1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ;testing stack operations PHA PHP PLA PLP
                                    
05d4 : a2ff                     ldx #$ff        ;initialize stack
05d6 : 9a                       txs
05d7 : a955                     lda #$55
05d9 : 48                       pha
05da : a9aa                     lda #$aa
05dc : 48                       pha
05dd : cdfe01                   cmp $1fe        ;on stack ?
                                trap_ne
05e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05e2 : ba                       tsx
05e3 : 8a                       txa             ;overwrite accu
05e4 : c9fd                     cmp #$fd        ;sp decremented?
                                trap_ne
05e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05e8 : 68                       pla
05e9 : c9aa                     cmp #$aa        ;successful retreived from stack?
                                trap_ne
05eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
05ed : 68                       pla
05ee : c955                     cmp #$55
                                trap_ne
05f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05f2 : cdff01                   cmp $1ff        ;remains on stack?
                                trap_ne
05f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
05f7 : ba                       tsx
05f8 : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
05fa : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
05fc : ad0002          >            lda test_case   ;previous test
05ff : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0601 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
0603 : a904            >            lda #test_num   ;*** next tests' number
0605 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
                                set_stat $ff    ;all on
                       >            load_flag $ff    
0608 : a9fb            >            lda #$ff    &m8i         ;force enable interrupts (mask I)
                       >
060a : 48              >            pha         ;use stack to load status
060b : 28              >            plp
                        
060c : 101a                     bpl nbr1        ;branches should not be taken
060e : 501b                     bvc nbr2
0610 : 901c                     bcc nbr3
0612 : d01d                     bne nbr4
0614 : 3003                     bmi br1         ;branches should be taken
                                trap 
0616 : 4c1606          >        jmp *           ;failed anyway
                        
0619 : 7003             br1     bvs br2
                                trap 
061b : 4c1b06          >        jmp *           ;failed anyway
                        
061e : b003             br2     bcs br3
                                trap 
0620 : 4c2006          >        jmp *           ;failed anyway
                        
0623 : f00f             br3     beq br4
                                trap 
0625 : 4c2506          >        jmp *           ;failed anyway
                        
0628 :                  nbr1
                                trap            ;previous bpl taken 
0628 : 4c2806          >        jmp *           ;failed anyway
                        
062b :                  nbr2
                                trap            ;previous bvc taken
062b : 4c2b06          >        jmp *           ;failed anyway
                        
062e :                  nbr3
                                trap            ;previous bcc taken
062e : 4c2e06          >        jmp *           ;failed anyway
                        
0631 :                  nbr4
                                trap            ;previous bne taken
0631 : 4c3106          >        jmp *           ;failed anyway
                        
0634 : 08               br4     php
0635 : ba                       tsx
0636 : e0fe                     cpx #$fe        ;sp after php?
                                trap_ne
0638 : d0fe            >        bne *           ;failed not equal (non zero)
                        
063a : 68                       pla
                                cmp_flag $ff    ;returned all flags on?
063b : 0908            >            ora #decmode        ;ignore decimal mode bit
063d : c9fb            >            cmp #($ff    |faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
063f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0641 : ba                       tsx
0642 : e0ff                     cpx #$ff        ;sp after php?
                                trap_ne
0644 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0      ;all off
                       >            load_flag 0      
0646 : a900            >            lda #0      &m8i         ;force enable interrupts (mask I)
                       >
0648 : 48              >            pha         ;use stack to load status
0649 : 28              >            plp
                        
064a : 301a                     bmi nbr11       ;branches should not be taken
064c : 701b                     bvs nbr12
064e : b01c                     bcs nbr13
0650 : f01d                     beq nbr14
0652 : 1003                     bpl br11        ;branches should be taken
                                trap 
0654 : 4c5406          >        jmp *           ;failed anyway
                        
0657 : 5003             br11    bvc br12
                                trap 
0659 : 4c5906          >        jmp *           ;failed anyway
                        
065c : 9003             br12    bcc br13
                                trap 
065e : 4c5e06          >        jmp *           ;failed anyway
                        
0661 : d00f             br13    bne br14
                                trap 
0663 : 4c6306          >        jmp *           ;failed anyway
                        
0666 :                  nbr11
                                trap            ;previous bmi taken 
0666 : 4c6606          >        jmp *           ;failed anyway
                        
0669 :                  nbr12
                                trap            ;previous bvs taken 
0669 : 4c6906          >        jmp *           ;failed anyway
                        
066c :                  nbr13
                                trap            ;previous bcs taken 
066c : 4c6c06          >        jmp *           ;failed anyway
                        
066f :                  nbr14
                                trap            ;previous beq taken 
066f : 4c6f06          >        jmp *           ;failed anyway
                        
0672 : 08               br14    php
0673 : 68                       pla
                                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
0674 : 0908            >            ora #decmode        ;ignore decimal mode bit
0676 : c938            >            cmp #(0      |faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
0678 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                ;crosscheck flags
                                set_stat zero
                       >            load_flag zero
067a : a902            >            lda #zero&m8i         ;force enable interrupts (mask I)
                       >
067c : 48              >            pha         ;use stack to load status
067d : 28              >            plp
                        
067e : d002                     bne brzs1
0680 : f003                     beq brzs2
0682 :                  brzs1
                                trap            ;branch zero/non zero
0682 : 4c8206          >        jmp *           ;failed anyway
                        
0685 : b002             brzs2   bcs brzs3
0687 : 9003                     bcc brzs4
0689 :                  brzs3
                                trap            ;branch carry/no carry
0689 : 4c8906          >        jmp *           ;failed anyway
                        
068c : 3002             brzs4   bmi brzs5
068e : 1003                     bpl brzs6
0690 :                  brzs5
                                trap            ;branch minus/plus
0690 : 4c9006          >        jmp *           ;failed anyway
                        
0693 : 7002             brzs6   bvs brzs7
0695 : 5003                     bvc brzs8
0697 :                  brzs7
                                trap            ;branch overflow/no overflow
0697 : 4c9706          >        jmp *           ;failed anyway
                        
069a :                  brzs8
                                set_stat carry
                       >            load_flag carry
069a : a901            >            lda #carry&m8i         ;force enable interrupts (mask I)
                       >
069c : 48              >            pha         ;use stack to load status
069d : 28              >            plp
                        
069e : f002                     beq brcs1
06a0 : d003                     bne brcs2
06a2 :                  brcs1
                                trap            ;branch zero/non zero
06a2 : 4ca206          >        jmp *           ;failed anyway
                        
06a5 : 9002             brcs2   bcc brcs3
06a7 : b003                     bcs brcs4
06a9 :                  brcs3
                                trap            ;branch carry/no carry
06a9 : 4ca906          >        jmp *           ;failed anyway
                        
06ac : 3002             brcs4   bmi brcs5
06ae : 1003                     bpl brcs6
06b0 :                  brcs5
                                trap            ;branch minus/plus
06b0 : 4cb006          >        jmp *           ;failed anyway
                        
06b3 : 7002             brcs6   bvs brcs7
06b5 : 5003                     bvc brcs8
06b7 :                  brcs7
                                trap            ;branch overflow/no overflow
06b7 : 4cb706          >        jmp *           ;failed anyway
                        
                        
06ba :                  brcs8
                                set_stat minus
                       >            load_flag minus
06ba : a980            >            lda #minus&m8i         ;force enable interrupts (mask I)
                       >
06bc : 48              >            pha         ;use stack to load status
06bd : 28              >            plp
                        
06be : f002                     beq brmi1
06c0 : d003                     bne brmi2
06c2 :                  brmi1
                                trap            ;branch zero/non zero
06c2 : 4cc206          >        jmp *           ;failed anyway
                        
06c5 : b002             brmi2   bcs brmi3
06c7 : 9003                     bcc brmi4
06c9 :                  brmi3
                                trap            ;branch carry/no carry
06c9 : 4cc906          >        jmp *           ;failed anyway
                        
06cc : 1002             brmi4   bpl brmi5
06ce : 3003                     bmi brmi6
06d0 :                  brmi5
                                trap            ;branch minus/plus
06d0 : 4cd006          >        jmp *           ;failed anyway
                        
06d3 : 7002             brmi6   bvs brmi7
06d5 : 5003                     bvc brmi8
06d7 :                  brmi7
                                trap            ;branch overflow/no overflow
06d7 : 4cd706          >        jmp *           ;failed anyway
                        
06da :                  brmi8
                                set_stat overfl
                       >            load_flag overfl
06da : a940            >            lda #overfl&m8i         ;force enable interrupts (mask I)
                       >
06dc : 48              >            pha         ;use stack to load status
06dd : 28              >            plp
                        
06de : f002                     beq brvs1
06e0 : d003                     bne brvs2
06e2 :                  brvs1
                                trap            ;branch zero/non zero
06e2 : 4ce206          >        jmp *           ;failed anyway
                        
06e5 : b002             brvs2   bcs brvs3
06e7 : 9003                     bcc brvs4
06e9 :                  brvs3
                                trap            ;branch carry/no carry
06e9 : 4ce906          >        jmp *           ;failed anyway
                        
06ec : 3002             brvs4   bmi brvs5
06ee : 1003                     bpl brvs6
06f0 :                  brvs5
                                trap            ;branch minus/plus
06f0 : 4cf006          >        jmp *           ;failed anyway
                        
06f3 : 5002             brvs6   bvc brvs7
06f5 : 7003                     bvs brvs8
06f7 :                  brvs7
                                trap            ;branch overflow/no overflow
06f7 : 4cf706          >        jmp *           ;failed anyway
                        
06fa :                  brvs8
                                set_stat $ff-zero
                       >            load_flag $ff-zero
06fa : a9f9            >            lda #$ff-zero&m8i         ;force enable interrupts (mask I)
                       >
06fc : 48              >            pha         ;use stack to load status
06fd : 28              >            plp
                        
06fe : f002                     beq brzc1
0700 : d003                     bne brzc2
0702 :                  brzc1
                                trap            ;branch zero/non zero
0702 : 4c0207          >        jmp *           ;failed anyway
                        
0705 : 9002             brzc2   bcc brzc3
0707 : b003                     bcs brzc4
0709 :                  brzc3
                                trap            ;branch carry/no carry
0709 : 4c0907          >        jmp *           ;failed anyway
                        
070c : 1002             brzc4   bpl brzc5
070e : 3003                     bmi brzc6
0710 :                  brzc5
                                trap            ;branch minus/plus
0710 : 4c1007          >        jmp *           ;failed anyway
                        
0713 : 5002             brzc6   bvc brzc7
0715 : 7003                     bvs brzc8
0717 :                  brzc7
                                trap            ;branch overflow/no overflow
0717 : 4c1707          >        jmp *           ;failed anyway
                        
071a :                  brzc8
                                set_stat $ff-carry
                       >            load_flag $ff-carry
071a : a9fa            >            lda #$ff-carry&m8i         ;force enable interrupts (mask I)
                       >
071c : 48              >            pha         ;use stack to load status
071d : 28              >            plp
                        
071e : d002                     bne brcc1
0720 : f003                     beq brcc2
0722 :                  brcc1
                                trap            ;branch zero/non zero
0722 : 4c2207          >        jmp *           ;failed anyway
                        
0725 : b002             brcc2   bcs brcc3
0727 : 9003                     bcc brcc4
0729 :                  brcc3
                                trap            ;branch carry/no carry
0729 : 4c2907          >        jmp *           ;failed anyway
                        
072c : 1002             brcc4   bpl brcc5
072e : 3003                     bmi brcc6
0730 :                  brcc5
                                trap            ;branch minus/plus
0730 : 4c3007          >        jmp *           ;failed anyway
                        
0733 : 5002             brcc6   bvc brcc7
0735 : 7003                     bvs brcc8
0737 :                  brcc7
                                trap            ;branch overflow/no overflow
0737 : 4c3707          >        jmp *           ;failed anyway
                        
073a :                  brcc8
                                set_stat $ff-minus
                       >            load_flag $ff-minus
073a : a97b            >            lda #$ff-minus&m8i         ;force enable interrupts (mask I)
                       >
073c : 48              >            pha         ;use stack to load status
073d : 28              >            plp
                        
073e : d002                     bne brpl1
0740 : f003                     beq brpl2
0742 :                  brpl1
                                trap            ;branch zero/non zero
0742 : 4c4207          >        jmp *           ;failed anyway
                        
0745 : 9002             brpl2   bcc brpl3
0747 : b003                     bcs brpl4
0749 :                  brpl3
                                trap            ;branch carry/no carry
0749 : 4c4907          >        jmp *           ;failed anyway
                        
074c : 3002             brpl4   bmi brpl5
074e : 1003                     bpl brpl6
0750 :                  brpl5
                                trap            ;branch minus/plus
0750 : 4c5007          >        jmp *           ;failed anyway
                        
0753 : 5002             brpl6   bvc brpl7
0755 : 7003                     bvs brpl8
0757 :                  brpl7
                                trap            ;branch overflow/no overflow
0757 : 4c5707          >        jmp *           ;failed anyway
                        
075a :                  brpl8
                                set_stat $ff-overfl
                       >            load_flag $ff-overfl
075a : a9bb            >            lda #$ff-overfl&m8i         ;force enable interrupts (mask I)
                       >
075c : 48              >            pha         ;use stack to load status
075d : 28              >            plp
                        
075e : d002                     bne brvc1
0760 : f003                     beq brvc2
0762 :                  brvc1
                                trap            ;branch zero/non zero
0762 : 4c6207          >        jmp *           ;failed anyway
                        
0765 : 9002             brvc2   bcc brvc3
0767 : b003                     bcs brvc4
0769 :                  brvc3
                                trap            ;branch carry/no carry
0769 : 4c6907          >        jmp *           ;failed anyway
                        
076c : 1002             brvc4   bpl brvc5
076e : 3003                     bmi brvc6
0770 :                  brvc5
                                trap            ;branch minus/plus
0770 : 4c7007          >        jmp *           ;failed anyway
                        
0773 : 7002             brvc6   bvs brvc7
0775 : 5003                     bvc brvc8
0777 :                  brvc7
                                trap            ;branch overflow/no overflow
0777 : 4c7707          >        jmp *           ;failed anyway
                        
077a :                  brvc8
                                next_test
077a : ad0002          >            lda test_case   ;previous test
077d : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
077f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
0781 : a905            >            lda #test_num   ;*** next tests' number
0783 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test PHA does not alter flags or accumulator but PLA does
0786 : a255                     ldx #$55        ;x & y protected
0788 : a0aa                     ldy #$aa
                                set_a 1,$ff     ;push
                       >            load_flag $ff     
078a : a9fb            >            lda #$ff     &m8i         ;force enable interrupts (mask I)
                       >
078c : 48              >            pha         ;use stack to load status
078d : a901            >            lda #1     ;precharge accu
078f : 28              >            plp
                        
0790 : 48                       pha
                                tst_a 1,$ff
0791 : 08              >            php         ;save flags
0792 : c901            >            cmp #1     ;test result
                       >            trap_ne
0794 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0796 : 68              >            pla         ;load status
0797 : 48              >            pha
                       >            cmp_flag $ff
0798 : 0908            >            ora #decmode        ;ignore decimal mode bit
079a : c9fb            >            cmp #($ff|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
079c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
079e : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
079f : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
07a1 : 48              >            pha         ;use stack to load status
07a2 : a900            >            lda #0     ;precharge accu
07a4 : 28              >            plp
                        
07a5 : 48                       pha
                                tst_a 0,0
07a6 : 08              >            php         ;save flags
07a7 : c900            >            cmp #0     ;test result
                       >            trap_ne
07a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07ab : 68              >            pla         ;load status
07ac : 48              >            pha
                       >            cmp_flag 0
07ad : 0908            >            ora #decmode        ;ignore decimal mode bit
07af : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
07b1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07b3 : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
07b4 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
07b6 : 48              >            pha         ;use stack to load status
07b7 : a9ff            >            lda #$ff     ;precharge accu
07b9 : 28              >            plp
                        
07ba : 48                       pha
                                tst_a $ff,$ff
07bb : 08              >            php         ;save flags
07bc : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07be : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07c0 : 68              >            pla         ;load status
07c1 : 48              >            pha
                       >            cmp_flag $ff
07c2 : 0908            >            ora #decmode        ;ignore decimal mode bit
07c4 : c9fb            >            cmp #($ff|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
07c6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07c8 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
07c9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
07cb : 48              >            pha         ;use stack to load status
07cc : a901            >            lda #1     ;precharge accu
07ce : 28              >            plp
                        
07cf : 48                       pha
                                tst_a 1,0
07d0 : 08              >            php         ;save flags
07d1 : c901            >            cmp #1     ;test result
                       >            trap_ne
07d3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07d5 : 68              >            pla         ;load status
07d6 : 48              >            pha
                       >            cmp_flag 0
07d7 : 0908            >            ora #decmode        ;ignore decimal mode bit
07d9 : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
07db : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07dd : 28              >            plp         ;restore status
                        
                                set_a 0,$ff
                       >            load_flag $ff
07de : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
07e0 : 48              >            pha         ;use stack to load status
07e1 : a900            >            lda #0     ;precharge accu
07e3 : 28              >            plp
                        
07e4 : 48                       pha
                                tst_a 0,$ff
07e5 : 08              >            php         ;save flags
07e6 : c900            >            cmp #0     ;test result
                       >            trap_ne
07e8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07ea : 68              >            pla         ;load status
07eb : 48              >            pha
                       >            cmp_flag $ff
07ec : 0908            >            ora #decmode        ;ignore decimal mode bit
07ee : c9fb            >            cmp #($ff|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
07f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07f2 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
07f3 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
07f5 : 48              >            pha         ;use stack to load status
07f6 : a9ff            >            lda #$ff     ;precharge accu
07f8 : 28              >            plp
                        
07f9 : 48                       pha
                                tst_a $ff,0
07fa : 08              >            php         ;save flags
07fb : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07fd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07ff : 68              >            pla         ;load status
0800 : 48              >            pha
                       >            cmp_flag 0
0801 : 0908            >            ora #decmode        ;ignore decimal mode bit
0803 : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0805 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0807 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff     ;pull
                       >            load_flag $ff     
0808 : a9fb            >            lda #$ff     &m8i         ;force enable interrupts (mask I)
                       >
080a : 48              >            pha         ;use stack to load status
080b : a900            >            lda #0     ;precharge accu
080d : 28              >            plp
                        
080e : 68                       pla
                                tst_a $ff,$ff-zero
080f : 08              >            php         ;save flags
0810 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0812 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0814 : 68              >            pla         ;load status
0815 : 48              >            pha
                       >            cmp_flag $ff-zero
0816 : 0908            >            ora #decmode        ;ignore decimal mode bit
0818 : c9f9            >            cmp #($ff-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
081a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
081c : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
081d : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
081f : 48              >            pha         ;use stack to load status
0820 : a9ff            >            lda #$ff     ;precharge accu
0822 : 28              >            plp
                        
0823 : 68                       pla
                                tst_a 0,zero
0824 : 08              >            php         ;save flags
0825 : c900            >            cmp #0     ;test result
                       >            trap_ne
0827 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0829 : 68              >            pla         ;load status
082a : 48              >            pha
                       >            cmp_flag zero
082b : 0908            >            ora #decmode        ;ignore decimal mode bit
082d : c93a            >            cmp #(zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
082f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0831 : 28              >            plp         ;restore status
                        
                                set_a $fe,$ff
                       >            load_flag $ff
0832 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0834 : 48              >            pha         ;use stack to load status
0835 : a9fe            >            lda #$fe     ;precharge accu
0837 : 28              >            plp
                        
0838 : 68                       pla
                                tst_a 1,$ff-zero-minus
0839 : 08              >            php         ;save flags
083a : c901            >            cmp #1     ;test result
                       >            trap_ne
083c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
083e : 68              >            pla         ;load status
083f : 48              >            pha
                       >            cmp_flag $ff-zero-minus
0840 : 0908            >            ora #decmode        ;ignore decimal mode bit
0842 : c979            >            cmp #($ff-zero-minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0844 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0846 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
0847 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0849 : 48              >            pha         ;use stack to load status
084a : a900            >            lda #0     ;precharge accu
084c : 28              >            plp
                        
084d : 68                       pla
                                tst_a $ff,minus
084e : 08              >            php         ;save flags
084f : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0851 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0853 : 68              >            pla         ;load status
0854 : 48              >            pha
                       >            cmp_flag minus
0855 : 0908            >            ora #decmode        ;ignore decimal mode bit
0857 : c9b8            >            cmp #(minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0859 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
085b : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
085c : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
085e : 48              >            pha         ;use stack to load status
085f : a9ff            >            lda #$ff     ;precharge accu
0861 : 28              >            plp
                        
0862 : 68                       pla
                                tst_a 0,$ff-minus
0863 : 08              >            php         ;save flags
0864 : c900            >            cmp #0     ;test result
                       >            trap_ne
0866 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0868 : 68              >            pla         ;load status
0869 : 48              >            pha
                       >            cmp_flag $ff-minus
086a : 0908            >            ora #decmode        ;ignore decimal mode bit
086c : c97b            >            cmp #($ff-minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
086e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0870 : 28              >            plp         ;restore status
                        
                                set_a $fe,0
                       >            load_flag 0
0871 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0873 : 48              >            pha         ;use stack to load status
0874 : a9fe            >            lda #$fe     ;precharge accu
0876 : 28              >            plp
                        
0877 : 68                       pla
                                tst_a 1,0
0878 : 08              >            php         ;save flags
0879 : c901            >            cmp #1     ;test result
                       >            trap_ne
087b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
087d : 68              >            pla         ;load status
087e : 48              >            pha
                       >            cmp_flag 0
087f : 0908            >            ora #decmode        ;ignore decimal mode bit
0881 : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0883 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0885 : 28              >            plp         ;restore status
                        
0886 : e055                     cpx #$55        ;x & y unchanged?
                                trap_ne
0888 : d0fe            >        bne *           ;failed not equal (non zero)
                        
088a : c0aa                     cpy #$aa
                                trap_ne
088c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
088e : ad0002          >            lda test_case   ;previous test
0891 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0893 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
0895 : a906            >            lda #test_num   ;*** next tests' number
0897 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; partial pretest EOR #
                                set_a $3c,0
                       >            load_flag 0
089a : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
089c : 48              >            pha         ;use stack to load status
089d : a93c            >            lda #$3c     ;precharge accu
089f : 28              >            plp
                        
08a0 : 49c3                     eor #$c3
                                tst_a $ff,fn
08a2 : 08              >            php         ;save flags
08a3 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
08a5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08a7 : 68              >            pla         ;load status
08a8 : 48              >            pha
                       >            cmp_flag fn
08a9 : 0908            >            ora #decmode        ;ignore decimal mode bit
08ab : c9b8            >            cmp #(fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
08ad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08af : 28              >            plp         ;restore status
                        
                                set_a $c3,0
                       >            load_flag 0
08b0 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
08b2 : 48              >            pha         ;use stack to load status
08b3 : a9c3            >            lda #$c3     ;precharge accu
08b5 : 28              >            plp
                        
08b6 : 49c3                     eor #$c3
                                tst_a 0,fz
08b8 : 08              >            php         ;save flags
08b9 : c900            >            cmp #0     ;test result
                       >            trap_ne
08bb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08bd : 68              >            pla         ;load status
08be : 48              >            pha
                       >            cmp_flag fz
08bf : 0908            >            ora #decmode        ;ignore decimal mode bit
08c1 : c93a            >            cmp #(fz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
08c3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08c5 : 28              >            plp         ;restore status
                        
                                next_test
08c6 : ad0002          >            lda test_case   ;previous test
08c9 : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08cb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
08cd : a907            >            lda #test_num   ;*** next tests' number
08cf : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
                        ; testing NOP
08d2 : a224                     ldx #$24
08d4 : a042                     ldy #$42
                                set_a $18,0
                       >            load_flag 0
08d6 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
08d8 : 48              >            pha         ;use stack to load status
08d9 : a918            >            lda #$18     ;precharge accu
08db : 28              >            plp
                        
08dc : ea                       nop
                                tst_a $18,0
08dd : 08              >            php         ;save flags
08de : c918            >            cmp #$18     ;test result
                       >            trap_ne
08e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08e2 : 68              >            pla         ;load status
08e3 : 48              >            pha
                       >            cmp_flag 0
08e4 : 0908            >            ora #decmode        ;ignore decimal mode bit
08e6 : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
08e8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08ea : 28              >            plp         ;restore status
                        
08eb : e024                     cpx #$24
                                trap_ne
08ed : d0fe            >        bne *           ;failed not equal (non zero)
                        
08ef : c042                     cpy #$42
                                trap_ne
08f1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
08f3 : a2db                     ldx #$db
08f5 : a0bd                     ldy #$bd
                                set_a $e7,$ff
                       >            load_flag $ff
08f7 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
08f9 : 48              >            pha         ;use stack to load status
08fa : a9e7            >            lda #$e7     ;precharge accu
08fc : 28              >            plp
                        
08fd : ea                       nop
                                tst_a $e7,$ff
08fe : 08              >            php         ;save flags
08ff : c9e7            >            cmp #$e7     ;test result
                       >            trap_ne
0901 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0903 : 68              >            pla         ;load status
0904 : 48              >            pha
                       >            cmp_flag $ff
0905 : 0908            >            ora #decmode        ;ignore decimal mode bit
0907 : c9fb            >            cmp #($ff|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0909 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
090b : 28              >            plp         ;restore status
                        
090c : e0db                     cpx #$db
                                trap_ne
090e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0910 : c0bd                     cpy #$bd
                                trap_ne
0912 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0914 : ad0002          >            lda test_case   ;previous test
0917 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0919 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
091b : a908            >            lda #test_num   ;*** next tests' number
091d : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump absolute
                                set_stat $0
                       >            load_flag $0
0920 : a900            >            lda #$0&m8i         ;force enable interrupts (mask I)
                       >
0922 : 48              >            pha         ;use stack to load status
0923 : 28              >            plp
                        
0924 : a946                     lda #'F'
0926 : a241                     ldx #'A'
0928 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
092a : 4cd337                   jmp test_far
092d : ea                       nop
092e : ea                       nop
                                trap_ne         ;runover protection
092f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0931 : e8                       inx
0932 : e8                       inx
0933 :                  far_ret 
                                trap_eq         ;returned flags OK?
0933 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0935 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0937 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0939 : 50fe            >        bvc *           ;failed overflow clear
                        
093b : c9ec                     cmp #('F'^$aa)  ;returned registers OK?
                                trap_ne
093d : d0fe            >        bne *           ;failed not equal (non zero)
                        
093f : e042                     cpx #('A'+1)
                                trap_ne
0941 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0943 : c04f                     cpy #('R'-3)
                                trap_ne
0945 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0947 : ca                       dex
0948 : c8                       iny
0949 : c8                       iny
094a : c8                       iny
094b : 49aa                     eor #$aa        ;N=0, V=1, Z=0, C=1
094d : 4c5609                   jmp test_near
0950 : ea                       nop
0951 : ea                       nop
                                trap_ne         ;runover protection
0952 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0954 : e8                       inx
0955 : e8                       inx
0956 :                  test_near
                                trap_eq         ;passed flags OK?
0956 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_mi
0958 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_cc
095a : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
095c : 50fe            >        bvc *           ;failed overflow clear
                        
095e : c946                     cmp #'F'        ;passed registers OK?
                                trap_ne
0960 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0962 : e041                     cpx #'A'
                                trap_ne
0964 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0966 : c052                     cpy #'R'
                                trap_ne
0968 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
096a : ad0002          >            lda test_case   ;previous test
096d : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
096f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
0971 : a909            >            lda #test_num   ;*** next tests' number
0973 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump indirect
                                set_stat 0
                       >            load_flag 0
0976 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0978 : 48              >            pha         ;use stack to load status
0979 : 28              >            plp
                        
097a : a949                     lda #'I'
097c : a24e                     ldx #'N'
097e : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
0980 : 6c0238                   jmp (ptr_tst_ind)
0983 : ea                       nop
                                trap_ne         ;runover protection
0984 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0986 : 88                       dey
0987 : 88                       dey
0988 :                  ind_ret 
0988 : 08                       php             ;either SP or Y count will fail, if we do not hit
0989 : 88                       dey
098a : 88                       dey
098b : 88                       dey
098c : 28                       plp
                                trap_eq         ;returned flags OK?
098d : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
098f : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0991 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0993 : 50fe            >        bvc *           ;failed overflow clear
                        
0995 : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
0997 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0999 : e04f                     cpx #('N'+1)
                                trap_ne
099b : d0fe            >        bne *           ;failed not equal (non zero)
                        
099d : c03e                     cpy #('D'-6)
                                trap_ne
099f : d0fe            >        bne *           ;failed not equal (non zero)
                        
09a1 : ba                       tsx             ;SP check
09a2 : e0ff                     cpx #$ff
                                trap_ne
09a4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
09a6 : ad0002          >            lda test_case   ;previous test
09a9 : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
09ab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
09ad : a90a            >            lda #test_num   ;*** next tests' number
09af : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump subroutine & return from subroutine
                                set_stat 0
                       >            load_flag 0
09b2 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
09b4 : 48              >            pha         ;use stack to load status
09b5 : 28              >            plp
                        
09b6 : a94a                     lda #'J'
09b8 : a253                     ldx #'S'
09ba : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
09bc : 204138                   jsr test_jsr
09be =                  jsr_ret = *-1           ;last address of jsr = return address
09bf : 08                       php             ;either SP or Y count will fail, if we do not hit
09c0 : 88                       dey
09c1 : 88                       dey
09c2 : 88                       dey
09c3 : 28                       plp
                                trap_eq         ;returned flags OK?
09c4 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
09c6 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
09c8 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
09ca : 50fe            >        bvc *           ;failed overflow clear
                        
09cc : c9e0                     cmp #('J'^$aa)  ;returned registers OK?
                                trap_ne
09ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
09d0 : e054                     cpx #('S'+1)
                                trap_ne
09d2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09d4 : c04c                     cpy #('R'-6)
                                trap_ne
09d6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09d8 : ba                       tsx             ;sp?
09d9 : e0ff                     cpx #$ff
                                trap_ne
09db : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
09dd : ad0002          >            lda test_case   ;previous test
09e0 : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
09e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
09e4 : a90b            >            lda #test_num   ;*** next tests' number
09e6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; break & return from interrupt
                            if ROM_vectors = 1
                                load_flag 0     ;with interrupts enabled if allowed!
                                pha
                                lda #'B'
                                ldx #'R'
                                ldy #'K'
                                plp             ;N=0, V=0, Z=0, C=0
                                brk
                            else
09e9 : a90a                     lda #hi brk_ret0 ;emulated break
09eb : 48                       pha
09ec : a900                     lda #lo brk_ret0
09ee : 48                       pha
                                load_flag fao    ;set break & unused on stack
09ef : a930            >            lda #fao    &m8i         ;force enable interrupts (mask I)
                        
09f1 : 48                       pha
                                load_flag intdis ;during interrupt
09f2 : a900            >            lda #intdis &m8i         ;force enable interrupts (mask I)
                        
09f4 : 48                       pha
09f5 : a942                     lda #'B'
09f7 : a252                     ldx #'R'
09f9 : a04b                     ldy #'K'
09fb : 28                       plp             ;N=0, V=0, Z=0, C=0
09fc : 4c8f38                   jmp irq_trap
                            endif
09ff : 88                       dey             ;should not be executed
0a00 :                  brk_ret0                ;address of break return
0a00 : 08                       php             ;either SP or Y count will fail, if we do not hit
0a01 : 88                       dey
0a02 : 88                       dey
0a03 : 88                       dey
0a04 : c9e8                     cmp #'B'^$aa    ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
0a06 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a08 : e053                     cpx #'R'+1
                                trap_ne
0a0a : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a0c : c045                     cpy #'K'-6
                                trap_ne
0a0e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a10 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
0a11 : 0908            >            ora #decmode        ;ignore decimal mode bit
0a13 : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
0a15 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a17 : ba                       tsx             ;sp?
0a18 : e0ff                     cpx #$ff
                                trap_ne
0a1a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                            if ROM_vectors = 1
                                load_flag $ff   ;with interrupts disabled if allowed!
                                pha
                                lda #$ff-'B'
                                ldx #$ff-'R'
                                ldy #$ff-'K'
                                plp             ;N=1, V=1, Z=1, C=1
                                brk
                            else
0a1c : a90a                     lda #hi brk_ret1 ;emulated break
0a1e : 48                       pha
0a1f : a931                     lda #lo brk_ret1
0a21 : 48                       pha
                                load_flag $ff
0a22 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                        
0a24 : 48                       pha             ;set break & unused on stack
0a25 : 48                       pha             ;actual flags
0a26 : a9bd                     lda #$ff-'B'
0a28 : a2ad                     ldx #$ff-'R'
0a2a : a0b4                     ldy #$ff-'K'
0a2c : 28                       plp             ;N=1, V=1, Z=1, C=1
0a2d : 4c8f38                   jmp irq_trap
                            endif
0a30 : 88                       dey             ;should not be executed
0a31 :                  brk_ret1                ;address of break return
0a31 : 08                       php             ;either SP or Y count will fail, if we do not hit
0a32 : 88                       dey
0a33 : 88                       dey
0a34 : 88                       dey
0a35 : c917                     cmp #($ff-'B')^$aa  ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
0a37 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a39 : e0ae                     cpx #$ff-'R'+1
                                trap_ne
0a3b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a3d : c0ae                     cpy #$ff-'K'-6
                                trap_ne
0a3f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a41 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag $ff
0a42 : 0908            >            ora #decmode        ;ignore decimal mode bit
0a44 : c9fb            >            cmp #($ff|faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
0a46 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a48 : ba                       tsx             ;sp?
0a49 : e0ff                     cpx #$ff
                                trap_ne
0a4b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0a4d : ad0002          >            lda test_case   ;previous test
0a50 : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0a52 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
0a54 : a90c            >            lda #test_num   ;*** next tests' number
0a56 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
                                set_stat $ff
                       >            load_flag $ff
0a59 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0a5b : 48              >            pha         ;use stack to load status
0a5c : 28              >            plp
                        
0a5d : 18                       clc
                                tst_stat $ff-carry
0a5e : 08              >            php         ;save status
0a5f : 68              >            pla         ;use stack to retrieve status
0a60 : 48              >            pha
                       >            cmp_flag $ff-carry
0a61 : 0908            >            ora #decmode        ;ignore decimal mode bit
0a63 : c9fa            >            cmp #($ff-carry|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a65 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a67 : 28              >            plp         ;restore status
                        
0a68 : 38                       sec
                                tst_stat $ff
0a69 : 08              >            php         ;save status
0a6a : 68              >            pla         ;use stack to retrieve status
0a6b : 48              >            pha
                       >            cmp_flag $ff
0a6c : 0908            >            ora #decmode        ;ignore decimal mode bit
0a6e : c9fb            >            cmp #($ff|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a72 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
                                cli
                                tst_stat $ff-intdis
                                sei
                                tst_stat $ff
                            endif
0a73 : d8                       cld
                                tst_stat $ff-decmode
0a74 : 08              >            php         ;save status
0a75 : 68              >            pla         ;use stack to retrieve status
0a76 : 48              >            pha
                       >            cmp_flag $ff-decmode
0a77 : 0908            >            ora #decmode        ;ignore decimal mode bit
0a79 : c9fb            >            cmp #($ff-decmode|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a7d : 28              >            plp         ;restore status
                        
0a7e : f8                       sed
                                tst_stat $ff
0a7f : 08              >            php         ;save status
0a80 : 68              >            pla         ;use stack to retrieve status
0a81 : 48              >            pha
                       >            cmp_flag $ff
0a82 : 0908            >            ora #decmode        ;ignore decimal mode bit
0a84 : c9fb            >            cmp #($ff|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a86 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a88 : 28              >            plp         ;restore status
                        
0a89 : b8                       clv
                                tst_stat $ff-overfl
0a8a : 08              >            php         ;save status
0a8b : 68              >            pla         ;use stack to retrieve status
0a8c : 48              >            pha
                       >            cmp_flag $ff-overfl
0a8d : 0908            >            ora #decmode        ;ignore decimal mode bit
0a8f : c9bb            >            cmp #($ff-overfl|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a91 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a93 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0a94 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0a96 : 48              >            pha         ;use stack to load status
0a97 : 28              >            plp
                        
                                tst_stat 0
0a98 : 08              >            php         ;save status
0a99 : 68              >            pla         ;use stack to retrieve status
0a9a : 48              >            pha
                       >            cmp_flag 0
0a9b : 0908            >            ora #decmode        ;ignore decimal mode bit
0a9d : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0a9f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aa1 : 28              >            plp         ;restore status
                        
0aa2 : 38                       sec
                                tst_stat carry
0aa3 : 08              >            php         ;save status
0aa4 : 68              >            pla         ;use stack to retrieve status
0aa5 : 48              >            pha
                       >            cmp_flag carry
0aa6 : 0908            >            ora #decmode        ;ignore decimal mode bit
0aa8 : c939            >            cmp #(carry|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0aaa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aac : 28              >            plp         ;restore status
                        
0aad : 18                       clc
                                tst_stat 0  
0aae : 08              >            php         ;save status
0aaf : 68              >            pla         ;use stack to retrieve status
0ab0 : 48              >            pha
                       >            cmp_flag 0  
0ab1 : 0908            >            ora #decmode        ;ignore decimal mode bit
0ab3 : c938            >            cmp #(0  |faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0ab5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ab7 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
                                sei
                                tst_stat intdis
                                cli
                                tst_stat 0
                            endif  
0ab8 : f8                       sed
                                tst_stat decmode
0ab9 : 08              >            php         ;save status
0aba : 68              >            pla         ;use stack to retrieve status
0abb : 48              >            pha
                       >            cmp_flag decmode
0abc : 0908            >            ora #decmode        ;ignore decimal mode bit
0abe : c938            >            cmp #(decmode|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0ac0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ac2 : 28              >            plp         ;restore status
                        
0ac3 : d8                       cld
                                tst_stat 0  
0ac4 : 08              >            php         ;save status
0ac5 : 68              >            pla         ;use stack to retrieve status
0ac6 : 48              >            pha
                       >            cmp_flag 0  
0ac7 : 0908            >            ora #decmode        ;ignore decimal mode bit
0ac9 : c938            >            cmp #(0  |faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0acb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0acd : 28              >            plp         ;restore status
                        
                                set_stat overfl
                       >            load_flag overfl
0ace : a940            >            lda #overfl&m8i         ;force enable interrupts (mask I)
                       >
0ad0 : 48              >            pha         ;use stack to load status
0ad1 : 28              >            plp
                        
                                tst_stat overfl
0ad2 : 08              >            php         ;save status
0ad3 : 68              >            pla         ;use stack to retrieve status
0ad4 : 48              >            pha
                       >            cmp_flag overfl
0ad5 : 0908            >            ora #decmode        ;ignore decimal mode bit
0ad7 : c978            >            cmp #(overfl|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0ad9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0adb : 28              >            plp         ;restore status
                        
0adc : b8                       clv
                                tst_stat 0
0add : 08              >            php         ;save status
0ade : 68              >            pla         ;use stack to retrieve status
0adf : 48              >            pha
                       >            cmp_flag 0
0ae0 : 0908            >            ora #decmode        ;ignore decimal mode bit
0ae2 : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0ae4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ae6 : 28              >            plp         ;restore status
                        
                                next_test
0ae7 : ad0002          >            lda test_case   ;previous test
0aea : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0aec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
0aee : a90d            >            lda #test_num   ;*** next tests' number
0af0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ; testing index register increment/decrement and transfer
                        ; INX INY DEX DEY TAX TXA TAY TYA 
0af3 : a2fe                     ldx #$fe
                                set_stat $ff
                       >            load_flag $ff
0af5 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0af7 : 48              >            pha         ;use stack to load status
0af8 : 28              >            plp
                        
0af9 : e8                       inx             ;ff
                                tst_x $ff,$ff-zero
0afa : 08              >            php         ;save flags
0afb : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0afd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aff : 68              >            pla         ;load status
0b00 : 48              >            pha
                       >            cmp_flag $ff-zero
0b01 : 0908            >            ora #decmode        ;ignore decimal mode bit
0b03 : c9f9            >            cmp #($ff-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b05 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b07 : 28              >            plp         ;restore status
                        
0b08 : e8                       inx             ;00
                                tst_x 0,$ff-minus
0b09 : 08              >            php         ;save flags
0b0a : e000            >            cpx #0     ;test result
                       >            trap_ne
0b0c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b0e : 68              >            pla         ;load status
0b0f : 48              >            pha
                       >            cmp_flag $ff-minus
0b10 : 0908            >            ora #decmode        ;ignore decimal mode bit
0b12 : c97b            >            cmp #($ff-minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b14 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b16 : 28              >            plp         ;restore status
                        
0b17 : e8                       inx             ;01
                                tst_x 1,$ff-minus-zero
0b18 : 08              >            php         ;save flags
0b19 : e001            >            cpx #1     ;test result
                       >            trap_ne
0b1b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b1d : 68              >            pla         ;load status
0b1e : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0b1f : 0908            >            ora #decmode        ;ignore decimal mode bit
0b21 : c979            >            cmp #($ff-minus-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b23 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b25 : 28              >            plp         ;restore status
                        
0b26 : ca                       dex             ;00
                                tst_x 0,$ff-minus
0b27 : 08              >            php         ;save flags
0b28 : e000            >            cpx #0     ;test result
                       >            trap_ne
0b2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b2c : 68              >            pla         ;load status
0b2d : 48              >            pha
                       >            cmp_flag $ff-minus
0b2e : 0908            >            ora #decmode        ;ignore decimal mode bit
0b30 : c97b            >            cmp #($ff-minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b32 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b34 : 28              >            plp         ;restore status
                        
0b35 : ca                       dex             ;ff
                                tst_x $ff,$ff-zero
0b36 : 08              >            php         ;save flags
0b37 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0b39 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b3b : 68              >            pla         ;load status
0b3c : 48              >            pha
                       >            cmp_flag $ff-zero
0b3d : 0908            >            ora #decmode        ;ignore decimal mode bit
0b3f : c9f9            >            cmp #($ff-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b41 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b43 : 28              >            plp         ;restore status
                        
0b44 : ca                       dex             ;fe
                                set_stat 0
                       >            load_flag 0
0b45 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0b47 : 48              >            pha         ;use stack to load status
0b48 : 28              >            plp
                        
0b49 : e8                       inx             ;ff
                                tst_x $ff,minus
0b4a : 08              >            php         ;save flags
0b4b : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0b4d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b4f : 68              >            pla         ;load status
0b50 : 48              >            pha
                       >            cmp_flag minus
0b51 : 0908            >            ora #decmode        ;ignore decimal mode bit
0b53 : c9b8            >            cmp #(minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b55 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b57 : 28              >            plp         ;restore status
                        
0b58 : e8                       inx             ;00
                                tst_x 0,zero
0b59 : 08              >            php         ;save flags
0b5a : e000            >            cpx #0     ;test result
                       >            trap_ne
0b5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b5e : 68              >            pla         ;load status
0b5f : 48              >            pha
                       >            cmp_flag zero
0b60 : 0908            >            ora #decmode        ;ignore decimal mode bit
0b62 : c93a            >            cmp #(zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b66 : 28              >            plp         ;restore status
                        
0b67 : e8                       inx             ;01
                                tst_x 1,0
0b68 : 08              >            php         ;save flags
0b69 : e001            >            cpx #1     ;test result
                       >            trap_ne
0b6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b6d : 68              >            pla         ;load status
0b6e : 48              >            pha
                       >            cmp_flag 0
0b6f : 0908            >            ora #decmode        ;ignore decimal mode bit
0b71 : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b73 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b75 : 28              >            plp         ;restore status
                        
0b76 : ca                       dex             ;00
                                tst_x 0,zero
0b77 : 08              >            php         ;save flags
0b78 : e000            >            cpx #0     ;test result
                       >            trap_ne
0b7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b7c : 68              >            pla         ;load status
0b7d : 48              >            pha
                       >            cmp_flag zero
0b7e : 0908            >            ora #decmode        ;ignore decimal mode bit
0b80 : c93a            >            cmp #(zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b82 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b84 : 28              >            plp         ;restore status
                        
0b85 : ca                       dex             ;ff
                                tst_x $ff,minus
0b86 : 08              >            php         ;save flags
0b87 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0b89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b8b : 68              >            pla         ;load status
0b8c : 48              >            pha
                       >            cmp_flag minus
0b8d : 0908            >            ora #decmode        ;ignore decimal mode bit
0b8f : c9b8            >            cmp #(minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0b91 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b93 : 28              >            plp         ;restore status
                        
                        
0b94 : a0fe                     ldy #$fe
                                set_stat $ff
                       >            load_flag $ff
0b96 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0b98 : 48              >            pha         ;use stack to load status
0b99 : 28              >            plp
                        
0b9a : c8                       iny             ;ff
                                tst_y $ff,$ff-zero
0b9b : 08              >            php         ;save flags
0b9c : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ba0 : 68              >            pla         ;load status
0ba1 : 48              >            pha
                       >            cmp_flag $ff-zero
0ba2 : 0908            >            ora #decmode        ;ignore decimal mode bit
0ba4 : c9f9            >            cmp #($ff-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0ba6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ba8 : 28              >            plp         ;restore status
                        
0ba9 : c8                       iny             ;00
                                tst_y 0,$ff-minus
0baa : 08              >            php         ;save flags
0bab : c000            >            cpy #0     ;test result
                       >            trap_ne
0bad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0baf : 68              >            pla         ;load status
0bb0 : 48              >            pha
                       >            cmp_flag $ff-minus
0bb1 : 0908            >            ora #decmode        ;ignore decimal mode bit
0bb3 : c97b            >            cmp #($ff-minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0bb5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bb7 : 28              >            plp         ;restore status
                        
0bb8 : c8                       iny             ;01
                                tst_y 1,$ff-minus-zero
0bb9 : 08              >            php         ;save flags
0bba : c001            >            cpy #1     ;test result
                       >            trap_ne
0bbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bbe : 68              >            pla         ;load status
0bbf : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0bc0 : 0908            >            ora #decmode        ;ignore decimal mode bit
0bc2 : c979            >            cmp #($ff-minus-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0bc4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bc6 : 28              >            plp         ;restore status
                        
0bc7 : 88                       dey             ;00
                                tst_y 0,$ff-minus
0bc8 : 08              >            php         ;save flags
0bc9 : c000            >            cpy #0     ;test result
                       >            trap_ne
0bcb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bcd : 68              >            pla         ;load status
0bce : 48              >            pha
                       >            cmp_flag $ff-minus
0bcf : 0908            >            ora #decmode        ;ignore decimal mode bit
0bd1 : c97b            >            cmp #($ff-minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0bd3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bd5 : 28              >            plp         ;restore status
                        
0bd6 : 88                       dey             ;ff
                                tst_y $ff,$ff-zero
0bd7 : 08              >            php         ;save flags
0bd8 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0bda : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bdc : 68              >            pla         ;load status
0bdd : 48              >            pha
                       >            cmp_flag $ff-zero
0bde : 0908            >            ora #decmode        ;ignore decimal mode bit
0be0 : c9f9            >            cmp #($ff-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0be2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0be4 : 28              >            plp         ;restore status
                        
0be5 : 88                       dey             ;fe
                                set_stat 0
                       >            load_flag 0
0be6 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0be8 : 48              >            pha         ;use stack to load status
0be9 : 28              >            plp
                        
0bea : c8                       iny             ;ff
                                tst_y $ff,0+minus
0beb : 08              >            php         ;save flags
0bec : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0bee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bf0 : 68              >            pla         ;load status
0bf1 : 48              >            pha
                       >            cmp_flag 0+minus
0bf2 : 0908            >            ora #decmode        ;ignore decimal mode bit
0bf4 : c9b8            >            cmp #(0+minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0bf6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bf8 : 28              >            plp         ;restore status
                        
0bf9 : c8                       iny             ;00
                                tst_y 0,zero
0bfa : 08              >            php         ;save flags
0bfb : c000            >            cpy #0     ;test result
                       >            trap_ne
0bfd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bff : 68              >            pla         ;load status
0c00 : 48              >            pha
                       >            cmp_flag zero
0c01 : 0908            >            ora #decmode        ;ignore decimal mode bit
0c03 : c93a            >            cmp #(zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c05 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c07 : 28              >            plp         ;restore status
                        
0c08 : c8                       iny             ;01
                                tst_y 1,0
0c09 : 08              >            php         ;save flags
0c0a : c001            >            cpy #1     ;test result
                       >            trap_ne
0c0c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c0e : 68              >            pla         ;load status
0c0f : 48              >            pha
                       >            cmp_flag 0
0c10 : 0908            >            ora #decmode        ;ignore decimal mode bit
0c12 : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c14 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c16 : 28              >            plp         ;restore status
                        
0c17 : 88                       dey             ;00
                                tst_y 0,zero
0c18 : 08              >            php         ;save flags
0c19 : c000            >            cpy #0     ;test result
                       >            trap_ne
0c1b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c1d : 68              >            pla         ;load status
0c1e : 48              >            pha
                       >            cmp_flag zero
0c1f : 0908            >            ora #decmode        ;ignore decimal mode bit
0c21 : c93a            >            cmp #(zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c23 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c25 : 28              >            plp         ;restore status
                        
0c26 : 88                       dey             ;ff
                                tst_y $ff,minus
0c27 : 08              >            php         ;save flags
0c28 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0c2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c2c : 68              >            pla         ;load status
0c2d : 48              >            pha
                       >            cmp_flag minus
0c2e : 0908            >            ora #decmode        ;ignore decimal mode bit
0c30 : c9b8            >            cmp #(minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c32 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c34 : 28              >            plp         ;restore status
                        
                                        
0c35 : a2ff                     ldx #$ff
                                set_stat $ff
                       >            load_flag $ff
0c37 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0c39 : 48              >            pha         ;use stack to load status
0c3a : 28              >            plp
                        
0c3b : 8a                       txa
                                tst_a $ff,$ff-zero
0c3c : 08              >            php         ;save flags
0c3d : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c3f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c41 : 68              >            pla         ;load status
0c42 : 48              >            pha
                       >            cmp_flag $ff-zero
0c43 : 0908            >            ora #decmode        ;ignore decimal mode bit
0c45 : c9f9            >            cmp #($ff-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c47 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c49 : 28              >            plp         ;restore status
                        
0c4a : 08                       php
0c4b : e8                       inx             ;00
0c4c : 28                       plp
0c4d : 8a                       txa
                                tst_a 0,$ff-minus
0c4e : 08              >            php         ;save flags
0c4f : c900            >            cmp #0     ;test result
                       >            trap_ne
0c51 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c53 : 68              >            pla         ;load status
0c54 : 48              >            pha
                       >            cmp_flag $ff-minus
0c55 : 0908            >            ora #decmode        ;ignore decimal mode bit
0c57 : c97b            >            cmp #($ff-minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c59 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c5b : 28              >            plp         ;restore status
                        
0c5c : 08                       php
0c5d : e8                       inx             ;01
0c5e : 28                       plp
0c5f : 8a                       txa
                                tst_a 1,$ff-minus-zero
0c60 : 08              >            php         ;save flags
0c61 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c63 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c65 : 68              >            pla         ;load status
0c66 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0c67 : 0908            >            ora #decmode        ;ignore decimal mode bit
0c69 : c979            >            cmp #($ff-minus-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c6d : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0c6e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0c70 : 48              >            pha         ;use stack to load status
0c71 : 28              >            plp
                        
0c72 : 8a                       txa
                                tst_a 1,0
0c73 : 08              >            php         ;save flags
0c74 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c76 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c78 : 68              >            pla         ;load status
0c79 : 48              >            pha
                       >            cmp_flag 0
0c7a : 0908            >            ora #decmode        ;ignore decimal mode bit
0c7c : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c80 : 28              >            plp         ;restore status
                        
0c81 : 08                       php
0c82 : ca                       dex             ;00
0c83 : 28                       plp
0c84 : 8a                       txa
                                tst_a 0,zero
0c85 : 08              >            php         ;save flags
0c86 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c88 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c8a : 68              >            pla         ;load status
0c8b : 48              >            pha
                       >            cmp_flag zero
0c8c : 0908            >            ora #decmode        ;ignore decimal mode bit
0c8e : c93a            >            cmp #(zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0c90 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c92 : 28              >            plp         ;restore status
                        
0c93 : 08                       php
0c94 : ca                       dex             ;ff
0c95 : 28                       plp
0c96 : 8a                       txa
                                tst_a $ff,minus
0c97 : 08              >            php         ;save flags
0c98 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c9a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c9c : 68              >            pla         ;load status
0c9d : 48              >            pha
                       >            cmp_flag minus
0c9e : 0908            >            ora #decmode        ;ignore decimal mode bit
0ca0 : c9b8            >            cmp #(minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0ca2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ca4 : 28              >            plp         ;restore status
                        
                                                
0ca5 : a0ff                     ldy #$ff
                                set_stat $ff
                       >            load_flag $ff
0ca7 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0ca9 : 48              >            pha         ;use stack to load status
0caa : 28              >            plp
                        
0cab : 98                       tya
                                tst_a $ff,$ff-zero
0cac : 08              >            php         ;save flags
0cad : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0caf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cb1 : 68              >            pla         ;load status
0cb2 : 48              >            pha
                       >            cmp_flag $ff-zero
0cb3 : 0908            >            ora #decmode        ;ignore decimal mode bit
0cb5 : c9f9            >            cmp #($ff-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0cb7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cb9 : 28              >            plp         ;restore status
                        
0cba : 08                       php
0cbb : c8                       iny             ;00
0cbc : 28                       plp
0cbd : 98                       tya
                                tst_a 0,$ff-minus
0cbe : 08              >            php         ;save flags
0cbf : c900            >            cmp #0     ;test result
                       >            trap_ne
0cc1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cc3 : 68              >            pla         ;load status
0cc4 : 48              >            pha
                       >            cmp_flag $ff-minus
0cc5 : 0908            >            ora #decmode        ;ignore decimal mode bit
0cc7 : c97b            >            cmp #($ff-minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0cc9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ccb : 28              >            plp         ;restore status
                        
0ccc : 08                       php
0ccd : c8                       iny             ;01
0cce : 28                       plp
0ccf : 98                       tya
                                tst_a 1,$ff-minus-zero
0cd0 : 08              >            php         ;save flags
0cd1 : c901            >            cmp #1     ;test result
                       >            trap_ne
0cd3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cd5 : 68              >            pla         ;load status
0cd6 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0cd7 : 0908            >            ora #decmode        ;ignore decimal mode bit
0cd9 : c979            >            cmp #($ff-minus-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0cdb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cdd : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0cde : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0ce0 : 48              >            pha         ;use stack to load status
0ce1 : 28              >            plp
                        
0ce2 : 98                       tya
                                tst_a 1,0
0ce3 : 08              >            php         ;save flags
0ce4 : c901            >            cmp #1     ;test result
                       >            trap_ne
0ce6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ce8 : 68              >            pla         ;load status
0ce9 : 48              >            pha
                       >            cmp_flag 0
0cea : 0908            >            ora #decmode        ;ignore decimal mode bit
0cec : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0cee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cf0 : 28              >            plp         ;restore status
                        
0cf1 : 08                       php
0cf2 : 88                       dey             ;00
0cf3 : 28                       plp
0cf4 : 98                       tya
                                tst_a 0,zero
0cf5 : 08              >            php         ;save flags
0cf6 : c900            >            cmp #0     ;test result
                       >            trap_ne
0cf8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cfa : 68              >            pla         ;load status
0cfb : 48              >            pha
                       >            cmp_flag zero
0cfc : 0908            >            ora #decmode        ;ignore decimal mode bit
0cfe : c93a            >            cmp #(zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0d00 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d02 : 28              >            plp         ;restore status
                        
0d03 : 08                       php
0d04 : 88                       dey             ;ff
0d05 : 28                       plp
0d06 : 98                       tya
                                tst_a $ff,minus
0d07 : 08              >            php         ;save flags
0d08 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0d0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d0c : 68              >            pla         ;load status
0d0d : 48              >            pha
                       >            cmp_flag minus
0d0e : 0908            >            ora #decmode        ;ignore decimal mode bit
0d10 : c9b8            >            cmp #(minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0d12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d14 : 28              >            plp         ;restore status
                        
                        
                                load_flag $ff
0d15 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                        
0d17 : 48                       pha
0d18 : a2ff                     ldx #$ff        ;ff
0d1a : 8a                       txa
0d1b : 28                       plp             
0d1c : a8                       tay
                                tst_y $ff,$ff-zero
0d1d : 08              >            php         ;save flags
0d1e : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0d20 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d22 : 68              >            pla         ;load status
0d23 : 48              >            pha
                       >            cmp_flag $ff-zero
0d24 : 0908            >            ora #decmode        ;ignore decimal mode bit
0d26 : c9f9            >            cmp #($ff-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0d28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d2a : 28              >            plp         ;restore status
                        
0d2b : 08                       php
0d2c : e8                       inx             ;00
0d2d : 8a                       txa
0d2e : 28                       plp
0d2f : a8                       tay
                                tst_y 0,$ff-minus
0d30 : 08              >            php         ;save flags
0d31 : c000            >            cpy #0     ;test result
                       >            trap_ne
0d33 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d35 : 68              >            pla         ;load status
0d36 : 48              >            pha
                       >            cmp_flag $ff-minus
0d37 : 0908            >            ora #decmode        ;ignore decimal mode bit
0d39 : c97b            >            cmp #($ff-minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0d3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d3d : 28              >            plp         ;restore status
                        
0d3e : 08                       php
0d3f : e8                       inx             ;01
0d40 : 8a                       txa
0d41 : 28                       plp
0d42 : a8                       tay
                                tst_y 1,$ff-minus-zero
0d43 : 08              >            php         ;save flags
0d44 : c001            >            cpy #1     ;test result
                       >            trap_ne
0d46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d48 : 68              >            pla         ;load status
0d49 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0d4a : 0908            >            ora #decmode        ;ignore decimal mode bit
0d4c : c979            >            cmp #($ff-minus-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0d4e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d50 : 28              >            plp         ;restore status
                        
                                load_flag 0
0d51 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                        
0d53 : 48                       pha
0d54 : a900                     lda #0
0d56 : 8a                       txa
0d57 : 28                       plp
0d58 : a8                       tay
                                tst_y 1,0
0d59 : 08              >            php         ;save flags
0d5a : c001            >            cpy #1     ;test result
                       >            trap_ne
0d5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d5e : 68              >            pla         ;load status
0d5f : 48              >            pha
                       >            cmp_flag 0
0d60 : 0908            >            ora #decmode        ;ignore decimal mode bit
0d62 : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0d64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d66 : 28              >            plp         ;restore status
                        
0d67 : 08                       php
0d68 : ca                       dex             ;00
0d69 : 8a                       txa
0d6a : 28                       plp
0d6b : a8                       tay
                                tst_y 0,zero
0d6c : 08              >            php         ;save flags
0d6d : c000            >            cpy #0     ;test result
                       >            trap_ne
0d6f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d71 : 68              >            pla         ;load status
0d72 : 48              >            pha
                       >            cmp_flag zero
0d73 : 0908            >            ora #decmode        ;ignore decimal mode bit
0d75 : c93a            >            cmp #(zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0d77 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d79 : 28              >            plp         ;restore status
                        
0d7a : 08                       php
0d7b : ca                       dex             ;ff
0d7c : 8a                       txa
0d7d : 28                       plp
0d7e : a8                       tay
                                tst_y $ff,minus
0d7f : 08              >            php         ;save flags
0d80 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0d82 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d84 : 68              >            pla         ;load status
0d85 : 48              >            pha
                       >            cmp_flag minus
0d86 : 0908            >            ora #decmode        ;ignore decimal mode bit
0d88 : c9b8            >            cmp #(minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0d8a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d8c : 28              >            plp         ;restore status
                        
                        
                        
                                load_flag $ff
0d8d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                        
0d8f : 48                       pha
0d90 : a0ff                     ldy #$ff        ;ff
0d92 : 98                       tya
0d93 : 28                       plp
0d94 : aa                       tax
                                tst_x $ff,$ff-zero
0d95 : 08              >            php         ;save flags
0d96 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0d98 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d9a : 68              >            pla         ;load status
0d9b : 48              >            pha
                       >            cmp_flag $ff-zero
0d9c : 0908            >            ora #decmode        ;ignore decimal mode bit
0d9e : c9f9            >            cmp #($ff-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0da0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0da2 : 28              >            plp         ;restore status
                        
0da3 : 08                       php
0da4 : c8                       iny             ;00
0da5 : 98                       tya
0da6 : 28                       plp
0da7 : aa                       tax
                                tst_x 0,$ff-minus
0da8 : 08              >            php         ;save flags
0da9 : e000            >            cpx #0     ;test result
                       >            trap_ne
0dab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0dad : 68              >            pla         ;load status
0dae : 48              >            pha
                       >            cmp_flag $ff-minus
0daf : 0908            >            ora #decmode        ;ignore decimal mode bit
0db1 : c97b            >            cmp #($ff-minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0db3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0db5 : 28              >            plp         ;restore status
                        
0db6 : 08                       php
0db7 : c8                       iny             ;01
0db8 : 98                       tya
0db9 : 28                       plp
0dba : aa                       tax
                                tst_x 1,$ff-minus-zero
0dbb : 08              >            php         ;save flags
0dbc : e001            >            cpx #1     ;test result
                       >            trap_ne
0dbe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0dc0 : 68              >            pla         ;load status
0dc1 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0dc2 : 0908            >            ora #decmode        ;ignore decimal mode bit
0dc4 : c979            >            cmp #($ff-minus-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0dc6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0dc8 : 28              >            plp         ;restore status
                        
                                load_flag 0
0dc9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                        
0dcb : 48                       pha
0dcc : a900                     lda #0          ;preset status
0dce : 98                       tya
0dcf : 28                       plp
0dd0 : aa                       tax
                                tst_x 1,0
0dd1 : 08              >            php         ;save flags
0dd2 : e001            >            cpx #1     ;test result
                       >            trap_ne
0dd4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0dd6 : 68              >            pla         ;load status
0dd7 : 48              >            pha
                       >            cmp_flag 0
0dd8 : 0908            >            ora #decmode        ;ignore decimal mode bit
0dda : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0ddc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0dde : 28              >            plp         ;restore status
                        
0ddf : 08                       php
0de0 : 88                       dey             ;00
0de1 : 98                       tya
0de2 : 28                       plp
0de3 : aa                       tax
                                tst_x 0,zero
0de4 : 08              >            php         ;save flags
0de5 : e000            >            cpx #0     ;test result
                       >            trap_ne
0de7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0de9 : 68              >            pla         ;load status
0dea : 48              >            pha
                       >            cmp_flag zero
0deb : 0908            >            ora #decmode        ;ignore decimal mode bit
0ded : c93a            >            cmp #(zero|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0def : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0df1 : 28              >            plp         ;restore status
                        
0df2 : 08                       php
0df3 : 88                       dey             ;ff
0df4 : 98                       tya
0df5 : 28                       plp
0df6 : aa                       tax
                                tst_x $ff,minus
0df7 : 08              >            php         ;save flags
0df8 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0dfa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0dfc : 68              >            pla         ;load status
0dfd : 48              >            pha
                       >            cmp_flag minus
0dfe : 0908            >            ora #decmode        ;ignore decimal mode bit
0e00 : c9b8            >            cmp #(minus|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
0e02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0e04 : 28              >            plp         ;restore status
                        
                                next_test
0e05 : ad0002          >            lda test_case   ;previous test
0e08 : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0e0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
0e0c : a90e            >            lda #test_num   ;*** next tests' number
0e0e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                             
                        ;TSX sets NZ - TXS does not
                        ;  This section also tests for proper stack wrap around.
0e11 : a201                     ldx #1          ;01
                                set_stat $ff
                       >            load_flag $ff
0e13 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0e15 : 48              >            pha         ;use stack to load status
0e16 : 28              >            plp
                        
0e17 : 9a                       txs
0e18 : 08                       php
0e19 : ad0101                   lda $101
                                cmp_flag $ff
0e1c : 0908            >            ora #decmode        ;ignore decimal mode bit
0e1e : c9fb            >            cmp #($ff|faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
0e20 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0e22 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0e24 : 48              >            pha         ;use stack to load status
0e25 : 28              >            plp
                        
0e26 : 9a                       txs
0e27 : 08                       php
0e28 : ad0101                   lda $101
                                cmp_flag 0
0e2b : 0908            >            ora #decmode        ;ignore decimal mode bit
0e2d : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
0e2f : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e31 : ca                       dex             ;00
                                set_stat $ff
                       >            load_flag $ff
0e32 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0e34 : 48              >            pha         ;use stack to load status
0e35 : 28              >            plp
                        
0e36 : 9a                       txs
0e37 : 08                       php
0e38 : ad0001                   lda $100
                                cmp_flag $ff
0e3b : 0908            >            ora #decmode        ;ignore decimal mode bit
0e3d : c9fb            >            cmp #($ff|faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
0e3f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0e41 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0e43 : 48              >            pha         ;use stack to load status
0e44 : 28              >            plp
                        
0e45 : 9a                       txs
0e46 : 08                       php
0e47 : ad0001                   lda $100
                                cmp_flag 0
0e4a : 0908            >            ora #decmode        ;ignore decimal mode bit
0e4c : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
0e4e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e50 : ca                       dex             ;ff
                                set_stat $ff
                       >            load_flag $ff
0e51 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0e53 : 48              >            pha         ;use stack to load status
0e54 : 28              >            plp
                        
0e55 : 9a                       txs
0e56 : 08                       php
0e57 : adff01                   lda $1ff
                                cmp_flag $ff
0e5a : 0908            >            ora #decmode        ;ignore decimal mode bit
0e5c : c9fb            >            cmp #($ff|faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
0e5e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0e60 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0e62 : 48              >            pha         ;use stack to load status
0e63 : 28              >            plp
                        
0e64 : 9a                       txs
0e65 : 08                       php
0e66 : adff01                   lda $1ff
                                cmp_flag 0
0e69 : 0908            >            ora #decmode        ;ignore decimal mode bit
0e6b : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                
0e6d : a201                     ldx #1
0e6f : 9a                       txs             ;sp=01
                                set_stat $ff
                       >            load_flag $ff
0e70 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0e72 : 48              >            pha         ;use stack to load status
0e73 : 28              >            plp
                        
0e74 : ba                       tsx             ;clears Z, N
0e75 : 08                       php             ;sp=00
0e76 : e001                     cpx #1
                                trap_ne
0e78 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e7a : ad0101                   lda $101
                                cmp_flag $ff-minus-zero
0e7d : 0908            >            ora #decmode        ;ignore decimal mode bit
0e7f : c979            >            cmp #($ff-minus-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
0e81 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0e83 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0e85 : 48              >            pha         ;use stack to load status
0e86 : 28              >            plp
                        
0e87 : ba                       tsx             ;clears N, sets Z
0e88 : 08                       php             ;sp=ff
0e89 : e000                     cpx #0
                                trap_ne
0e8b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e8d : ad0001                   lda $100
                                cmp_flag $ff-minus
0e90 : 0908            >            ora #decmode        ;ignore decimal mode bit
0e92 : c97b            >            cmp #($ff-minus|faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
0e94 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0e96 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0e98 : 48              >            pha         ;use stack to load status
0e99 : 28              >            plp
                        
0e9a : ba                       tsx             ;clears N, sets Z
0e9b : 08                       php             ;sp=fe
0e9c : e0ff                     cpx #$ff
                                trap_ne
0e9e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ea0 : adff01                   lda $1ff
                                cmp_flag $ff-zero
0ea3 : 0908            >            ora #decmode        ;ignore decimal mode bit
0ea5 : c9f9            >            cmp #($ff-zero|faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
0ea7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
0ea9 : a201                     ldx #1
0eab : 9a                       txs             ;sp=01
                                set_stat 0
                       >            load_flag 0
0eac : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0eae : 48              >            pha         ;use stack to load status
0eaf : 28              >            plp
                        
0eb0 : ba                       tsx             ;clears Z, N
0eb1 : 08                       php             ;sp=00
0eb2 : e001                     cpx #1
                                trap_ne
0eb4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0eb6 : ad0101                   lda $101
                                cmp_flag 0
0eb9 : 0908            >            ora #decmode        ;ignore decimal mode bit
0ebb : c938            >            cmp #(0|faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
0ebd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0ebf : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0ec1 : 48              >            pha         ;use stack to load status
0ec2 : 28              >            plp
                        
0ec3 : ba                       tsx             ;clears N, sets Z
0ec4 : 08                       php             ;sp=ff
0ec5 : e000                     cpx #0
                                trap_ne
0ec7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ec9 : ad0001                   lda $100
                                cmp_flag zero
0ecc : 0908            >            ora #decmode        ;ignore decimal mode bit
0ece : c93a            >            cmp #(zero|faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
0ed0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0ed2 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0ed4 : 48              >            pha         ;use stack to load status
0ed5 : 28              >            plp
                        
0ed6 : ba                       tsx             ;clears N, sets Z
0ed7 : 08                       php             ;sp=fe
0ed8 : e0ff                     cpx #$ff
                                trap_ne
0eda : d0fe            >        bne *           ;failed not equal (non zero)
                        
0edc : adff01                   lda $1ff
                                cmp_flag minus
0edf : 0908            >            ora #decmode        ;ignore decimal mode bit
0ee1 : c9b8            >            cmp #(minus|faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
0ee3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ee5 : 68                       pla             ;sp=ff
                                next_test
0ee6 : ad0002          >            lda test_case   ;previous test
0ee9 : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0eeb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
0eed : a90f            >            lda #test_num   ;*** next tests' number
0eef : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; testing index register load & store LDY LDX STY STX all addressing modes
                        ; LDX / STX - zp,y / abs,y
0ef2 : a003                     ldy #3
0ef4 :                  tldx    
                                set_stat 0
                       >            load_flag 0
0ef4 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0ef6 : 48              >            pha         ;use stack to load status
0ef7 : 28              >            plp
                        
0ef8 : b615                     ldx zp1,y
0efa : 08                       php         ;test stores do not alter flags
0efb : 8a                       txa
0efc : 49c3                     eor #$c3
0efe : 28                       plp
0eff : 990302                   sta abst,y
0f02 : 08                       php         ;flags after load/store sequence
0f03 : 49c3                     eor #$c3
0f05 : d91802                   cmp abs1,y  ;test result
                                trap_ne
0f08 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f0a : 68                       pla         ;load status
                                eor_flag 0
0f0b : 0908            >            ora #decmode        ;ignore decimal mode bit
0f0d : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
0f0f : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0f12 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f14 : 88                       dey
0f15 : 10dd                     bpl tldx                  
                        
0f17 : a003                     ldy #3
0f19 :                  tldx1   
                                set_stat $ff
                       >            load_flag $ff
0f19 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0f1b : 48              >            pha         ;use stack to load status
0f1c : 28              >            plp
                        
0f1d : b615                     ldx zp1,y
0f1f : 08                       php         ;test stores do not alter flags
0f20 : 8a                       txa
0f21 : 49c3                     eor #$c3
0f23 : 28                       plp
0f24 : 990302                   sta abst,y
0f27 : 08                       php         ;flags after load/store sequence
0f28 : 49c3                     eor #$c3
0f2a : d91802                   cmp abs1,y  ;test result
                                trap_ne
0f2d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f2f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0f30 : 0908            >            ora #decmode        ;ignore decimal mode bit
0f32 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
0f34 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0f37 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f39 : 88                       dey
0f3a : 10dd                     bpl tldx1                  
                        
0f3c : a003                     ldy #3
0f3e :                  tldx2   
                                set_stat 0
                       >            load_flag 0
0f3e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0f40 : 48              >            pha         ;use stack to load status
0f41 : 28              >            plp
                        
0f42 : be1802                   ldx abs1,y
0f45 : 08                       php         ;test stores do not alter flags
0f46 : 8a                       txa
0f47 : 49c3                     eor #$c3
0f49 : aa                       tax
0f4a : 28                       plp
0f4b : 960c                     stx zpt,y
0f4d : 08                       php         ;flags after load/store sequence
0f4e : 49c3                     eor #$c3
0f50 : d91500                   cmp zp1,y   ;test result
                                trap_ne
0f53 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f55 : 68                       pla         ;load status
                                eor_flag 0
0f56 : 0908            >            ora #decmode        ;ignore decimal mode bit
0f58 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
0f5a : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0f5d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f5f : 88                       dey
0f60 : 10dc                     bpl tldx2                  
                        
0f62 : a003                     ldy #3
0f64 :                  tldx3   
                                set_stat $ff
                       >            load_flag $ff
0f64 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
0f66 : 48              >            pha         ;use stack to load status
0f67 : 28              >            plp
                        
0f68 : be1802                   ldx abs1,y
0f6b : 08                       php         ;test stores do not alter flags
0f6c : 8a                       txa
0f6d : 49c3                     eor #$c3
0f6f : aa                       tax
0f70 : 28                       plp
0f71 : 960c                     stx zpt,y
0f73 : 08                       php         ;flags after load/store sequence
0f74 : 49c3                     eor #$c3
0f76 : d91500                   cmp zp1,y   ;test result
                                trap_ne
0f79 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f7b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0f7c : 0908            >            ora #decmode        ;ignore decimal mode bit
0f7e : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
0f80 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
0f83 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f85 : 88                       dey
0f86 : 10dc                     bpl tldx3
                                
0f88 : a003                     ldy #3      ;testing store result
0f8a : a200                     ldx #0
0f8c : b90c00           tstx    lda zpt,y
0f8f : 49c3                     eor #$c3
0f91 : d91500                   cmp zp1,y
                                trap_ne     ;store to zp data
0f94 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f96 : 960c                     stx zpt,y   ;clear                
0f98 : b90302                   lda abst,y
0f9b : 49c3                     eor #$c3
0f9d : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
0fa0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fa2 : 8a                       txa
0fa3 : 990302                   sta abst,y  ;clear                
0fa6 : 88                       dey
0fa7 : 10e3                     bpl tstx
                                next_test
0fa9 : ad0002          >            lda test_case   ;previous test
0fac : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0fae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
0fb0 : a910            >            lda #test_num   ;*** next tests' number
0fb2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; indexed wraparound test (only zp should wrap)
0fb5 : a0fd                     ldy #3+$fa
0fb7 : b61b             tldx4   ldx zp1-$fa&$ff,y   ;wrap on indexed zp
0fb9 : 8a                       txa
0fba : 990901                   sta abst-$fa,y      ;no STX abs,y!
0fbd : 88                       dey
0fbe : c0fa                     cpy #$fa
0fc0 : b0f5                     bcs tldx4                  
0fc2 : a0fd                     ldy #3+$fa
0fc4 : be1e01           tldx5   ldx abs1-$fa,y      ;no wrap on indexed abs
0fc7 : 9612                     stx zpt-$fa&$ff,y
0fc9 : 88                       dey
0fca : c0fa                     cpy #$fa
0fcc : b0f6                     bcs tldx5                  
0fce : a003                     ldy #3      ;testing wraparound result
0fd0 : a200                     ldx #0
0fd2 : b90c00           tstx1   lda zpt,y
0fd5 : d91500                   cmp zp1,y
                                trap_ne     ;store to zp data
0fd8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fda : 960c                     stx zpt,y   ;clear                
0fdc : b90302                   lda abst,y
0fdf : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
0fe2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fe4 : 8a                       txa
0fe5 : 990302                   sta abst,y  ;clear                
0fe8 : 88                       dey
0fe9 : 10e7                     bpl tstx1
                                next_test
0feb : ad0002          >            lda test_case   ;previous test
0fee : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0ff0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
0ff2 : a911            >            lda #test_num   ;*** next tests' number
0ff4 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; LDY / STY - zp,x / abs,x
0ff7 : a203                     ldx #3
0ff9 :                  tldy    
                                set_stat 0
                       >            load_flag 0
0ff9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
0ffb : 48              >            pha         ;use stack to load status
0ffc : 28              >            plp
                        
0ffd : b415                     ldy zp1,x
0fff : 08                       php         ;test stores do not alter flags
1000 : 98                       tya
1001 : 49c3                     eor #$c3
1003 : 28                       plp
1004 : 9d0302                   sta abst,x
1007 : 08                       php         ;flags after load/store sequence
1008 : 49c3                     eor #$c3
100a : dd1802                   cmp abs1,x  ;test result
                                trap_ne
100d : d0fe            >        bne *           ;failed not equal (non zero)
                        
100f : 68                       pla         ;load status
                                eor_flag 0
1010 : 0908            >            ora #decmode        ;ignore decimal mode bit
1012 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1014 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
1017 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1019 : ca                       dex
101a : 10dd                     bpl tldy                  
                        
101c : a203                     ldx #3
101e :                  tldy1   
                                set_stat $ff
                       >            load_flag $ff
101e : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1020 : 48              >            pha         ;use stack to load status
1021 : 28              >            plp
                        
1022 : b415                     ldy zp1,x
1024 : 08                       php         ;test stores do not alter flags
1025 : 98                       tya
1026 : 49c3                     eor #$c3
1028 : 28                       plp
1029 : 9d0302                   sta abst,x
102c : 08                       php         ;flags after load/store sequence
102d : 49c3                     eor #$c3
102f : dd1802                   cmp abs1,x  ;test result
                                trap_ne
1032 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1034 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1035 : 0908            >            ora #decmode        ;ignore decimal mode bit
1037 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1039 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
103c : d0fe            >        bne *           ;failed not equal (non zero)
                        
103e : ca                       dex
103f : 10dd                     bpl tldy1                  
                        
1041 : a203                     ldx #3
1043 :                  tldy2   
                                set_stat 0
                       >            load_flag 0
1043 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1045 : 48              >            pha         ;use stack to load status
1046 : 28              >            plp
                        
1047 : bc1802                   ldy abs1,x
104a : 08                       php         ;test stores do not alter flags
104b : 98                       tya
104c : 49c3                     eor #$c3
104e : a8                       tay
104f : 28                       plp
1050 : 940c                     sty zpt,x
1052 : 08                       php         ;flags after load/store sequence
1053 : 49c3                     eor #$c3
1055 : d515                     cmp zp1,x   ;test result
                                trap_ne
1057 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1059 : 68                       pla         ;load status
                                eor_flag 0
105a : 0908            >            ora #decmode        ;ignore decimal mode bit
105c : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
105e : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
1061 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1063 : ca                       dex
1064 : 10dd                     bpl tldy2                  
                        
1066 : a203                     ldx #3
1068 :                  tldy3
                                set_stat $ff
                       >            load_flag $ff
1068 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
106a : 48              >            pha         ;use stack to load status
106b : 28              >            plp
                        
106c : bc1802                   ldy abs1,x
106f : 08                       php         ;test stores do not alter flags
1070 : 98                       tya
1071 : 49c3                     eor #$c3
1073 : a8                       tay
1074 : 28                       plp
1075 : 940c                     sty zpt,x
1077 : 08                       php         ;flags after load/store sequence
1078 : 49c3                     eor #$c3
107a : d515                     cmp zp1,x   ;test result
                                trap_ne
107c : d0fe            >        bne *           ;failed not equal (non zero)
                        
107e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
107f : 0908            >            ora #decmode        ;ignore decimal mode bit
1081 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1083 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
1086 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1088 : ca                       dex
1089 : 10dd                     bpl tldy3
                        
108b : a203                     ldx #3      ;testing store result
108d : a000                     ldy #0
108f : b50c             tsty    lda zpt,x
1091 : 49c3                     eor #$c3
1093 : d515                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1095 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1097 : 940c                     sty zpt,x   ;clear                
1099 : bd0302                   lda abst,x
109c : 49c3                     eor #$c3
109e : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
10a1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10a3 : 8a                       txa
10a4 : 9d0302                   sta abst,x  ;clear                
10a7 : ca                       dex
10a8 : 10e5                     bpl tsty
                                next_test
10aa : ad0002          >            lda test_case   ;previous test
10ad : c911            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
10af : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0012 =                 >test_num = test_num + 1
10b1 : a912            >            lda #test_num   ;*** next tests' number
10b3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
10b6 : a2fd                     ldx #3+$fa
10b8 : b41b             tldy4   ldy zp1-$fa&$ff,x   ;wrap on indexed zp
10ba : 98                       tya
10bb : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
10be : ca                       dex
10bf : e0fa                     cpx #$fa
10c1 : b0f5                     bcs tldy4                  
10c3 : a2fd                     ldx #3+$fa
10c5 : bc1e01           tldy5   ldy abs1-$fa,x      ;no wrap on indexed abs
10c8 : 9412                     sty zpt-$fa&$ff,x
10ca : ca                       dex
10cb : e0fa                     cpx #$fa
10cd : b0f6                     bcs tldy5                  
10cf : a203                     ldx #3      ;testing wraparound result
10d1 : a000                     ldy #0
10d3 : b50c             tsty1   lda zpt,x
10d5 : d515                     cmp zp1,x
                                trap_ne     ;store to zp,x data
10d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10d9 : 940c                     sty zpt,x   ;clear                
10db : bd0302                   lda abst,x
10de : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
10e1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10e3 : 8a                       txa
10e4 : 9d0302                   sta abst,x  ;clear                
10e7 : ca                       dex
10e8 : 10e9                     bpl tsty1
                                next_test
10ea : ad0002          >            lda test_case   ;previous test
10ed : c912            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
10ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0013 =                 >test_num = test_num + 1
10f1 : a913            >            lda #test_num   ;*** next tests' number
10f3 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDX / STX - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
10f6 : a900            >            lda #0  &m8i         ;force enable interrupts (mask I)
                       >
10f8 : 48              >            pha         ;use stack to load status
10f9 : 28              >            plp
                        
10fa : a615                     ldx zp1
10fc : 08                       php         ;test stores do not alter flags
10fd : 8a                       txa
10fe : 49c3                     eor #$c3
1100 : aa                       tax
1101 : 28                       plp
1102 : 8e0302                   stx abst
1105 : 08                       php         ;flags after load/store sequence
1106 : 49c3                     eor #$c3
1108 : aa                       tax
1109 : e0c3                     cpx #$c3    ;test result
                                trap_ne
110b : d0fe            >        bne *           ;failed not equal (non zero)
                        
110d : 68                       pla         ;load status
                                eor_flag 0
110e : 0908            >            ora #decmode        ;ignore decimal mode bit
1110 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1112 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1115 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1117 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1119 : 48              >            pha         ;use stack to load status
111a : 28              >            plp
                        
111b : a616                     ldx zp1+1
111d : 08                       php         ;test stores do not alter flags
111e : 8a                       txa
111f : 49c3                     eor #$c3
1121 : aa                       tax
1122 : 28                       plp
1123 : 8e0402                   stx abst+1
1126 : 08                       php         ;flags after load/store sequence
1127 : 49c3                     eor #$c3
1129 : aa                       tax
112a : e082                     cpx #$82    ;test result
                                trap_ne
112c : d0fe            >        bne *           ;failed not equal (non zero)
                        
112e : 68                       pla         ;load status
                                eor_flag 0
112f : 0908            >            ora #decmode        ;ignore decimal mode bit
1131 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1133 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1136 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1138 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
113a : 48              >            pha         ;use stack to load status
113b : 28              >            plp
                        
113c : a617                     ldx zp1+2
113e : 08                       php         ;test stores do not alter flags
113f : 8a                       txa
1140 : 49c3                     eor #$c3
1142 : aa                       tax
1143 : 28                       plp
1144 : 8e0502                   stx abst+2
1147 : 08                       php         ;flags after load/store sequence
1148 : 49c3                     eor #$c3
114a : aa                       tax
114b : e041                     cpx #$41    ;test result
                                trap_ne
114d : d0fe            >        bne *           ;failed not equal (non zero)
                        
114f : 68                       pla         ;load status
                                eor_flag 0
1150 : 0908            >            ora #decmode        ;ignore decimal mode bit
1152 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1154 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1157 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1159 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
115b : 48              >            pha         ;use stack to load status
115c : 28              >            plp
                        
115d : a618                     ldx zp1+3
115f : 08                       php         ;test stores do not alter flags
1160 : 8a                       txa
1161 : 49c3                     eor #$c3
1163 : aa                       tax
1164 : 28                       plp
1165 : 8e0602                   stx abst+3
1168 : 08                       php         ;flags after load/store sequence
1169 : 49c3                     eor #$c3
116b : aa                       tax
116c : e000                     cpx #0      ;test result
                                trap_ne
116e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1170 : 68                       pla         ;load status
                                eor_flag 0
1171 : 0908            >            ora #decmode        ;ignore decimal mode bit
1173 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1175 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1178 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
117a : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
117c : 48              >            pha         ;use stack to load status
117d : 28              >            plp
                        
117e : a615                     ldx zp1  
1180 : 08                       php         ;test stores do not alter flags
1181 : 8a                       txa
1182 : 49c3                     eor #$c3
1184 : aa                       tax
1185 : 28                       plp
1186 : 8e0302                   stx abst  
1189 : 08                       php         ;flags after load/store sequence
118a : 49c3                     eor #$c3
118c : aa                       tax
118d : e0c3                     cpx #$c3    ;test result
                                trap_ne     ;
118f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1191 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1192 : 0908            >            ora #decmode        ;ignore decimal mode bit
1194 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1196 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1199 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
119b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
119d : 48              >            pha         ;use stack to load status
119e : 28              >            plp
                        
119f : a616                     ldx zp1+1
11a1 : 08                       php         ;test stores do not alter flags
11a2 : 8a                       txa
11a3 : 49c3                     eor #$c3
11a5 : aa                       tax
11a6 : 28                       plp
11a7 : 8e0402                   stx abst+1
11aa : 08                       php         ;flags after load/store sequence
11ab : 49c3                     eor #$c3
11ad : aa                       tax
11ae : e082                     cpx #$82    ;test result
                                trap_ne
11b0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11b2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11b3 : 0908            >            ora #decmode        ;ignore decimal mode bit
11b5 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
11b7 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
11ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11bc : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
11be : 48              >            pha         ;use stack to load status
11bf : 28              >            plp
                        
11c0 : a617                     ldx zp1+2
11c2 : 08                       php         ;test stores do not alter flags
11c3 : 8a                       txa
11c4 : 49c3                     eor #$c3
11c6 : aa                       tax
11c7 : 28                       plp
11c8 : 8e0502                   stx abst+2
11cb : 08                       php         ;flags after load/store sequence
11cc : 49c3                     eor #$c3
11ce : aa                       tax
11cf : e041                     cpx #$41    ;test result
                                trap_ne     ;
11d1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11d3 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11d4 : 0908            >            ora #decmode        ;ignore decimal mode bit
11d6 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
11d8 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
11db : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11dd : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
11df : 48              >            pha         ;use stack to load status
11e0 : 28              >            plp
                        
11e1 : a618                     ldx zp1+3
11e3 : 08                       php         ;test stores do not alter flags
11e4 : 8a                       txa
11e5 : 49c3                     eor #$c3
11e7 : aa                       tax
11e8 : 28                       plp
11e9 : 8e0602                   stx abst+3
11ec : 08                       php         ;flags after load/store sequence
11ed : 49c3                     eor #$c3
11ef : aa                       tax
11f0 : e000                     cpx #0      ;test result
                                trap_ne
11f2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
11f4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11f5 : 0908            >            ora #decmode        ;ignore decimal mode bit
11f7 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
11f9 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
11fc : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
11fe : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1200 : 48              >            pha         ;use stack to load status
1201 : 28              >            plp
                        
1202 : ae1802                   ldx abs1  
1205 : 08                       php         ;test stores do not alter flags
1206 : 8a                       txa
1207 : 49c3                     eor #$c3
1209 : aa                       tax
120a : 28                       plp
120b : 860c                     stx zpt  
120d : 08                       php         ;flags after load/store sequence
120e : 49c3                     eor #$c3
1210 : c515                     cmp zp1     ;test result
                                trap_ne
1212 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1214 : 68                       pla         ;load status
                                eor_flag 0
1215 : 0908            >            ora #decmode        ;ignore decimal mode bit
1217 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1219 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
121c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
121e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1220 : 48              >            pha         ;use stack to load status
1221 : 28              >            plp
                        
1222 : ae1902                   ldx abs1+1
1225 : 08                       php         ;test stores do not alter flags
1226 : 8a                       txa
1227 : 49c3                     eor #$c3
1229 : aa                       tax
122a : 28                       plp
122b : 860d                     stx zpt+1
122d : 08                       php         ;flags after load/store sequence
122e : 49c3                     eor #$c3
1230 : c516                     cmp zp1+1   ;test result
                                trap_ne
1232 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1234 : 68                       pla         ;load status
                                eor_flag 0
1235 : 0908            >            ora #decmode        ;ignore decimal mode bit
1237 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1239 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
123c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
123e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1240 : 48              >            pha         ;use stack to load status
1241 : 28              >            plp
                        
1242 : ae1a02                   ldx abs1+2
1245 : 08                       php         ;test stores do not alter flags
1246 : 8a                       txa
1247 : 49c3                     eor #$c3
1249 : aa                       tax
124a : 28                       plp
124b : 860e                     stx zpt+2
124d : 08                       php         ;flags after load/store sequence
124e : 49c3                     eor #$c3
1250 : c517                     cmp zp1+2   ;test result
                                trap_ne
1252 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1254 : 68                       pla         ;load status
                                eor_flag 0
1255 : 0908            >            ora #decmode        ;ignore decimal mode bit
1257 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1259 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
125c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
125e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1260 : 48              >            pha         ;use stack to load status
1261 : 28              >            plp
                        
1262 : ae1b02                   ldx abs1+3
1265 : 08                       php         ;test stores do not alter flags
1266 : 8a                       txa
1267 : 49c3                     eor #$c3
1269 : aa                       tax
126a : 28                       plp
126b : 860f                     stx zpt+3
126d : 08                       php         ;flags after load/store sequence
126e : 49c3                     eor #$c3
1270 : c518                     cmp zp1+3   ;test result
                                trap_ne
1272 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1274 : 68                       pla         ;load status
                                eor_flag 0
1275 : 0908            >            ora #decmode        ;ignore decimal mode bit
1277 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1279 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
127c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
127e : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1280 : 48              >            pha         ;use stack to load status
1281 : 28              >            plp
                        
1282 : ae1802                   ldx abs1  
1285 : 08                       php         ;test stores do not alter flags
1286 : 8a                       txa
1287 : 49c3                     eor #$c3
1289 : aa                       tax
128a : 28                       plp
128b : 860c                     stx zpt  
128d : 08                       php         ;flags after load/store sequence
128e : 49c3                     eor #$c3
1290 : aa                       tax
1291 : e415                     cpx zp1     ;test result
                                trap_ne
1293 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1295 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1296 : 0908            >            ora #decmode        ;ignore decimal mode bit
1298 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
129a : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
129d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
129f : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
12a1 : 48              >            pha         ;use stack to load status
12a2 : 28              >            plp
                        
12a3 : ae1902                   ldx abs1+1
12a6 : 08                       php         ;test stores do not alter flags
12a7 : 8a                       txa
12a8 : 49c3                     eor #$c3
12aa : aa                       tax
12ab : 28                       plp
12ac : 860d                     stx zpt+1
12ae : 08                       php         ;flags after load/store sequence
12af : 49c3                     eor #$c3
12b1 : aa                       tax
12b2 : e416                     cpx zp1+1   ;test result
                                trap_ne
12b4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12b6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12b7 : 0908            >            ora #decmode        ;ignore decimal mode bit
12b9 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
12bb : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
12be : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
12c0 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
12c2 : 48              >            pha         ;use stack to load status
12c3 : 28              >            plp
                        
12c4 : ae1a02                   ldx abs1+2
12c7 : 08                       php         ;test stores do not alter flags
12c8 : 8a                       txa
12c9 : 49c3                     eor #$c3
12cb : aa                       tax
12cc : 28                       plp
12cd : 860e                     stx zpt+2
12cf : 08                       php         ;flags after load/store sequence
12d0 : 49c3                     eor #$c3
12d2 : aa                       tax
12d3 : e417                     cpx zp1+2   ;test result
                                trap_ne
12d5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12d7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12d8 : 0908            >            ora #decmode        ;ignore decimal mode bit
12da : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
12dc : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
12df : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
12e1 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
12e3 : 48              >            pha         ;use stack to load status
12e4 : 28              >            plp
                        
12e5 : ae1b02                   ldx abs1+3
12e8 : 08                       php         ;test stores do not alter flags
12e9 : 8a                       txa
12ea : 49c3                     eor #$c3
12ec : aa                       tax
12ed : 28                       plp
12ee : 860f                     stx zpt+3
12f0 : 08                       php         ;flags after load/store sequence
12f1 : 49c3                     eor #$c3
12f3 : aa                       tax
12f4 : e418                     cpx zp1+3   ;test result
                                trap_ne
12f6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12f8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12f9 : 0908            >            ora #decmode        ;ignore decimal mode bit
12fb : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
12fd : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1300 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0  
                       >            load_flag 0  
1302 : a900            >            lda #0  &m8i         ;force enable interrupts (mask I)
                       >
1304 : 48              >            pha         ;use stack to load status
1305 : 28              >            plp
                        
1306 : a2c3                     ldx #$c3
1308 : 08                       php
1309 : ec1802                   cpx abs1    ;test result
                                trap_ne
130c : d0fe            >        bne *           ;failed not equal (non zero)
                        
130e : 68                       pla         ;load status
                                eor_flag 0
130f : 0908            >            ora #decmode        ;ignore decimal mode bit
1311 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1313 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1316 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1318 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
131a : 48              >            pha         ;use stack to load status
131b : 28              >            plp
                        
131c : a282                     ldx #$82
131e : 08                       php
131f : ec1902                   cpx abs1+1  ;test result
                                trap_ne
1322 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1324 : 68                       pla         ;load status
                                eor_flag 0
1325 : 0908            >            ora #decmode        ;ignore decimal mode bit
1327 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1329 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
132c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
132e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1330 : 48              >            pha         ;use stack to load status
1331 : 28              >            plp
                        
1332 : a241                     ldx #$41
1334 : 08                       php
1335 : ec1a02                   cpx abs1+2  ;test result
                                trap_ne
1338 : d0fe            >        bne *           ;failed not equal (non zero)
                        
133a : 68                       pla         ;load status
                                eor_flag 0
133b : 0908            >            ora #decmode        ;ignore decimal mode bit
133d : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
133f : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1342 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1344 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1346 : 48              >            pha         ;use stack to load status
1347 : 28              >            plp
                        
1348 : a200                     ldx #0
134a : 08                       php
134b : ec1b02                   cpx abs1+3  ;test result
                                trap_ne
134e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1350 : 68                       pla         ;load status
                                eor_flag 0
1351 : 0908            >            ora #decmode        ;ignore decimal mode bit
1353 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1355 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1358 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
135a : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
135c : 48              >            pha         ;use stack to load status
135d : 28              >            plp
                        
135e : a2c3                     ldx #$c3  
1360 : 08                       php
1361 : ec1802                   cpx abs1    ;test result
                                trap_ne
1364 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1366 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1367 : 0908            >            ora #decmode        ;ignore decimal mode bit
1369 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
136b : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
136e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1370 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1372 : 48              >            pha         ;use stack to load status
1373 : 28              >            plp
                        
1374 : a282                     ldx #$82
1376 : 08                       php
1377 : ec1902                   cpx abs1+1  ;test result
                                trap_ne
137a : d0fe            >        bne *           ;failed not equal (non zero)
                        
137c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
137d : 0908            >            ora #decmode        ;ignore decimal mode bit
137f : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1381 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1384 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1386 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1388 : 48              >            pha         ;use stack to load status
1389 : 28              >            plp
                        
138a : a241                     ldx #$41
138c : 08                       php
138d : ec1a02                   cpx abs1+2  ;test result
                                trap_ne
1390 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1392 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1393 : 0908            >            ora #decmode        ;ignore decimal mode bit
1395 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1397 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
139a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
139c : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
139e : 48              >            pha         ;use stack to load status
139f : 28              >            plp
                        
13a0 : a200                     ldx #0
13a2 : 08                       php
13a3 : ec1b02                   cpx abs1+3  ;test result
                                trap_ne
13a6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13a8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13a9 : 0908            >            ora #decmode        ;ignore decimal mode bit
13ab : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
13ad : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
13b0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
13b2 : a200                     ldx #0
13b4 : a50c                     lda zpt  
13b6 : 49c3                     eor #$c3
13b8 : c515                     cmp zp1  
                                trap_ne     ;store to zp data
13ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
13bc : 860c                     stx zpt     ;clear                
13be : ad0302                   lda abst  
13c1 : 49c3                     eor #$c3
13c3 : cd1802                   cmp abs1  
                                trap_ne     ;store to abs data
13c6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13c8 : 8e0302                   stx abst    ;clear                
13cb : a50d                     lda zpt+1
13cd : 49c3                     eor #$c3
13cf : c516                     cmp zp1+1
                                trap_ne     ;store to zp data
13d1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13d3 : 860d                     stx zpt+1   ;clear                
13d5 : ad0402                   lda abst+1
13d8 : 49c3                     eor #$c3
13da : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs data
13dd : d0fe            >        bne *           ;failed not equal (non zero)
                        
13df : 8e0402                   stx abst+1  ;clear                
13e2 : a50e                     lda zpt+2
13e4 : 49c3                     eor #$c3
13e6 : c517                     cmp zp1+2
                                trap_ne     ;store to zp data
13e8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13ea : 860e                     stx zpt+2   ;clear                
13ec : ad0502                   lda abst+2
13ef : 49c3                     eor #$c3
13f1 : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs data
13f4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
13f6 : 8e0502                   stx abst+2  ;clear                
13f9 : a50f                     lda zpt+3
13fb : 49c3                     eor #$c3
13fd : c518                     cmp zp1+3
                                trap_ne     ;store to zp data
13ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
1401 : 860f                     stx zpt+3   ;clear                
1403 : ad0602                   lda abst+3
1406 : 49c3                     eor #$c3
1408 : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs data
140b : d0fe            >        bne *           ;failed not equal (non zero)
                        
140d : 8e0602                   stx abst+3  ;clear                
                                next_test
1410 : ad0002          >            lda test_case   ;previous test
1413 : c913            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1415 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0014 =                 >test_num = test_num + 1
1417 : a914            >            lda #test_num   ;*** next tests' number
1419 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp / abs / #
                                set_stat 0
                       >            load_flag 0
141c : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
141e : 48              >            pha         ;use stack to load status
141f : 28              >            plp
                        
1420 : a415                     ldy zp1  
1422 : 08                       php         ;test stores do not alter flags
1423 : 98                       tya
1424 : 49c3                     eor #$c3
1426 : a8                       tay
1427 : 28                       plp
1428 : 8c0302                   sty abst  
142b : 08                       php         ;flags after load/store sequence
142c : 49c3                     eor #$c3
142e : a8                       tay
142f : c0c3                     cpy #$c3    ;test result
                                trap_ne
1431 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1433 : 68                       pla         ;load status
                                eor_flag 0
1434 : 0908            >            ora #decmode        ;ignore decimal mode bit
1436 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1438 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
143b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
143d : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
143f : 48              >            pha         ;use stack to load status
1440 : 28              >            plp
                        
1441 : a416                     ldy zp1+1
1443 : 08                       php         ;test stores do not alter flags
1444 : 98                       tya
1445 : 49c3                     eor #$c3
1447 : a8                       tay
1448 : 28                       plp
1449 : 8c0402                   sty abst+1
144c : 08                       php         ;flags after load/store sequence
144d : 49c3                     eor #$c3
144f : a8                       tay
1450 : c082                     cpy #$82    ;test result
                                trap_ne
1452 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1454 : 68                       pla         ;load status
                                eor_flag 0
1455 : 0908            >            ora #decmode        ;ignore decimal mode bit
1457 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1459 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
145c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
145e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1460 : 48              >            pha         ;use stack to load status
1461 : 28              >            plp
                        
1462 : a417                     ldy zp1+2
1464 : 08                       php         ;test stores do not alter flags
1465 : 98                       tya
1466 : 49c3                     eor #$c3
1468 : a8                       tay
1469 : 28                       plp
146a : 8c0502                   sty abst+2
146d : 08                       php         ;flags after load/store sequence
146e : 49c3                     eor #$c3
1470 : a8                       tay
1471 : c041                     cpy #$41    ;test result
                                trap_ne
1473 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1475 : 68                       pla         ;load status
                                eor_flag 0
1476 : 0908            >            ora #decmode        ;ignore decimal mode bit
1478 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
147a : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
147d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
147f : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1481 : 48              >            pha         ;use stack to load status
1482 : 28              >            plp
                        
1483 : a418                     ldy zp1+3
1485 : 08                       php         ;test stores do not alter flags
1486 : 98                       tya
1487 : 49c3                     eor #$c3
1489 : a8                       tay
148a : 28                       plp
148b : 8c0602                   sty abst+3
148e : 08                       php         ;flags after load/store sequence
148f : 49c3                     eor #$c3
1491 : a8                       tay
1492 : c000                     cpy #0      ;test result
                                trap_ne
1494 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1496 : 68                       pla         ;load status
                                eor_flag 0
1497 : 0908            >            ora #decmode        ;ignore decimal mode bit
1499 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
149b : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
149e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
14a0 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
14a2 : 48              >            pha         ;use stack to load status
14a3 : 28              >            plp
                        
14a4 : a415                     ldy zp1  
14a6 : 08                       php         ;test stores do not alter flags
14a7 : 98                       tya
14a8 : 49c3                     eor #$c3
14aa : a8                       tay
14ab : 28                       plp
14ac : 8c0302                   sty abst  
14af : 08                       php         ;flags after load/store sequence
14b0 : 49c3                     eor #$c3
14b2 : a8                       tay
14b3 : c0c3                     cpy #$c3    ;test result
                                trap_ne
14b5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14b7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14b8 : 0908            >            ora #decmode        ;ignore decimal mode bit
14ba : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
14bc : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
14bf : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14c1 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
14c3 : 48              >            pha         ;use stack to load status
14c4 : 28              >            plp
                        
14c5 : a416                     ldy zp1+1
14c7 : 08                       php         ;test stores do not alter flags
14c8 : 98                       tya
14c9 : 49c3                     eor #$c3
14cb : a8                       tay
14cc : 28                       plp
14cd : 8c0402                   sty abst+1
14d0 : 08                       php         ;flags after load/store sequence
14d1 : 49c3                     eor #$c3
14d3 : a8                       tay
14d4 : c082                     cpy #$82   ;test result
                                trap_ne
14d6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14d8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14d9 : 0908            >            ora #decmode        ;ignore decimal mode bit
14db : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
14dd : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
14e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14e2 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
14e4 : 48              >            pha         ;use stack to load status
14e5 : 28              >            plp
                        
14e6 : a417                     ldy zp1+2
14e8 : 08                       php         ;test stores do not alter flags
14e9 : 98                       tya
14ea : 49c3                     eor #$c3
14ec : a8                       tay
14ed : 28                       plp
14ee : 8c0502                   sty abst+2
14f1 : 08                       php         ;flags after load/store sequence
14f2 : 49c3                     eor #$c3
14f4 : a8                       tay
14f5 : c041                     cpy #$41    ;test result
                                trap_ne
14f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14f9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14fa : 0908            >            ora #decmode        ;ignore decimal mode bit
14fc : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
14fe : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1501 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1503 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1505 : 48              >            pha         ;use stack to load status
1506 : 28              >            plp
                        
1507 : a418                     ldy zp1+3
1509 : 08                       php         ;test stores do not alter flags
150a : 98                       tya
150b : 49c3                     eor #$c3
150d : a8                       tay
150e : 28                       plp
150f : 8c0602                   sty abst+3
1512 : 08                       php         ;flags after load/store sequence
1513 : 49c3                     eor #$c3
1515 : a8                       tay
1516 : c000                     cpy #0      ;test result
                                trap_ne
1518 : d0fe            >        bne *           ;failed not equal (non zero)
                        
151a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
151b : 0908            >            ora #decmode        ;ignore decimal mode bit
151d : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
151f : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1522 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
                                set_stat 0
                       >            load_flag 0
1524 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1526 : 48              >            pha         ;use stack to load status
1527 : 28              >            plp
                        
1528 : ac1802                   ldy abs1  
152b : 08                       php         ;test stores do not alter flags
152c : 98                       tya
152d : 49c3                     eor #$c3
152f : a8                       tay
1530 : 28                       plp
1531 : 840c                     sty zpt  
1533 : 08                       php         ;flags after load/store sequence
1534 : 49c3                     eor #$c3
1536 : a8                       tay
1537 : c415                     cpy zp1     ;test result
                                trap_ne
1539 : d0fe            >        bne *           ;failed not equal (non zero)
                        
153b : 68                       pla         ;load status
                                eor_flag 0
153c : 0908            >            ora #decmode        ;ignore decimal mode bit
153e : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1540 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1543 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1545 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1547 : 48              >            pha         ;use stack to load status
1548 : 28              >            plp
                        
1549 : ac1902                   ldy abs1+1
154c : 08                       php         ;test stores do not alter flags
154d : 98                       tya
154e : 49c3                     eor #$c3
1550 : a8                       tay
1551 : 28                       plp
1552 : 840d                     sty zpt+1
1554 : 08                       php         ;flags after load/store sequence
1555 : 49c3                     eor #$c3
1557 : a8                       tay
1558 : c416                     cpy zp1+1   ;test result
                                trap_ne
155a : d0fe            >        bne *           ;failed not equal (non zero)
                        
155c : 68                       pla         ;load status
                                eor_flag 0
155d : 0908            >            ora #decmode        ;ignore decimal mode bit
155f : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1561 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1564 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1566 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1568 : 48              >            pha         ;use stack to load status
1569 : 28              >            plp
                        
156a : ac1a02                   ldy abs1+2
156d : 08                       php         ;test stores do not alter flags
156e : 98                       tya
156f : 49c3                     eor #$c3
1571 : a8                       tay
1572 : 28                       plp
1573 : 840e                     sty zpt+2
1575 : 08                       php         ;flags after load/store sequence
1576 : 49c3                     eor #$c3
1578 : a8                       tay
1579 : c417                     cpy zp1+2   ;test result
                                trap_ne
157b : d0fe            >        bne *           ;failed not equal (non zero)
                        
157d : 68                       pla         ;load status
                                eor_flag 0
157e : 0908            >            ora #decmode        ;ignore decimal mode bit
1580 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1582 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1585 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1587 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1589 : 48              >            pha         ;use stack to load status
158a : 28              >            plp
                        
158b : ac1b02                   ldy abs1+3
158e : 08                       php         ;test stores do not alter flags
158f : 98                       tya
1590 : 49c3                     eor #$c3
1592 : a8                       tay
1593 : 28                       plp
1594 : 840f                     sty zpt+3
1596 : 08                       php         ;flags after load/store sequence
1597 : 49c3                     eor #$c3
1599 : a8                       tay
159a : c418                     cpy zp1+3   ;test result
                                trap_ne
159c : d0fe            >        bne *           ;failed not equal (non zero)
                        
159e : 68                       pla         ;load status
                                eor_flag 0
159f : 0908            >            ora #decmode        ;ignore decimal mode bit
15a1 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
15a3 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
15a6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
15a8 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
15aa : 48              >            pha         ;use stack to load status
15ab : 28              >            plp
                        
15ac : ac1802                   ldy abs1  
15af : 08                       php         ;test stores do not alter flags
15b0 : 98                       tya
15b1 : 49c3                     eor #$c3
15b3 : a8                       tay
15b4 : 28                       plp
15b5 : 840c                     sty zpt  
15b7 : 08                       php         ;flags after load/store sequence
15b8 : 49c3                     eor #$c3
15ba : a8                       tay
15bb : c515                     cmp zp1     ;test result
                                trap_ne
15bd : d0fe            >        bne *           ;failed not equal (non zero)
                        
15bf : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15c0 : 0908            >            ora #decmode        ;ignore decimal mode bit
15c2 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
15c4 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
15c7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
15c9 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
15cb : 48              >            pha         ;use stack to load status
15cc : 28              >            plp
                        
15cd : ac1902                   ldy abs1+1
15d0 : 08                       php         ;test stores do not alter flags
15d1 : 98                       tya
15d2 : 49c3                     eor #$c3
15d4 : a8                       tay
15d5 : 28                       plp
15d6 : 840d                     sty zpt+1
15d8 : 08                       php         ;flags after load/store sequence
15d9 : 49c3                     eor #$c3
15db : a8                       tay
15dc : c516                     cmp zp1+1   ;test result
                                trap_ne
15de : d0fe            >        bne *           ;failed not equal (non zero)
                        
15e0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15e1 : 0908            >            ora #decmode        ;ignore decimal mode bit
15e3 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
15e5 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
15e8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
15ea : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
15ec : 48              >            pha         ;use stack to load status
15ed : 28              >            plp
                        
15ee : ac1a02                   ldy abs1+2
15f1 : 08                       php         ;test stores do not alter flags
15f2 : 98                       tya
15f3 : 49c3                     eor #$c3
15f5 : a8                       tay
15f6 : 28                       plp
15f7 : 840e                     sty zpt+2
15f9 : 08                       php         ;flags after load/store sequence
15fa : 49c3                     eor #$c3
15fc : a8                       tay
15fd : c517                     cmp zp1+2   ;test result
                                trap_ne
15ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
1601 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1602 : 0908            >            ora #decmode        ;ignore decimal mode bit
1604 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1606 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1609 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
160b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
160d : 48              >            pha         ;use stack to load status
160e : 28              >            plp
                        
160f : ac1b02                   ldy abs1+3
1612 : 08                       php         ;test stores do not alter flags
1613 : 98                       tya
1614 : 49c3                     eor #$c3
1616 : a8                       tay
1617 : 28                       plp
1618 : 840f                     sty zpt+3
161a : 08                       php         ;flags after load/store sequence
161b : 49c3                     eor #$c3
161d : a8                       tay
161e : c518                     cmp zp1+3   ;test result
                                trap_ne
1620 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1622 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1623 : 0908            >            ora #decmode        ;ignore decimal mode bit
1625 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1627 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
162a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                        
                                set_stat 0
                       >            load_flag 0
162c : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
162e : 48              >            pha         ;use stack to load status
162f : 28              >            plp
                        
1630 : a0c3                     ldy #$c3  
1632 : 08                       php
1633 : cc1802                   cpy abs1    ;test result
                                trap_ne
1636 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1638 : 68                       pla         ;load status
                                eor_flag 0
1639 : 0908            >            ora #decmode        ;ignore decimal mode bit
163b : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
163d : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1640 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1642 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1644 : 48              >            pha         ;use stack to load status
1645 : 28              >            plp
                        
1646 : a082                     ldy #$82
1648 : 08                       php
1649 : cc1902                   cpy abs1+1  ;test result
                                trap_ne
164c : d0fe            >        bne *           ;failed not equal (non zero)
                        
164e : 68                       pla         ;load status
                                eor_flag 0
164f : 0908            >            ora #decmode        ;ignore decimal mode bit
1651 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1653 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1656 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1658 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
165a : 48              >            pha         ;use stack to load status
165b : 28              >            plp
                        
165c : a041                     ldy #$41
165e : 08                       php
165f : cc1a02                   cpy abs1+2  ;test result
                                trap_ne
1662 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1664 : 68                       pla         ;load status
                                eor_flag 0
1665 : 0908            >            ora #decmode        ;ignore decimal mode bit
1667 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1669 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
166c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
166e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1670 : 48              >            pha         ;use stack to load status
1671 : 28              >            plp
                        
1672 : a000                     ldy #0
1674 : 08                       php
1675 : cc1b02                   cpy abs1+3  ;test result
                                trap_ne
1678 : d0fe            >        bne *           ;failed not equal (non zero)
                        
167a : 68                       pla         ;load status
                                eor_flag 0
167b : 0908            >            ora #decmode        ;ignore decimal mode bit
167d : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
167f : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1682 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1684 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1686 : 48              >            pha         ;use stack to load status
1687 : 28              >            plp
                        
1688 : a0c3                     ldy #$c3  
168a : 08                       php
168b : cc1802                   cpy abs1    ;test result
                                trap_ne
168e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1690 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1691 : 0908            >            ora #decmode        ;ignore decimal mode bit
1693 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1695 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1698 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
169a : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
169c : 48              >            pha         ;use stack to load status
169d : 28              >            plp
                        
169e : a082                     ldy #$82
16a0 : 08                       php
16a1 : cc1902                   cpy abs1+1  ;test result
                                trap_ne
16a4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16a6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16a7 : 0908            >            ora #decmode        ;ignore decimal mode bit
16a9 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
16ab : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
16ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
16b0 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
16b2 : 48              >            pha         ;use stack to load status
16b3 : 28              >            plp
                        
16b4 : a041                     ldy #$41
16b6 : 08                       php
16b7 : cc1a02                   cpy abs1+2   ;test result
                                trap_ne
16ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
16bc : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16bd : 0908            >            ora #decmode        ;ignore decimal mode bit
16bf : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
16c1 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
16c4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
16c6 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
16c8 : 48              >            pha         ;use stack to load status
16c9 : 28              >            plp
                        
16ca : a000                     ldy #0
16cc : 08                       php
16cd : cc1b02                   cpy abs1+3  ;test result
                                trap_ne
16d0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16d2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16d3 : 0908            >            ora #decmode        ;ignore decimal mode bit
16d5 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
16d7 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
16da : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
16dc : a000                     ldy #0
16de : a50c                     lda zpt  
16e0 : 49c3                     eor #$c3
16e2 : c515                     cmp zp1  
                                trap_ne     ;store to zp   data
16e4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16e6 : 840c                     sty zpt     ;clear                
16e8 : ad0302                   lda abst  
16eb : 49c3                     eor #$c3
16ed : cd1802                   cmp abs1  
                                trap_ne     ;store to abs   data
16f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16f2 : 8c0302                   sty abst    ;clear                
16f5 : a50d                     lda zpt+1
16f7 : 49c3                     eor #$c3
16f9 : c516                     cmp zp1+1
                                trap_ne     ;store to zp+1 data
16fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
16fd : 840d                     sty zpt+1   ;clear                
16ff : ad0402                   lda abst+1
1702 : 49c3                     eor #$c3
1704 : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs+1 data
1707 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1709 : 8c0402                   sty abst+1  ;clear                
170c : a50e                     lda zpt+2
170e : 49c3                     eor #$c3
1710 : c517                     cmp zp1+2
                                trap_ne     ;store to zp+2 data
1712 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1714 : 840e                     sty zpt+2   ;clear                
1716 : ad0502                   lda abst+2
1719 : 49c3                     eor #$c3
171b : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs+2 data
171e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1720 : 8c0502                   sty abst+2  ;clear                
1723 : a50f                     lda zpt+3
1725 : 49c3                     eor #$c3
1727 : c518                     cmp zp1+3
                                trap_ne     ;store to zp+3 data
1729 : d0fe            >        bne *           ;failed not equal (non zero)
                        
172b : 840f                     sty zpt+3   ;clear                
172d : ad0602                   lda abst+3
1730 : 49c3                     eor #$c3
1732 : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs+3 data
1735 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1737 : 8c0602                   sty abst+3  ;clear                
                                next_test
173a : ad0002          >            lda test_case   ;previous test
173d : c914            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
173f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0015 =                 >test_num = test_num + 1
1741 : a915            >            lda #test_num   ;*** next tests' number
1743 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA all addressing modes
                        ; LDA / STA - zp,x / abs,x
1746 : a203                     ldx #3
1748 :                  tldax    
                                set_stat 0
                       >            load_flag 0
1748 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
174a : 48              >            pha         ;use stack to load status
174b : 28              >            plp
                        
174c : b515                     lda zp1,x
174e : 08                       php         ;test stores do not alter flags
174f : 49c3                     eor #$c3
1751 : 28                       plp
1752 : 9d0302                   sta abst,x
1755 : 08                       php         ;flags after load/store sequence
1756 : 49c3                     eor #$c3
1758 : dd1802                   cmp abs1,x  ;test result
                                trap_ne
175b : d0fe            >        bne *           ;failed not equal (non zero)
                        
175d : 68                       pla         ;load status
                                eor_flag 0
175e : 0908            >            ora #decmode        ;ignore decimal mode bit
1760 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1762 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
1765 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1767 : ca                       dex
1768 : 10de                     bpl tldax                  
                        
176a : a203                     ldx #3
176c :                  tldax1   
                                set_stat $ff
                       >            load_flag $ff
176c : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
176e : 48              >            pha         ;use stack to load status
176f : 28              >            plp
                        
1770 : b515                     lda zp1,x
1772 : 08                       php         ;test stores do not alter flags
1773 : 49c3                     eor #$c3
1775 : 28                       plp
1776 : 9d0302                   sta abst,x
1779 : 08                       php         ;flags after load/store sequence
177a : 49c3                     eor #$c3
177c : dd1802                   cmp abs1,x   ;test result
                                trap_ne
177f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1781 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1782 : 0908            >            ora #decmode        ;ignore decimal mode bit
1784 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1786 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
1789 : d0fe            >        bne *           ;failed not equal (non zero)
                        
178b : ca                       dex
178c : 10de                     bpl tldax1                  
                        
178e : a203                     ldx #3
1790 :                  tldax2   
                                set_stat 0
                       >            load_flag 0
1790 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1792 : 48              >            pha         ;use stack to load status
1793 : 28              >            plp
                        
1794 : bd1802                   lda abs1,x
1797 : 08                       php         ;test stores do not alter flags
1798 : 49c3                     eor #$c3
179a : 28                       plp
179b : 950c                     sta zpt,x
179d : 08                       php         ;flags after load/store sequence
179e : 49c3                     eor #$c3
17a0 : d515                     cmp zp1,x   ;test result
                                trap_ne
17a2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17a4 : 68                       pla         ;load status
                                eor_flag 0
17a5 : 0908            >            ora #decmode        ;ignore decimal mode bit
17a7 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
17a9 : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
17ac : d0fe            >        bne *           ;failed not equal (non zero)
                        
17ae : ca                       dex
17af : 10df                     bpl tldax2                  
                        
17b1 : a203                     ldx #3
17b3 :                  tldax3
                                set_stat $ff
                       >            load_flag $ff
17b3 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
17b5 : 48              >            pha         ;use stack to load status
17b6 : 28              >            plp
                        
17b7 : bd1802                   lda abs1,x
17ba : 08                       php         ;test stores do not alter flags
17bb : 49c3                     eor #$c3
17bd : 28                       plp
17be : 950c                     sta zpt,x
17c0 : 08                       php         ;flags after load/store sequence
17c1 : 49c3                     eor #$c3
17c3 : d515                     cmp zp1,x   ;test result
                                trap_ne
17c5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17c7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
17c8 : 0908            >            ora #decmode        ;ignore decimal mode bit
17ca : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
17cc : dd1d02                   cmp fLDx,x  ;test flags
                                trap_ne
17cf : d0fe            >        bne *           ;failed not equal (non zero)
                        
17d1 : ca                       dex
17d2 : 10df                     bpl tldax3
                        
17d4 : a203                     ldx #3      ;testing store result
17d6 : a000                     ldy #0
17d8 : b50c             tstax   lda zpt,x
17da : 49c3                     eor #$c3
17dc : d515                     cmp zp1,x
                                trap_ne     ;store to zp,x data
17de : d0fe            >        bne *           ;failed not equal (non zero)
                        
17e0 : 940c                     sty zpt,x   ;clear                
17e2 : bd0302                   lda abst,x
17e5 : 49c3                     eor #$c3
17e7 : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
17ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
17ec : 8a                       txa
17ed : 9d0302                   sta abst,x  ;clear                
17f0 : ca                       dex
17f1 : 10e5                     bpl tstax
                                next_test
17f3 : ad0002          >            lda test_case   ;previous test
17f6 : c915            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
17f8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0016 =                 >test_num = test_num + 1
17fa : a916            >            lda #test_num   ;*** next tests' number
17fc : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - (zp),y / abs,y / (zp,x)
17ff : a003                     ldy #3
1801 :                  tlday    
                                set_stat 0
                       >            load_flag 0
1801 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1803 : 48              >            pha         ;use stack to load status
1804 : 28              >            plp
                        
1805 : b126                     lda (ind1),y
1807 : 08                       php         ;test stores do not alter flags
1808 : 49c3                     eor #$c3
180a : 28                       plp
180b : 990302                   sta abst,y
180e : 08                       php         ;flags after load/store sequence
180f : 49c3                     eor #$c3
1811 : d91802                   cmp abs1,y  ;test result
                                trap_ne
1814 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1816 : 68                       pla         ;load status
                                eor_flag 0
1817 : 0908            >            ora #decmode        ;ignore decimal mode bit
1819 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
181b : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
181e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1820 : 88                       dey
1821 : 10de                     bpl tlday                  
                        
1823 : a003                     ldy #3
1825 :                  tlday1   
                                set_stat $ff
                       >            load_flag $ff
1825 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1827 : 48              >            pha         ;use stack to load status
1828 : 28              >            plp
                        
1829 : b126                     lda (ind1),y
182b : 08                       php         ;test stores do not alter flags
182c : 49c3                     eor #$c3
182e : 28                       plp
182f : 990302                   sta abst,y
1832 : 08                       php         ;flags after load/store sequence
1833 : 49c3                     eor #$c3
1835 : d91802                   cmp abs1,y  ;test result
                                trap_ne
1838 : d0fe            >        bne *           ;failed not equal (non zero)
                        
183a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
183b : 0908            >            ora #decmode        ;ignore decimal mode bit
183d : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
183f : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
1842 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1844 : 88                       dey
1845 : 10de                     bpl tlday1                  
                        
1847 : a003                     ldy #3      ;testing store result
1849 : a200                     ldx #0
184b : b90302           tstay   lda abst,y
184e : 49c3                     eor #$c3
1850 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
1853 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1855 : 8a                       txa
1856 : 990302                   sta abst,y  ;clear                
1859 : 88                       dey
185a : 10ef                     bpl tstay
                        
185c : a003                     ldy #3
185e :                  tlday2   
                                set_stat 0
                       >            load_flag 0
185e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1860 : 48              >            pha         ;use stack to load status
1861 : 28              >            plp
                        
1862 : b91802                   lda abs1,y
1865 : 08                       php         ;test stores do not alter flags
1866 : 49c3                     eor #$c3
1868 : 28                       plp
1869 : 9132                     sta (indt),y
186b : 08                       php         ;flags after load/store sequence
186c : 49c3                     eor #$c3
186e : d126                     cmp (ind1),y    ;test result
                                trap_ne
1870 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1872 : 68                       pla         ;load status
                                eor_flag 0
1873 : 0908            >            ora #decmode        ;ignore decimal mode bit
1875 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1877 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
187a : d0fe            >        bne *           ;failed not equal (non zero)
                        
187c : 88                       dey
187d : 10df                     bpl tlday2                  
                        
187f : a003                     ldy #3
1881 :                  tlday3   
                                set_stat $ff
                       >            load_flag $ff
1881 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1883 : 48              >            pha         ;use stack to load status
1884 : 28              >            plp
                        
1885 : b91802                   lda abs1,y
1888 : 08                       php         ;test stores do not alter flags
1889 : 49c3                     eor #$c3
188b : 28                       plp
188c : 9132                     sta (indt),y
188e : 08                       php         ;flags after load/store sequence
188f : 49c3                     eor #$c3
1891 : d126                     cmp (ind1),y   ;test result
                                trap_ne
1893 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1895 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1896 : 0908            >            ora #decmode        ;ignore decimal mode bit
1898 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
189a : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
189d : d0fe            >        bne *           ;failed not equal (non zero)
                        
189f : 88                       dey
18a0 : 10df                     bpl tlday3
                                
18a2 : a003                     ldy #3      ;testing store result
18a4 : a200                     ldx #0
18a6 : b90302           tstay1  lda abst,y
18a9 : 49c3                     eor #$c3
18ab : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
18ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
18b0 : 8a                       txa
18b1 : 990302                   sta abst,y  ;clear                
18b4 : 88                       dey
18b5 : 10ef                     bpl tstay1
                                
18b7 : a206                     ldx #6
18b9 : a003                     ldy #3
18bb :                  tldax4   
                                set_stat 0
                       >            load_flag 0
18bb : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
18bd : 48              >            pha         ;use stack to load status
18be : 28              >            plp
                        
18bf : a126                     lda (ind1,x)
18c1 : 08                       php         ;test stores do not alter flags
18c2 : 49c3                     eor #$c3
18c4 : 28                       plp
18c5 : 8132                     sta (indt,x)
18c7 : 08                       php         ;flags after load/store sequence
18c8 : 49c3                     eor #$c3
18ca : d91802                   cmp abs1,y  ;test result
                                trap_ne
18cd : d0fe            >        bne *           ;failed not equal (non zero)
                        
18cf : 68                       pla         ;load status
                                eor_flag 0
18d0 : 0908            >            ora #decmode        ;ignore decimal mode bit
18d2 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
18d4 : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
18d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18d9 : ca                       dex
18da : ca                       dex
18db : 88                       dey
18dc : 10dd                     bpl tldax4                  
                        
18de : a206                     ldx #6
18e0 : a003                     ldy #3
18e2 :                  tldax5
                                set_stat $ff
                       >            load_flag $ff
18e2 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
18e4 : 48              >            pha         ;use stack to load status
18e5 : 28              >            plp
                        
18e6 : a126                     lda (ind1,x)
18e8 : 08                       php         ;test stores do not alter flags
18e9 : 49c3                     eor #$c3
18eb : 28                       plp
18ec : 8132                     sta (indt,x)
18ee : 08                       php         ;flags after load/store sequence
18ef : 49c3                     eor #$c3
18f1 : d91802                   cmp abs1,y  ;test result
                                trap_ne
18f4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18f6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
18f7 : 0908            >            ora #decmode        ;ignore decimal mode bit
18f9 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
18fb : d91d02                   cmp fLDx,y  ;test flags
                                trap_ne
18fe : d0fe            >        bne *           ;failed not equal (non zero)
                        
1900 : ca                       dex
1901 : ca                       dex
1902 : 88                       dey
1903 : 10dd                     bpl tldax5
                        
1905 : a003                     ldy #3      ;testing store result
1907 : a200                     ldx #0
1909 : b90302           tstay2  lda abst,y
190c : 49c3                     eor #$c3
190e : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
1911 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1913 : 8a                       txa
1914 : 990302                   sta abst,y  ;clear                
1917 : 88                       dey
1918 : 10ef                     bpl tstay2
                                next_test
191a : ad0002          >            lda test_case   ;previous test
191d : c916            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
191f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0017 =                 >test_num = test_num + 1
1921 : a917            >            lda #test_num   ;*** next tests' number
1923 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
1926 : a2fd                     ldx #3+$fa
1928 : b51b             tldax6  lda zp1-$fa&$ff,x   ;wrap on indexed zp
192a : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
192d : ca                       dex
192e : e0fa                     cpx #$fa
1930 : b0f6                     bcs tldax6                  
1932 : a2fd                     ldx #3+$fa
1934 : bd1e01           tldax7  lda abs1-$fa,x      ;no wrap on indexed abs
1937 : 9512                     sta zpt-$fa&$ff,x
1939 : ca                       dex
193a : e0fa                     cpx #$fa
193c : b0f6                     bcs tldax7
                                                  
193e : a203                     ldx #3      ;testing wraparound result
1940 : a000                     ldy #0
1942 : b50c             tstax1  lda zpt,x
1944 : d515                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1946 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1948 : 940c                     sty zpt,x   ;clear                
194a : bd0302                   lda abst,x
194d : dd1802                   cmp abs1,x
                                trap_ne     ;store to abs,x data
1950 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1952 : 8a                       txa
1953 : 9d0302                   sta abst,x  ;clear                
1956 : ca                       dex
1957 : 10e9                     bpl tstax1
                        
1959 : a0fb                     ldy #3+$f8
195b : a2fe                     ldx #6+$f8
195d : a12e             tlday4  lda (ind1-$f8&$ff,x) ;wrap on indexed zp indirect
195f : 990b01                   sta abst-$f8,y
1962 : ca                       dex
1963 : ca                       dex
1964 : 88                       dey
1965 : c0f8                     cpy #$f8
1967 : b0f4                     bcs tlday4
1969 : a003                     ldy #3      ;testing wraparound result
196b : a200                     ldx #0
196d : b90302           tstay4  lda abst,y
1970 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
1973 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1975 : 8a                       txa
1976 : 990302                   sta abst,y  ;clear                
1979 : 88                       dey
197a : 10f1                     bpl tstay4
                                
197c : a0fb                     ldy #3+$f8
197e : b92001           tlday5  lda abs1-$f8,y  ;no wrap on indexed abs
1981 : 913a                     sta (inwt),y
1983 : 88                       dey
1984 : c0f8                     cpy #$f8
1986 : b0f6                     bcs tlday5                  
1988 : a003                     ldy #3      ;testing wraparound result
198a : a200                     ldx #0
198c : b90302           tstay5  lda abst,y
198f : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
1992 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1994 : 8a                       txa
1995 : 990302                   sta abst,y  ;clear                
1998 : 88                       dey
1999 : 10f1                     bpl tstay5
                        
199b : a0fb                     ldy #3+$f8
199d : a2fe                     ldx #6+$f8
199f : b130             tlday6  lda (inw1),y    ;no wrap on zp indirect indexed 
19a1 : 813a                     sta (indt-$f8&$ff,x)
19a3 : ca                       dex
19a4 : ca                       dex
19a5 : 88                       dey
19a6 : c0f8                     cpy #$f8
19a8 : b0f5                     bcs tlday6
19aa : a003                     ldy #3      ;testing wraparound result
19ac : a200                     ldx #0
19ae : b90302           tstay6  lda abst,y
19b1 : d91802                   cmp abs1,y
                                trap_ne     ;store to abs data
19b4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19b6 : 8a                       txa
19b7 : 990302                   sta abst,y  ;clear                
19ba : 88                       dey
19bb : 10f1                     bpl tstay6
                                next_test
19bd : ad0002          >            lda test_case   ;previous test
19c0 : c917            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
19c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0018 =                 >test_num = test_num + 1
19c4 : a918            >            lda #test_num   ;*** next tests' number
19c6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
19c9 : a900            >            lda #0  &m8i         ;force enable interrupts (mask I)
                       >
19cb : 48              >            pha         ;use stack to load status
19cc : 28              >            plp
                        
19cd : a515                     lda zp1
19cf : 08                       php         ;test stores do not alter flags
19d0 : 49c3                     eor #$c3
19d2 : 28                       plp
19d3 : 8d0302                   sta abst
19d6 : 08                       php         ;flags after load/store sequence
19d7 : 49c3                     eor #$c3
19d9 : c9c3                     cmp #$c3    ;test result
                                trap_ne
19db : d0fe            >        bne *           ;failed not equal (non zero)
                        
19dd : 68                       pla         ;load status
                                eor_flag 0
19de : 0908            >            ora #decmode        ;ignore decimal mode bit
19e0 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
19e2 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
19e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
19e7 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
19e9 : 48              >            pha         ;use stack to load status
19ea : 28              >            plp
                        
19eb : a516                     lda zp1+1
19ed : 08                       php         ;test stores do not alter flags
19ee : 49c3                     eor #$c3
19f0 : 28                       plp
19f1 : 8d0402                   sta abst+1
19f4 : 08                       php         ;flags after load/store sequence
19f5 : 49c3                     eor #$c3
19f7 : c982                     cmp #$82    ;test result
                                trap_ne
19f9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19fb : 68                       pla         ;load status
                                eor_flag 0
19fc : 0908            >            ora #decmode        ;ignore decimal mode bit
19fe : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1a00 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1a03 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a05 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1a07 : 48              >            pha         ;use stack to load status
1a08 : 28              >            plp
                        
1a09 : a517                     lda zp1+2
1a0b : 08                       php         ;test stores do not alter flags
1a0c : 49c3                     eor #$c3
1a0e : 28                       plp
1a0f : 8d0502                   sta abst+2
1a12 : 08                       php         ;flags after load/store sequence
1a13 : 49c3                     eor #$c3
1a15 : c941                     cmp #$41    ;test result
                                trap_ne
1a17 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a19 : 68                       pla         ;load status
                                eor_flag 0
1a1a : 0908            >            ora #decmode        ;ignore decimal mode bit
1a1c : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1a1e : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1a21 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a23 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1a25 : 48              >            pha         ;use stack to load status
1a26 : 28              >            plp
                        
1a27 : a518                     lda zp1+3
1a29 : 08                       php         ;test stores do not alter flags
1a2a : 49c3                     eor #$c3
1a2c : 28                       plp
1a2d : 8d0602                   sta abst+3
1a30 : 08                       php         ;flags after load/store sequence
1a31 : 49c3                     eor #$c3
1a33 : c900                     cmp #0      ;test result
                                trap_ne
1a35 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a37 : 68                       pla         ;load status
                                eor_flag 0
1a38 : 0908            >            ora #decmode        ;ignore decimal mode bit
1a3a : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1a3c : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1a3f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a41 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1a43 : 48              >            pha         ;use stack to load status
1a44 : 28              >            plp
                        
1a45 : a515                     lda zp1  
1a47 : 08                       php         ;test stores do not alter flags
1a48 : 49c3                     eor #$c3
1a4a : 28                       plp
1a4b : 8d0302                   sta abst  
1a4e : 08                       php         ;flags after load/store sequence
1a4f : 49c3                     eor #$c3
1a51 : c9c3                     cmp #$c3    ;test result
                                trap_ne
1a53 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a55 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a56 : 0908            >            ora #decmode        ;ignore decimal mode bit
1a58 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1a5a : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1a5d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a5f : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1a61 : 48              >            pha         ;use stack to load status
1a62 : 28              >            plp
                        
1a63 : a516                     lda zp1+1
1a65 : 08                       php         ;test stores do not alter flags
1a66 : 49c3                     eor #$c3
1a68 : 28                       plp
1a69 : 8d0402                   sta abst+1
1a6c : 08                       php         ;flags after load/store sequence
1a6d : 49c3                     eor #$c3
1a6f : c982                     cmp #$82    ;test result
                                trap_ne
1a71 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a73 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a74 : 0908            >            ora #decmode        ;ignore decimal mode bit
1a76 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1a78 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1a7b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a7d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1a7f : 48              >            pha         ;use stack to load status
1a80 : 28              >            plp
                        
1a81 : a517                     lda zp1+2
1a83 : 08                       php         ;test stores do not alter flags
1a84 : 49c3                     eor #$c3
1a86 : 28                       plp
1a87 : 8d0502                   sta abst+2
1a8a : 08                       php         ;flags after load/store sequence
1a8b : 49c3                     eor #$c3
1a8d : c941                     cmp #$41    ;test result
                                trap_ne
1a8f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a91 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a92 : 0908            >            ora #decmode        ;ignore decimal mode bit
1a94 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1a96 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1a99 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a9b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1a9d : 48              >            pha         ;use stack to load status
1a9e : 28              >            plp
                        
1a9f : a518                     lda zp1+3
1aa1 : 08                       php         ;test stores do not alter flags
1aa2 : 49c3                     eor #$c3
1aa4 : 28                       plp
1aa5 : 8d0602                   sta abst+3
1aa8 : 08                       php         ;flags after load/store sequence
1aa9 : 49c3                     eor #$c3
1aab : c900                     cmp #0      ;test result
                                trap_ne
1aad : d0fe            >        bne *           ;failed not equal (non zero)
                        
1aaf : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1ab0 : 0908            >            ora #decmode        ;ignore decimal mode bit
1ab2 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1ab4 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1ab7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1ab9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1abb : 48              >            pha         ;use stack to load status
1abc : 28              >            plp
                        
1abd : ad1802                   lda abs1  
1ac0 : 08                       php         ;test stores do not alter flags
1ac1 : 49c3                     eor #$c3
1ac3 : 28                       plp
1ac4 : 850c                     sta zpt  
1ac6 : 08                       php         ;flags after load/store sequence
1ac7 : 49c3                     eor #$c3
1ac9 : c515                     cmp zp1     ;test result
                                trap_ne
1acb : d0fe            >        bne *           ;failed not equal (non zero)
                        
1acd : 68                       pla         ;load status
                                eor_flag 0
1ace : 0908            >            ora #decmode        ;ignore decimal mode bit
1ad0 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1ad2 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1ad5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1ad7 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1ad9 : 48              >            pha         ;use stack to load status
1ada : 28              >            plp
                        
1adb : ad1902                   lda abs1+1
1ade : 08                       php         ;test stores do not alter flags
1adf : 49c3                     eor #$c3
1ae1 : 28                       plp
1ae2 : 850d                     sta zpt+1
1ae4 : 08                       php         ;flags after load/store sequence
1ae5 : 49c3                     eor #$c3
1ae7 : c516                     cmp zp1+1   ;test result
                                trap_ne
1ae9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1aeb : 68                       pla         ;load status
                                eor_flag 0
1aec : 0908            >            ora #decmode        ;ignore decimal mode bit
1aee : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1af0 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1af3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1af5 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1af7 : 48              >            pha         ;use stack to load status
1af8 : 28              >            plp
                        
1af9 : ad1a02                   lda abs1+2
1afc : 08                       php         ;test stores do not alter flags
1afd : 49c3                     eor #$c3
1aff : 28                       plp
1b00 : 850e                     sta zpt+2
1b02 : 08                       php         ;flags after load/store sequence
1b03 : 49c3                     eor #$c3
1b05 : c517                     cmp zp1+2   ;test result
                                trap_ne
1b07 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b09 : 68                       pla         ;load status
                                eor_flag 0
1b0a : 0908            >            ora #decmode        ;ignore decimal mode bit
1b0c : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1b0e : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1b11 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1b13 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1b15 : 48              >            pha         ;use stack to load status
1b16 : 28              >            plp
                        
1b17 : ad1b02                   lda abs1+3
1b1a : 08                       php         ;test stores do not alter flags
1b1b : 49c3                     eor #$c3
1b1d : 28                       plp
1b1e : 850f                     sta zpt+3
1b20 : 08                       php         ;flags after load/store sequence
1b21 : 49c3                     eor #$c3
1b23 : c518                     cmp zp1+3   ;test result
                                trap_ne
1b25 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b27 : 68                       pla         ;load status
                                eor_flag 0
1b28 : 0908            >            ora #decmode        ;ignore decimal mode bit
1b2a : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1b2c : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1b2f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1b31 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1b33 : 48              >            pha         ;use stack to load status
1b34 : 28              >            plp
                        
1b35 : ad1802                   lda abs1  
1b38 : 08                       php         ;test stores do not alter flags
1b39 : 49c3                     eor #$c3
1b3b : 28                       plp
1b3c : 850c                     sta zpt  
1b3e : 08                       php         ;flags after load/store sequence
1b3f : 49c3                     eor #$c3
1b41 : c515                     cmp zp1     ;test result
                                trap_ne
1b43 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b45 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1b46 : 0908            >            ora #decmode        ;ignore decimal mode bit
1b48 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1b4a : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1b4d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1b4f : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1b51 : 48              >            pha         ;use stack to load status
1b52 : 28              >            plp
                        
1b53 : ad1902                   lda abs1+1
1b56 : 08                       php         ;test stores do not alter flags
1b57 : 49c3                     eor #$c3
1b59 : 28                       plp
1b5a : 850d                     sta zpt+1
1b5c : 08                       php         ;flags after load/store sequence
1b5d : 49c3                     eor #$c3
1b5f : c516                     cmp zp1+1   ;test result
                                trap_ne
1b61 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b63 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1b64 : 0908            >            ora #decmode        ;ignore decimal mode bit
1b66 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1b68 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1b6b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1b6d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1b6f : 48              >            pha         ;use stack to load status
1b70 : 28              >            plp
                        
1b71 : ad1a02                   lda abs1+2
1b74 : 08                       php         ;test stores do not alter flags
1b75 : 49c3                     eor #$c3
1b77 : 28                       plp
1b78 : 850e                     sta zpt+2
1b7a : 08                       php         ;flags after load/store sequence
1b7b : 49c3                     eor #$c3
1b7d : c517                     cmp zp1+2   ;test result
                                trap_ne
1b7f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b81 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1b82 : 0908            >            ora #decmode        ;ignore decimal mode bit
1b84 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1b86 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1b89 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1b8b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1b8d : 48              >            pha         ;use stack to load status
1b8e : 28              >            plp
                        
1b8f : ad1b02                   lda abs1+3
1b92 : 08                       php         ;test stores do not alter flags
1b93 : 49c3                     eor #$c3
1b95 : 28                       plp
1b96 : 850f                     sta zpt+3
1b98 : 08                       php         ;flags after load/store sequence
1b99 : 49c3                     eor #$c3
1b9b : c518                     cmp zp1+3   ;test result
                                trap_ne
1b9d : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b9f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1ba0 : 0908            >            ora #decmode        ;ignore decimal mode bit
1ba2 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1ba4 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1ba7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0  
                       >            load_flag 0  
1ba9 : a900            >            lda #0  &m8i         ;force enable interrupts (mask I)
                       >
1bab : 48              >            pha         ;use stack to load status
1bac : 28              >            plp
                        
1bad : a9c3                     lda #$c3
1baf : 08                       php
1bb0 : cd1802                   cmp abs1    ;test result
                                trap_ne
1bb3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1bb5 : 68                       pla         ;load status
                                eor_flag 0
1bb6 : 0908            >            ora #decmode        ;ignore decimal mode bit
1bb8 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1bba : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1bbd : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1bbf : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1bc1 : 48              >            pha         ;use stack to load status
1bc2 : 28              >            plp
                        
1bc3 : a982                     lda #$82
1bc5 : 08                       php
1bc6 : cd1902                   cmp abs1+1  ;test result
                                trap_ne
1bc9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1bcb : 68                       pla         ;load status
                                eor_flag 0
1bcc : 0908            >            ora #decmode        ;ignore decimal mode bit
1bce : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1bd0 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1bd3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1bd5 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1bd7 : 48              >            pha         ;use stack to load status
1bd8 : 28              >            plp
                        
1bd9 : a941                     lda #$41
1bdb : 08                       php
1bdc : cd1a02                   cmp abs1+2  ;test result
                                trap_ne
1bdf : d0fe            >        bne *           ;failed not equal (non zero)
                        
1be1 : 68                       pla         ;load status
                                eor_flag 0
1be2 : 0908            >            ora #decmode        ;ignore decimal mode bit
1be4 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1be6 : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1be9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1beb : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1bed : 48              >            pha         ;use stack to load status
1bee : 28              >            plp
                        
1bef : a900                     lda #0
1bf1 : 08                       php
1bf2 : cd1b02                   cmp abs1+3  ;test result
                                trap_ne
1bf5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1bf7 : 68                       pla         ;load status
                                eor_flag 0
1bf8 : 0908            >            ora #decmode        ;ignore decimal mode bit
1bfa : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1bfc : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1bff : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1c01 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1c03 : 48              >            pha         ;use stack to load status
1c04 : 28              >            plp
                        
1c05 : a9c3                     lda #$c3  
1c07 : 08                       php
1c08 : cd1802                   cmp abs1    ;test result
                                trap_ne
1c0b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1c0d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1c0e : 0908            >            ora #decmode        ;ignore decimal mode bit
1c10 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1c12 : cd1d02                   cmp fLDx    ;test flags
                                trap_ne
1c15 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1c17 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1c19 : 48              >            pha         ;use stack to load status
1c1a : 28              >            plp
                        
1c1b : a982                     lda #$82
1c1d : 08                       php
1c1e : cd1902                   cmp abs1+1  ;test result
                                trap_ne
1c21 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1c23 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1c24 : 0908            >            ora #decmode        ;ignore decimal mode bit
1c26 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1c28 : cd1e02                   cmp fLDx+1  ;test flags
                                trap_ne
1c2b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1c2d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1c2f : 48              >            pha         ;use stack to load status
1c30 : 28              >            plp
                        
1c31 : a941                     lda #$41
1c33 : 08                       php
1c34 : cd1a02                   cmp abs1+2  ;test result
                                trap_ne
1c37 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1c39 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1c3a : 0908            >            ora #decmode        ;ignore decimal mode bit
1c3c : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1c3e : cd1f02                   cmp fLDx+2  ;test flags
                                trap_ne
1c41 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1c43 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1c45 : 48              >            pha         ;use stack to load status
1c46 : 28              >            plp
                        
1c47 : a900                     lda #0
1c49 : 08                       php
1c4a : cd1b02                   cmp abs1+3  ;test result
                                trap_ne
1c4d : d0fe            >        bne *           ;failed not equal (non zero)
                        
1c4f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1c50 : 0908            >            ora #decmode        ;ignore decimal mode bit
1c52 : 4979            >            eor #(lo~fnz &m8i|faod)  ;mask I, invert expected flags + always on bits
                        
1c54 : cd2002                   cmp fLDx+3  ;test flags
                                trap_ne
1c57 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
1c59 : a200                     ldx #0
1c5b : a50c                     lda zpt  
1c5d : 49c3                     eor #$c3
1c5f : c515                     cmp zp1  
                                trap_ne     ;store to zp data
1c61 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1c63 : 860c                     stx zpt     ;clear                
1c65 : ad0302                   lda abst  
1c68 : 49c3                     eor #$c3
1c6a : cd1802                   cmp abs1  
                                trap_ne     ;store to abs data
1c6d : d0fe            >        bne *           ;failed not equal (non zero)
                        
1c6f : 8e0302                   stx abst    ;clear                
1c72 : a50d                     lda zpt+1
1c74 : 49c3                     eor #$c3
1c76 : c516                     cmp zp1+1
                                trap_ne     ;store to zp data
1c78 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1c7a : 860d                     stx zpt+1   ;clear                
1c7c : ad0402                   lda abst+1
1c7f : 49c3                     eor #$c3
1c81 : cd1902                   cmp abs1+1
                                trap_ne     ;store to abs data
1c84 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1c86 : 8e0402                   stx abst+1  ;clear                
1c89 : a50e                     lda zpt+2
1c8b : 49c3                     eor #$c3
1c8d : c517                     cmp zp1+2
                                trap_ne     ;store to zp data
1c8f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1c91 : 860e                     stx zpt+2   ;clear                
1c93 : ad0502                   lda abst+2
1c96 : 49c3                     eor #$c3
1c98 : cd1a02                   cmp abs1+2
                                trap_ne     ;store to abs data
1c9b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1c9d : 8e0502                   stx abst+2  ;clear                
1ca0 : a50f                     lda zpt+3
1ca2 : 49c3                     eor #$c3
1ca4 : c518                     cmp zp1+3
                                trap_ne     ;store to zp data
1ca6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ca8 : 860f                     stx zpt+3   ;clear                
1caa : ad0602                   lda abst+3
1cad : 49c3                     eor #$c3
1caf : cd1b02                   cmp abs1+3
                                trap_ne     ;store to abs data
1cb2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1cb4 : 8e0602                   stx abst+3  ;clear                
                                next_test
1cb7 : ad0002          >            lda test_case   ;previous test
1cba : c918            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1cbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0019 =                 >test_num = test_num + 1
1cbe : a919            >            lda #test_num   ;*** next tests' number
1cc0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing bit test & compares BIT CPX CPY CMP all addressing modes
                        ; BIT - zp / abs
                                set_a $ff,0
                       >            load_flag 0
1cc3 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1cc5 : 48              >            pha         ;use stack to load status
1cc6 : a9ff            >            lda #$ff     ;precharge accu
1cc8 : 28              >            plp
                        
1cc9 : 2418                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1ccb : 08              >            php         ;save flags
1ccc : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1cce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cd0 : 68              >            pla         ;load status
1cd1 : 48              >            pha
                       >            cmp_flag fz 
1cd2 : 0908            >            ora #decmode        ;ignore decimal mode bit
1cd4 : c93a            >            cmp #(fz |faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1cd6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cd8 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1cd9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1cdb : 48              >            pha         ;use stack to load status
1cdc : a901            >            lda #1     ;precharge accu
1cde : 28              >            plp
                        
1cdf : 2417                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1ce1 : 08              >            php         ;save flags
1ce2 : c901            >            cmp #1     ;test result
                       >            trap_ne
1ce4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ce6 : 68              >            pla         ;load status
1ce7 : 48              >            pha
                       >            cmp_flag fv
1ce8 : 0908            >            ora #decmode        ;ignore decimal mode bit
1cea : c978            >            cmp #(fv|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1cec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cee : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1cef : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1cf1 : 48              >            pha         ;use stack to load status
1cf2 : a901            >            lda #1     ;precharge accu
1cf4 : 28              >            plp
                        
1cf5 : 2416                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1cf7 : 08              >            php         ;save flags
1cf8 : c901            >            cmp #1     ;test result
                       >            trap_ne
1cfa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cfc : 68              >            pla         ;load status
1cfd : 48              >            pha
                       >            cmp_flag fnz
1cfe : 0908            >            ora #decmode        ;ignore decimal mode bit
1d00 : c9ba            >            cmp #(fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d04 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1d05 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1d07 : 48              >            pha         ;use stack to load status
1d08 : a901            >            lda #1     ;precharge accu
1d0a : 28              >            plp
                        
1d0b : 2415                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1d0d : 08              >            php         ;save flags
1d0e : c901            >            cmp #1     ;test result
                       >            trap_ne
1d10 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d12 : 68              >            pla         ;load status
1d13 : 48              >            pha
                       >            cmp_flag fnv
1d14 : 0908            >            ora #decmode        ;ignore decimal mode bit
1d16 : c9f8            >            cmp #(fnv|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d18 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d1a : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1d1b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1d1d : 48              >            pha         ;use stack to load status
1d1e : a9ff            >            lda #$ff     ;precharge accu
1d20 : 28              >            plp
                        
1d21 : 2418                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1d23 : 08              >            php         ;save flags
1d24 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1d26 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d28 : 68              >            pla         ;load status
1d29 : 48              >            pha
                       >            cmp_flag ~fnv 
1d2a : 0908            >            ora #decmode        ;ignore decimal mode bit
1d2c : c93b            >            cmp #(~fnv |faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d30 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1d31 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1d33 : 48              >            pha         ;use stack to load status
1d34 : a901            >            lda #1     ;precharge accu
1d36 : 28              >            plp
                        
1d37 : 2417                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1d39 : 08              >            php         ;save flags
1d3a : c901            >            cmp #1     ;test result
                       >            trap_ne
1d3c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d3e : 68              >            pla         ;load status
1d3f : 48              >            pha
                       >            cmp_flag ~fnz
1d40 : 0908            >            ora #decmode        ;ignore decimal mode bit
1d42 : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d44 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d46 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1d47 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1d49 : 48              >            pha         ;use stack to load status
1d4a : a901            >            lda #1     ;precharge accu
1d4c : 28              >            plp
                        
1d4d : 2416                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1d4f : 08              >            php         ;save flags
1d50 : c901            >            cmp #1     ;test result
                       >            trap_ne
1d52 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d54 : 68              >            pla         ;load status
1d55 : 48              >            pha
                       >            cmp_flag ~fv
1d56 : 0908            >            ora #decmode        ;ignore decimal mode bit
1d58 : c9bb            >            cmp #(~fv|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d5c : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1d5d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1d5f : 48              >            pha         ;use stack to load status
1d60 : a901            >            lda #1     ;precharge accu
1d62 : 28              >            plp
                        
1d63 : 2415                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1d65 : 08              >            php         ;save flags
1d66 : c901            >            cmp #1     ;test result
                       >            trap_ne
1d68 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d6a : 68              >            pla         ;load status
1d6b : 48              >            pha
                       >            cmp_flag ~fz
1d6c : 0908            >            ora #decmode        ;ignore decimal mode bit
1d6e : c9f9            >            cmp #(~fz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d72 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,0
                       >            load_flag 0
1d73 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1d75 : 48              >            pha         ;use stack to load status
1d76 : a9ff            >            lda #$ff     ;precharge accu
1d78 : 28              >            plp
                        
1d79 : 2c1b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1d7c : 08              >            php         ;save flags
1d7d : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1d7f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d81 : 68              >            pla         ;load status
1d82 : 48              >            pha
                       >            cmp_flag fz 
1d83 : 0908            >            ora #decmode        ;ignore decimal mode bit
1d85 : c93a            >            cmp #(fz |faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d89 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1d8a : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1d8c : 48              >            pha         ;use stack to load status
1d8d : a901            >            lda #1     ;precharge accu
1d8f : 28              >            plp
                        
1d90 : 2c1a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1d93 : 08              >            php         ;save flags
1d94 : c901            >            cmp #1     ;test result
                       >            trap_ne
1d96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d98 : 68              >            pla         ;load status
1d99 : 48              >            pha
                       >            cmp_flag fv
1d9a : 0908            >            ora #decmode        ;ignore decimal mode bit
1d9c : c978            >            cmp #(fv|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1d9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1da0 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1da1 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1da3 : 48              >            pha         ;use stack to load status
1da4 : a901            >            lda #1     ;precharge accu
1da6 : 28              >            plp
                        
1da7 : 2c1902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1daa : 08              >            php         ;save flags
1dab : c901            >            cmp #1     ;test result
                       >            trap_ne
1dad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1daf : 68              >            pla         ;load status
1db0 : 48              >            pha
                       >            cmp_flag fnz
1db1 : 0908            >            ora #decmode        ;ignore decimal mode bit
1db3 : c9ba            >            cmp #(fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1db5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1db7 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1db8 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1dba : 48              >            pha         ;use stack to load status
1dbb : a901            >            lda #1     ;precharge accu
1dbd : 28              >            plp
                        
1dbe : 2c1802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1dc1 : 08              >            php         ;save flags
1dc2 : c901            >            cmp #1     ;test result
                       >            trap_ne
1dc4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dc6 : 68              >            pla         ;load status
1dc7 : 48              >            pha
                       >            cmp_flag fnv
1dc8 : 0908            >            ora #decmode        ;ignore decimal mode bit
1dca : c9f8            >            cmp #(fnv|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1dcc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dce : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1dcf : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1dd1 : 48              >            pha         ;use stack to load status
1dd2 : a9ff            >            lda #$ff     ;precharge accu
1dd4 : 28              >            plp
                        
1dd5 : 2c1b02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1dd8 : 08              >            php         ;save flags
1dd9 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1ddb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ddd : 68              >            pla         ;load status
1dde : 48              >            pha
                       >            cmp_flag ~fnv 
1ddf : 0908            >            ora #decmode        ;ignore decimal mode bit
1de1 : c93b            >            cmp #(~fnv |faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1de3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1de5 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1de6 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1de8 : 48              >            pha         ;use stack to load status
1de9 : a901            >            lda #1     ;precharge accu
1deb : 28              >            plp
                        
1dec : 2c1a02                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1def : 08              >            php         ;save flags
1df0 : c901            >            cmp #1     ;test result
                       >            trap_ne
1df2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1df4 : 68              >            pla         ;load status
1df5 : 48              >            pha
                       >            cmp_flag ~fnz
1df6 : 0908            >            ora #decmode        ;ignore decimal mode bit
1df8 : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1dfa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dfc : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1dfd : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1dff : 48              >            pha         ;use stack to load status
1e00 : a901            >            lda #1     ;precharge accu
1e02 : 28              >            plp
                        
1e03 : 2c1902                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1e06 : 08              >            php         ;save flags
1e07 : c901            >            cmp #1     ;test result
                       >            trap_ne
1e09 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e0b : 68              >            pla         ;load status
1e0c : 48              >            pha
                       >            cmp_flag ~fv
1e0d : 0908            >            ora #decmode        ;ignore decimal mode bit
1e0f : c9bb            >            cmp #(~fv|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e11 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e13 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1e14 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1e16 : 48              >            pha         ;use stack to load status
1e17 : a901            >            lda #1     ;precharge accu
1e19 : 28              >            plp
                        
1e1a : 2c1802                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1e1d : 08              >            php         ;save flags
1e1e : c901            >            cmp #1     ;test result
                       >            trap_ne
1e20 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e22 : 68              >            pla         ;load status
1e23 : 48              >            pha
                       >            cmp_flag ~fz
1e24 : 0908            >            ora #decmode        ;ignore decimal mode bit
1e26 : c9f9            >            cmp #(~fz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e2a : 28              >            plp         ;restore status
                        
                                next_test
1e2b : ad0002          >            lda test_case   ;previous test
1e2e : c919            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1e30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001a =                 >test_num = test_num + 1
1e32 : a91a            >            lda #test_num   ;*** next tests' number
1e34 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; CPX - zp / abs / #         
                                set_x $80,0
                       >            load_flag 0
1e37 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1e39 : 48              >            pha         ;use stack to load status
1e3a : a280            >            ldx #$80     ;precharge index x
1e3c : 28              >            plp
                        
1e3d : e419                     cpx zp7f
                                tst_stat fc
1e3f : 08              >            php         ;save status
1e40 : 68              >            pla         ;use stack to retrieve status
1e41 : 48              >            pha
                       >            cmp_flag fc
1e42 : 0908            >            ora #decmode        ;ignore decimal mode bit
1e44 : c939            >            cmp #(fc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e48 : 28              >            plp         ;restore status
                        
1e49 : ca                       dex
1e4a : e419                     cpx zp7f
                                tst_stat fzc
1e4c : 08              >            php         ;save status
1e4d : 68              >            pla         ;use stack to retrieve status
1e4e : 48              >            pha
                       >            cmp_flag fzc
1e4f : 0908            >            ora #decmode        ;ignore decimal mode bit
1e51 : c93b            >            cmp #(fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e53 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e55 : 28              >            plp         ;restore status
                        
1e56 : ca                       dex
1e57 : e419                     cpx zp7f
                                tst_x $7e,fn
1e59 : 08              >            php         ;save flags
1e5a : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1e5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e5e : 68              >            pla         ;load status
1e5f : 48              >            pha
                       >            cmp_flag fn
1e60 : 0908            >            ora #decmode        ;ignore decimal mode bit
1e62 : c9b8            >            cmp #(fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e66 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1e67 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1e69 : 48              >            pha         ;use stack to load status
1e6a : a280            >            ldx #$80     ;precharge index x
1e6c : 28              >            plp
                        
1e6d : e419                     cpx zp7f
                                tst_stat ~fnz
1e6f : 08              >            php         ;save status
1e70 : 68              >            pla         ;use stack to retrieve status
1e71 : 48              >            pha
                       >            cmp_flag ~fnz
1e72 : 0908            >            ora #decmode        ;ignore decimal mode bit
1e74 : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e76 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e78 : 28              >            plp         ;restore status
                        
1e79 : ca                       dex
1e7a : e419                     cpx zp7f
                                tst_stat ~fn
1e7c : 08              >            php         ;save status
1e7d : 68              >            pla         ;use stack to retrieve status
1e7e : 48              >            pha
                       >            cmp_flag ~fn
1e7f : 0908            >            ora #decmode        ;ignore decimal mode bit
1e81 : c97b            >            cmp #(~fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e83 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e85 : 28              >            plp         ;restore status
                        
1e86 : ca                       dex
1e87 : e419                     cpx zp7f
                                tst_x $7e,~fzc
1e89 : 08              >            php         ;save flags
1e8a : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1e8c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e8e : 68              >            pla         ;load status
1e8f : 48              >            pha
                       >            cmp_flag ~fzc
1e90 : 0908            >            ora #decmode        ;ignore decimal mode bit
1e92 : c9f8            >            cmp #(~fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1e94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e96 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1e97 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1e99 : 48              >            pha         ;use stack to load status
1e9a : a280            >            ldx #$80     ;precharge index x
1e9c : 28              >            plp
                        
1e9d : ec1c02                   cpx abs7f
                                tst_stat fc
1ea0 : 08              >            php         ;save status
1ea1 : 68              >            pla         ;use stack to retrieve status
1ea2 : 48              >            pha
                       >            cmp_flag fc
1ea3 : 0908            >            ora #decmode        ;ignore decimal mode bit
1ea5 : c939            >            cmp #(fc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1ea7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ea9 : 28              >            plp         ;restore status
                        
1eaa : ca                       dex
1eab : ec1c02                   cpx abs7f
                                tst_stat fzc
1eae : 08              >            php         ;save status
1eaf : 68              >            pla         ;use stack to retrieve status
1eb0 : 48              >            pha
                       >            cmp_flag fzc
1eb1 : 0908            >            ora #decmode        ;ignore decimal mode bit
1eb3 : c93b            >            cmp #(fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1eb5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eb7 : 28              >            plp         ;restore status
                        
1eb8 : ca                       dex
1eb9 : ec1c02                   cpx abs7f
                                tst_x $7e,fn
1ebc : 08              >            php         ;save flags
1ebd : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1ebf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ec1 : 68              >            pla         ;load status
1ec2 : 48              >            pha
                       >            cmp_flag fn
1ec3 : 0908            >            ora #decmode        ;ignore decimal mode bit
1ec5 : c9b8            >            cmp #(fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1ec7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ec9 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1eca : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1ecc : 48              >            pha         ;use stack to load status
1ecd : a280            >            ldx #$80     ;precharge index x
1ecf : 28              >            plp
                        
1ed0 : ec1c02                   cpx abs7f
                                tst_stat ~fnz
1ed3 : 08              >            php         ;save status
1ed4 : 68              >            pla         ;use stack to retrieve status
1ed5 : 48              >            pha
                       >            cmp_flag ~fnz
1ed6 : 0908            >            ora #decmode        ;ignore decimal mode bit
1ed8 : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1eda : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1edc : 28              >            plp         ;restore status
                        
1edd : ca                       dex
1ede : ec1c02                   cpx abs7f
                                tst_stat ~fn
1ee1 : 08              >            php         ;save status
1ee2 : 68              >            pla         ;use stack to retrieve status
1ee3 : 48              >            pha
                       >            cmp_flag ~fn
1ee4 : 0908            >            ora #decmode        ;ignore decimal mode bit
1ee6 : c97b            >            cmp #(~fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1ee8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eea : 28              >            plp         ;restore status
                        
1eeb : ca                       dex
1eec : ec1c02                   cpx abs7f
                                tst_x $7e,~fzc
1eef : 08              >            php         ;save flags
1ef0 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1ef2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ef4 : 68              >            pla         ;load status
1ef5 : 48              >            pha
                       >            cmp_flag ~fzc
1ef6 : 0908            >            ora #decmode        ;ignore decimal mode bit
1ef8 : c9f8            >            cmp #(~fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1efa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1efc : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1efd : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1eff : 48              >            pha         ;use stack to load status
1f00 : a280            >            ldx #$80     ;precharge index x
1f02 : 28              >            plp
                        
1f03 : e07f                     cpx #$7f
                                tst_stat fc
1f05 : 08              >            php         ;save status
1f06 : 68              >            pla         ;use stack to retrieve status
1f07 : 48              >            pha
                       >            cmp_flag fc
1f08 : 0908            >            ora #decmode        ;ignore decimal mode bit
1f0a : c939            >            cmp #(fc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f0c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f0e : 28              >            plp         ;restore status
                        
1f0f : ca                       dex
1f10 : e07f                     cpx #$7f
                                tst_stat fzc
1f12 : 08              >            php         ;save status
1f13 : 68              >            pla         ;use stack to retrieve status
1f14 : 48              >            pha
                       >            cmp_flag fzc
1f15 : 0908            >            ora #decmode        ;ignore decimal mode bit
1f17 : c93b            >            cmp #(fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f19 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f1b : 28              >            plp         ;restore status
                        
1f1c : ca                       dex
1f1d : e07f                     cpx #$7f
                                tst_x $7e,fn
1f1f : 08              >            php         ;save flags
1f20 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1f22 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f24 : 68              >            pla         ;load status
1f25 : 48              >            pha
                       >            cmp_flag fn
1f26 : 0908            >            ora #decmode        ;ignore decimal mode bit
1f28 : c9b8            >            cmp #(fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f2a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f2c : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1f2d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1f2f : 48              >            pha         ;use stack to load status
1f30 : a280            >            ldx #$80     ;precharge index x
1f32 : 28              >            plp
                        
1f33 : e07f                     cpx #$7f
                                tst_stat ~fnz
1f35 : 08              >            php         ;save status
1f36 : 68              >            pla         ;use stack to retrieve status
1f37 : 48              >            pha
                       >            cmp_flag ~fnz
1f38 : 0908            >            ora #decmode        ;ignore decimal mode bit
1f3a : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f3c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f3e : 28              >            plp         ;restore status
                        
1f3f : ca                       dex
1f40 : e07f                     cpx #$7f
                                tst_stat ~fn
1f42 : 08              >            php         ;save status
1f43 : 68              >            pla         ;use stack to retrieve status
1f44 : 48              >            pha
                       >            cmp_flag ~fn
1f45 : 0908            >            ora #decmode        ;ignore decimal mode bit
1f47 : c97b            >            cmp #(~fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f49 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f4b : 28              >            plp         ;restore status
                        
1f4c : ca                       dex
1f4d : e07f                     cpx #$7f
                                tst_x $7e,~fzc
1f4f : 08              >            php         ;save flags
1f50 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1f52 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f54 : 68              >            pla         ;load status
1f55 : 48              >            pha
                       >            cmp_flag ~fzc
1f56 : 0908            >            ora #decmode        ;ignore decimal mode bit
1f58 : c9f8            >            cmp #(~fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f5c : 28              >            plp         ;restore status
                        
                                next_test
1f5d : ad0002          >            lda test_case   ;previous test
1f60 : c91a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1f62 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001b =                 >test_num = test_num + 1
1f64 : a91b            >            lda #test_num   ;*** next tests' number
1f66 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPY - zp / abs / #         
                                set_y $80,0
                       >            load_flag 0
1f69 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1f6b : 48              >            pha         ;use stack to load status
1f6c : a080            >            ldy #$80     ;precharge index y
1f6e : 28              >            plp
                        
1f6f : c419                     cpy zp7f
                                tst_stat fc
1f71 : 08              >            php         ;save status
1f72 : 68              >            pla         ;use stack to retrieve status
1f73 : 48              >            pha
                       >            cmp_flag fc
1f74 : 0908            >            ora #decmode        ;ignore decimal mode bit
1f76 : c939            >            cmp #(fc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f78 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f7a : 28              >            plp         ;restore status
                        
1f7b : 88                       dey
1f7c : c419                     cpy zp7f
                                tst_stat fzc
1f7e : 08              >            php         ;save status
1f7f : 68              >            pla         ;use stack to retrieve status
1f80 : 48              >            pha
                       >            cmp_flag fzc
1f81 : 0908            >            ora #decmode        ;ignore decimal mode bit
1f83 : c93b            >            cmp #(fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f85 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f87 : 28              >            plp         ;restore status
                        
1f88 : 88                       dey
1f89 : c419                     cpy zp7f
                                tst_y $7e,fn
1f8b : 08              >            php         ;save flags
1f8c : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1f8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f90 : 68              >            pla         ;load status
1f91 : 48              >            pha
                       >            cmp_flag fn
1f92 : 0908            >            ora #decmode        ;ignore decimal mode bit
1f94 : c9b8            >            cmp #(fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1f96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f98 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1f99 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1f9b : 48              >            pha         ;use stack to load status
1f9c : a080            >            ldy #$80     ;precharge index y
1f9e : 28              >            plp
                        
1f9f : c419                     cpy zp7f
                                tst_stat ~fnz
1fa1 : 08              >            php         ;save status
1fa2 : 68              >            pla         ;use stack to retrieve status
1fa3 : 48              >            pha
                       >            cmp_flag ~fnz
1fa4 : 0908            >            ora #decmode        ;ignore decimal mode bit
1fa6 : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1fa8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1faa : 28              >            plp         ;restore status
                        
1fab : 88                       dey
1fac : c419                     cpy zp7f
                                tst_stat ~fn
1fae : 08              >            php         ;save status
1faf : 68              >            pla         ;use stack to retrieve status
1fb0 : 48              >            pha
                       >            cmp_flag ~fn
1fb1 : 0908            >            ora #decmode        ;ignore decimal mode bit
1fb3 : c97b            >            cmp #(~fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1fb5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fb7 : 28              >            plp         ;restore status
                        
1fb8 : 88                       dey
1fb9 : c419                     cpy zp7f
                                tst_y $7e,~fzc
1fbb : 08              >            php         ;save flags
1fbc : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1fbe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fc0 : 68              >            pla         ;load status
1fc1 : 48              >            pha
                       >            cmp_flag ~fzc
1fc2 : 0908            >            ora #decmode        ;ignore decimal mode bit
1fc4 : c9f8            >            cmp #(~fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1fc6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fc8 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1fc9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
1fcb : 48              >            pha         ;use stack to load status
1fcc : a080            >            ldy #$80     ;precharge index y
1fce : 28              >            plp
                        
1fcf : cc1c02                   cpy abs7f
                                tst_stat fc
1fd2 : 08              >            php         ;save status
1fd3 : 68              >            pla         ;use stack to retrieve status
1fd4 : 48              >            pha
                       >            cmp_flag fc
1fd5 : 0908            >            ora #decmode        ;ignore decimal mode bit
1fd7 : c939            >            cmp #(fc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1fd9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fdb : 28              >            plp         ;restore status
                        
1fdc : 88                       dey
1fdd : cc1c02                   cpy abs7f
                                tst_stat fzc
1fe0 : 08              >            php         ;save status
1fe1 : 68              >            pla         ;use stack to retrieve status
1fe2 : 48              >            pha
                       >            cmp_flag fzc
1fe3 : 0908            >            ora #decmode        ;ignore decimal mode bit
1fe5 : c93b            >            cmp #(fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1fe7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fe9 : 28              >            plp         ;restore status
                        
1fea : 88                       dey
1feb : cc1c02                   cpy abs7f
                                tst_y $7e,fn
1fee : 08              >            php         ;save flags
1fef : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1ff1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ff3 : 68              >            pla         ;load status
1ff4 : 48              >            pha
                       >            cmp_flag fn
1ff5 : 0908            >            ora #decmode        ;ignore decimal mode bit
1ff7 : c9b8            >            cmp #(fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
1ff9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ffb : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1ffc : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
1ffe : 48              >            pha         ;use stack to load status
1fff : a080            >            ldy #$80     ;precharge index y
2001 : 28              >            plp
                        
2002 : cc1c02                   cpy abs7f
                                tst_stat ~fnz
2005 : 08              >            php         ;save status
2006 : 68              >            pla         ;use stack to retrieve status
2007 : 48              >            pha
                       >            cmp_flag ~fnz
2008 : 0908            >            ora #decmode        ;ignore decimal mode bit
200a : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
200c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
200e : 28              >            plp         ;restore status
                        
200f : 88                       dey
2010 : cc1c02                   cpy abs7f
                                tst_stat ~fn
2013 : 08              >            php         ;save status
2014 : 68              >            pla         ;use stack to retrieve status
2015 : 48              >            pha
                       >            cmp_flag ~fn
2016 : 0908            >            ora #decmode        ;ignore decimal mode bit
2018 : c97b            >            cmp #(~fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
201a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
201c : 28              >            plp         ;restore status
                        
201d : 88                       dey
201e : cc1c02                   cpy abs7f
                                tst_y $7e,~fzc
2021 : 08              >            php         ;save flags
2022 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
2024 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2026 : 68              >            pla         ;load status
2027 : 48              >            pha
                       >            cmp_flag ~fzc
2028 : 0908            >            ora #decmode        ;ignore decimal mode bit
202a : c9f8            >            cmp #(~fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
202c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
202e : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
202f : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2031 : 48              >            pha         ;use stack to load status
2032 : a080            >            ldy #$80     ;precharge index y
2034 : 28              >            plp
                        
2035 : c07f                     cpy #$7f
                                tst_stat fc
2037 : 08              >            php         ;save status
2038 : 68              >            pla         ;use stack to retrieve status
2039 : 48              >            pha
                       >            cmp_flag fc
203a : 0908            >            ora #decmode        ;ignore decimal mode bit
203c : c939            >            cmp #(fc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
203e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2040 : 28              >            plp         ;restore status
                        
2041 : 88                       dey
2042 : c07f                     cpy #$7f
                                tst_stat fzc
2044 : 08              >            php         ;save status
2045 : 68              >            pla         ;use stack to retrieve status
2046 : 48              >            pha
                       >            cmp_flag fzc
2047 : 0908            >            ora #decmode        ;ignore decimal mode bit
2049 : c93b            >            cmp #(fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
204b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
204d : 28              >            plp         ;restore status
                        
204e : 88                       dey
204f : c07f                     cpy #$7f
                                tst_y $7e,fn
2051 : 08              >            php         ;save flags
2052 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
2054 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2056 : 68              >            pla         ;load status
2057 : 48              >            pha
                       >            cmp_flag fn
2058 : 0908            >            ora #decmode        ;ignore decimal mode bit
205a : c9b8            >            cmp #(fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
205c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
205e : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
205f : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2061 : 48              >            pha         ;use stack to load status
2062 : a080            >            ldy #$80     ;precharge index y
2064 : 28              >            plp
                        
2065 : c07f                     cpy #$7f
                                tst_stat ~fnz
2067 : 08              >            php         ;save status
2068 : 68              >            pla         ;use stack to retrieve status
2069 : 48              >            pha
                       >            cmp_flag ~fnz
206a : 0908            >            ora #decmode        ;ignore decimal mode bit
206c : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
206e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2070 : 28              >            plp         ;restore status
                        
2071 : 88                       dey
2072 : c07f                     cpy #$7f
                                tst_stat ~fn
2074 : 08              >            php         ;save status
2075 : 68              >            pla         ;use stack to retrieve status
2076 : 48              >            pha
                       >            cmp_flag ~fn
2077 : 0908            >            ora #decmode        ;ignore decimal mode bit
2079 : c97b            >            cmp #(~fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
207b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
207d : 28              >            plp         ;restore status
                        
207e : 88                       dey
207f : c07f                     cpy #$7f
                                tst_y $7e,~fzc
2081 : 08              >            php         ;save flags
2082 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
2084 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2086 : 68              >            pla         ;load status
2087 : 48              >            pha
                       >            cmp_flag ~fzc
2088 : 0908            >            ora #decmode        ;ignore decimal mode bit
208a : c9f8            >            cmp #(~fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
208c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
208e : 28              >            plp         ;restore status
                        
                                next_test
208f : ad0002          >            lda test_case   ;previous test
2092 : c91b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2094 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001c =                 >test_num = test_num + 1
2096 : a91c            >            lda #test_num   ;*** next tests' number
2098 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CMP - zp / abs / #         
                                set_a $80,0
                       >            load_flag 0
209b : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
209d : 48              >            pha         ;use stack to load status
209e : a980            >            lda #$80     ;precharge accu
20a0 : 28              >            plp
                        
20a1 : c519                     cmp zp7f
                                tst_a $80,fc
20a3 : 08              >            php         ;save flags
20a4 : c980            >            cmp #$80     ;test result
                       >            trap_ne
20a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20a8 : 68              >            pla         ;load status
20a9 : 48              >            pha
                       >            cmp_flag fc
20aa : 0908            >            ora #decmode        ;ignore decimal mode bit
20ac : c939            >            cmp #(fc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
20ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20b0 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
20b1 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
20b3 : 48              >            pha         ;use stack to load status
20b4 : a97f            >            lda #$7f     ;precharge accu
20b6 : 28              >            plp
                        
20b7 : c519                     cmp zp7f
                                tst_a $7f,fzc
20b9 : 08              >            php         ;save flags
20ba : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
20bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20be : 68              >            pla         ;load status
20bf : 48              >            pha
                       >            cmp_flag fzc
20c0 : 0908            >            ora #decmode        ;ignore decimal mode bit
20c2 : c93b            >            cmp #(fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
20c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20c6 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
20c7 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
20c9 : 48              >            pha         ;use stack to load status
20ca : a97e            >            lda #$7e     ;precharge accu
20cc : 28              >            plp
                        
20cd : c519                     cmp zp7f
                                tst_a $7e,fn
20cf : 08              >            php         ;save flags
20d0 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20d4 : 68              >            pla         ;load status
20d5 : 48              >            pha
                       >            cmp_flag fn
20d6 : 0908            >            ora #decmode        ;ignore decimal mode bit
20d8 : c9b8            >            cmp #(fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
20da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20dc : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
20dd : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
20df : 48              >            pha         ;use stack to load status
20e0 : a980            >            lda #$80     ;precharge accu
20e2 : 28              >            plp
                        
20e3 : c519                     cmp zp7f
                                tst_a $80,~fnz
20e5 : 08              >            php         ;save flags
20e6 : c980            >            cmp #$80     ;test result
                       >            trap_ne
20e8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20ea : 68              >            pla         ;load status
20eb : 48              >            pha
                       >            cmp_flag ~fnz
20ec : 0908            >            ora #decmode        ;ignore decimal mode bit
20ee : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
20f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20f2 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
20f3 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
20f5 : 48              >            pha         ;use stack to load status
20f6 : a97f            >            lda #$7f     ;precharge accu
20f8 : 28              >            plp
                        
20f9 : c519                     cmp zp7f
                                tst_a $7f,~fn
20fb : 08              >            php         ;save flags
20fc : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
20fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2100 : 68              >            pla         ;load status
2101 : 48              >            pha
                       >            cmp_flag ~fn
2102 : 0908            >            ora #decmode        ;ignore decimal mode bit
2104 : c97b            >            cmp #(~fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2106 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2108 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2109 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
210b : 48              >            pha         ;use stack to load status
210c : a97e            >            lda #$7e     ;precharge accu
210e : 28              >            plp
                        
210f : c519                     cmp zp7f
                                tst_a $7e,~fzc
2111 : 08              >            php         ;save flags
2112 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2114 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2116 : 68              >            pla         ;load status
2117 : 48              >            pha
                       >            cmp_flag ~fzc
2118 : 0908            >            ora #decmode        ;ignore decimal mode bit
211a : c9f8            >            cmp #(~fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
211c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
211e : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
211f : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2121 : 48              >            pha         ;use stack to load status
2122 : a980            >            lda #$80     ;precharge accu
2124 : 28              >            plp
                        
2125 : cd1c02                   cmp abs7f
                                tst_a $80,fc
2128 : 08              >            php         ;save flags
2129 : c980            >            cmp #$80     ;test result
                       >            trap_ne
212b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
212d : 68              >            pla         ;load status
212e : 48              >            pha
                       >            cmp_flag fc
212f : 0908            >            ora #decmode        ;ignore decimal mode bit
2131 : c939            >            cmp #(fc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2133 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2135 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2136 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2138 : 48              >            pha         ;use stack to load status
2139 : a97f            >            lda #$7f     ;precharge accu
213b : 28              >            plp
                        
213c : cd1c02                   cmp abs7f
                                tst_a $7f,fzc
213f : 08              >            php         ;save flags
2140 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2142 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2144 : 68              >            pla         ;load status
2145 : 48              >            pha
                       >            cmp_flag fzc
2146 : 0908            >            ora #decmode        ;ignore decimal mode bit
2148 : c93b            >            cmp #(fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
214a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
214c : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
214d : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
214f : 48              >            pha         ;use stack to load status
2150 : a97e            >            lda #$7e     ;precharge accu
2152 : 28              >            plp
                        
2153 : cd1c02                   cmp abs7f
                                tst_a $7e,fn
2156 : 08              >            php         ;save flags
2157 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2159 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
215b : 68              >            pla         ;load status
215c : 48              >            pha
                       >            cmp_flag fn
215d : 0908            >            ora #decmode        ;ignore decimal mode bit
215f : c9b8            >            cmp #(fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2161 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2163 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2164 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2166 : 48              >            pha         ;use stack to load status
2167 : a980            >            lda #$80     ;precharge accu
2169 : 28              >            plp
                        
216a : cd1c02                   cmp abs7f
                                tst_a $80,~fnz
216d : 08              >            php         ;save flags
216e : c980            >            cmp #$80     ;test result
                       >            trap_ne
2170 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2172 : 68              >            pla         ;load status
2173 : 48              >            pha
                       >            cmp_flag ~fnz
2174 : 0908            >            ora #decmode        ;ignore decimal mode bit
2176 : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2178 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
217a : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
217b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
217d : 48              >            pha         ;use stack to load status
217e : a97f            >            lda #$7f     ;precharge accu
2180 : 28              >            plp
                        
2181 : cd1c02                   cmp abs7f
                                tst_a $7f,~fn
2184 : 08              >            php         ;save flags
2185 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2187 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2189 : 68              >            pla         ;load status
218a : 48              >            pha
                       >            cmp_flag ~fn
218b : 0908            >            ora #decmode        ;ignore decimal mode bit
218d : c97b            >            cmp #(~fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
218f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2191 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2192 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2194 : 48              >            pha         ;use stack to load status
2195 : a97e            >            lda #$7e     ;precharge accu
2197 : 28              >            plp
                        
2198 : cd1c02                   cmp abs7f
                                tst_a $7e,~fzc
219b : 08              >            php         ;save flags
219c : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
219e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21a0 : 68              >            pla         ;load status
21a1 : 48              >            pha
                       >            cmp_flag ~fzc
21a2 : 0908            >            ora #decmode        ;ignore decimal mode bit
21a4 : c9f8            >            cmp #(~fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
21a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21a8 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
21a9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
21ab : 48              >            pha         ;use stack to load status
21ac : a980            >            lda #$80     ;precharge accu
21ae : 28              >            plp
                        
21af : c97f                     cmp #$7f
                                tst_a $80,fc
21b1 : 08              >            php         ;save flags
21b2 : c980            >            cmp #$80     ;test result
                       >            trap_ne
21b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21b6 : 68              >            pla         ;load status
21b7 : 48              >            pha
                       >            cmp_flag fc
21b8 : 0908            >            ora #decmode        ;ignore decimal mode bit
21ba : c939            >            cmp #(fc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
21bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21be : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
21bf : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
21c1 : 48              >            pha         ;use stack to load status
21c2 : a97f            >            lda #$7f     ;precharge accu
21c4 : 28              >            plp
                        
21c5 : c97f                     cmp #$7f
                                tst_a $7f,fzc
21c7 : 08              >            php         ;save flags
21c8 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
21ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21cc : 68              >            pla         ;load status
21cd : 48              >            pha
                       >            cmp_flag fzc
21ce : 0908            >            ora #decmode        ;ignore decimal mode bit
21d0 : c93b            >            cmp #(fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
21d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21d4 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
21d5 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
21d7 : 48              >            pha         ;use stack to load status
21d8 : a97e            >            lda #$7e     ;precharge accu
21da : 28              >            plp
                        
21db : c97f                     cmp #$7f
                                tst_a $7e,fn
21dd : 08              >            php         ;save flags
21de : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
21e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21e2 : 68              >            pla         ;load status
21e3 : 48              >            pha
                       >            cmp_flag fn
21e4 : 0908            >            ora #decmode        ;ignore decimal mode bit
21e6 : c9b8            >            cmp #(fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
21e8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21ea : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
21eb : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
21ed : 48              >            pha         ;use stack to load status
21ee : a980            >            lda #$80     ;precharge accu
21f0 : 28              >            plp
                        
21f1 : c97f                     cmp #$7f
                                tst_a $80,~fnz
21f3 : 08              >            php         ;save flags
21f4 : c980            >            cmp #$80     ;test result
                       >            trap_ne
21f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21f8 : 68              >            pla         ;load status
21f9 : 48              >            pha
                       >            cmp_flag ~fnz
21fa : 0908            >            ora #decmode        ;ignore decimal mode bit
21fc : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
21fe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2200 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2201 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2203 : 48              >            pha         ;use stack to load status
2204 : a97f            >            lda #$7f     ;precharge accu
2206 : 28              >            plp
                        
2207 : c97f                     cmp #$7f
                                tst_a $7f,~fn
2209 : 08              >            php         ;save flags
220a : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
220c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
220e : 68              >            pla         ;load status
220f : 48              >            pha
                       >            cmp_flag ~fn
2210 : 0908            >            ora #decmode        ;ignore decimal mode bit
2212 : c97b            >            cmp #(~fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2214 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2216 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2217 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2219 : 48              >            pha         ;use stack to load status
221a : a97e            >            lda #$7e     ;precharge accu
221c : 28              >            plp
                        
221d : c97f                     cmp #$7f
                                tst_a $7e,~fzc
221f : 08              >            php         ;save flags
2220 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2222 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2224 : 68              >            pla         ;load status
2225 : 48              >            pha
                       >            cmp_flag ~fzc
2226 : 0908            >            ora #decmode        ;ignore decimal mode bit
2228 : c9f8            >            cmp #(~fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
222a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
222c : 28              >            plp         ;restore status
                        
                        
222d : a204                     ldx #4          ;with indexing by X
                                set_a $80,0
                       >            load_flag 0
222f : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2231 : 48              >            pha         ;use stack to load status
2232 : a980            >            lda #$80     ;precharge accu
2234 : 28              >            plp
                        
2235 : d515                     cmp zp1,x
                                tst_a $80,fc
2237 : 08              >            php         ;save flags
2238 : c980            >            cmp #$80     ;test result
                       >            trap_ne
223a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
223c : 68              >            pla         ;load status
223d : 48              >            pha
                       >            cmp_flag fc
223e : 0908            >            ora #decmode        ;ignore decimal mode bit
2240 : c939            >            cmp #(fc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2242 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2244 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2245 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2247 : 48              >            pha         ;use stack to load status
2248 : a97f            >            lda #$7f     ;precharge accu
224a : 28              >            plp
                        
224b : d515                     cmp zp1,x
                                tst_a $7f,fzc
224d : 08              >            php         ;save flags
224e : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2250 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2252 : 68              >            pla         ;load status
2253 : 48              >            pha
                       >            cmp_flag fzc
2254 : 0908            >            ora #decmode        ;ignore decimal mode bit
2256 : c93b            >            cmp #(fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2258 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
225a : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
225b : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
225d : 48              >            pha         ;use stack to load status
225e : a97e            >            lda #$7e     ;precharge accu
2260 : 28              >            plp
                        
2261 : d515                     cmp zp1,x
                                tst_a $7e,fn
2263 : 08              >            php         ;save flags
2264 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2266 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2268 : 68              >            pla         ;load status
2269 : 48              >            pha
                       >            cmp_flag fn
226a : 0908            >            ora #decmode        ;ignore decimal mode bit
226c : c9b8            >            cmp #(fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
226e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2270 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2271 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2273 : 48              >            pha         ;use stack to load status
2274 : a980            >            lda #$80     ;precharge accu
2276 : 28              >            plp
                        
2277 : d515                     cmp zp1,x
                                tst_a $80,~fnz
2279 : 08              >            php         ;save flags
227a : c980            >            cmp #$80     ;test result
                       >            trap_ne
227c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
227e : 68              >            pla         ;load status
227f : 48              >            pha
                       >            cmp_flag ~fnz
2280 : 0908            >            ora #decmode        ;ignore decimal mode bit
2282 : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2284 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2286 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2287 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2289 : 48              >            pha         ;use stack to load status
228a : a97f            >            lda #$7f     ;precharge accu
228c : 28              >            plp
                        
228d : d515                     cmp zp1,x
                                tst_a $7f,~fn
228f : 08              >            php         ;save flags
2290 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2292 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2294 : 68              >            pla         ;load status
2295 : 48              >            pha
                       >            cmp_flag ~fn
2296 : 0908            >            ora #decmode        ;ignore decimal mode bit
2298 : c97b            >            cmp #(~fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
229a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
229c : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
229d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
229f : 48              >            pha         ;use stack to load status
22a0 : a97e            >            lda #$7e     ;precharge accu
22a2 : 28              >            plp
                        
22a3 : d515                     cmp zp1,x
                                tst_a $7e,~fzc
22a5 : 08              >            php         ;save flags
22a6 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
22a8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22aa : 68              >            pla         ;load status
22ab : 48              >            pha
                       >            cmp_flag ~fzc
22ac : 0908            >            ora #decmode        ;ignore decimal mode bit
22ae : c9f8            >            cmp #(~fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
22b0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22b2 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
22b3 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
22b5 : 48              >            pha         ;use stack to load status
22b6 : a980            >            lda #$80     ;precharge accu
22b8 : 28              >            plp
                        
22b9 : dd1802                   cmp abs1,x
                                tst_a $80,fc
22bc : 08              >            php         ;save flags
22bd : c980            >            cmp #$80     ;test result
                       >            trap_ne
22bf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22c1 : 68              >            pla         ;load status
22c2 : 48              >            pha
                       >            cmp_flag fc
22c3 : 0908            >            ora #decmode        ;ignore decimal mode bit
22c5 : c939            >            cmp #(fc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
22c7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22c9 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
22ca : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
22cc : 48              >            pha         ;use stack to load status
22cd : a97f            >            lda #$7f     ;precharge accu
22cf : 28              >            plp
                        
22d0 : dd1802                   cmp abs1,x
                                tst_a $7f,fzc
22d3 : 08              >            php         ;save flags
22d4 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
22d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22d8 : 68              >            pla         ;load status
22d9 : 48              >            pha
                       >            cmp_flag fzc
22da : 0908            >            ora #decmode        ;ignore decimal mode bit
22dc : c93b            >            cmp #(fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
22de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22e0 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
22e1 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
22e3 : 48              >            pha         ;use stack to load status
22e4 : a97e            >            lda #$7e     ;precharge accu
22e6 : 28              >            plp
                        
22e7 : dd1802                   cmp abs1,x
                                tst_a $7e,fn
22ea : 08              >            php         ;save flags
22eb : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
22ed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22ef : 68              >            pla         ;load status
22f0 : 48              >            pha
                       >            cmp_flag fn
22f1 : 0908            >            ora #decmode        ;ignore decimal mode bit
22f3 : c9b8            >            cmp #(fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
22f5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22f7 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
22f8 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
22fa : 48              >            pha         ;use stack to load status
22fb : a980            >            lda #$80     ;precharge accu
22fd : 28              >            plp
                        
22fe : dd1802                   cmp abs1,x
                                tst_a $80,~fnz
2301 : 08              >            php         ;save flags
2302 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2304 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2306 : 68              >            pla         ;load status
2307 : 48              >            pha
                       >            cmp_flag ~fnz
2308 : 0908            >            ora #decmode        ;ignore decimal mode bit
230a : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
230c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
230e : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
230f : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2311 : 48              >            pha         ;use stack to load status
2312 : a97f            >            lda #$7f     ;precharge accu
2314 : 28              >            plp
                        
2315 : dd1802                   cmp abs1,x
                                tst_a $7f,~fn
2318 : 08              >            php         ;save flags
2319 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
231b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
231d : 68              >            pla         ;load status
231e : 48              >            pha
                       >            cmp_flag ~fn
231f : 0908            >            ora #decmode        ;ignore decimal mode bit
2321 : c97b            >            cmp #(~fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2323 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2325 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2326 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2328 : 48              >            pha         ;use stack to load status
2329 : a97e            >            lda #$7e     ;precharge accu
232b : 28              >            plp
                        
232c : dd1802                   cmp abs1,x
                                tst_a $7e,~fzc
232f : 08              >            php         ;save flags
2330 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2332 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2334 : 68              >            pla         ;load status
2335 : 48              >            pha
                       >            cmp_flag ~fzc
2336 : 0908            >            ora #decmode        ;ignore decimal mode bit
2338 : c9f8            >            cmp #(~fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
233a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
233c : 28              >            plp         ;restore status
                        
                        
233d : a004                     ldy #4          ;with indexing by Y
233f : a208                     ldx #8          ;with indexed indirect
                                set_a $80,0
                       >            load_flag 0
2341 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2343 : 48              >            pha         ;use stack to load status
2344 : a980            >            lda #$80     ;precharge accu
2346 : 28              >            plp
                        
2347 : d91802                   cmp abs1,y
                                tst_a $80,fc
234a : 08              >            php         ;save flags
234b : c980            >            cmp #$80     ;test result
                       >            trap_ne
234d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
234f : 68              >            pla         ;load status
2350 : 48              >            pha
                       >            cmp_flag fc
2351 : 0908            >            ora #decmode        ;ignore decimal mode bit
2353 : c939            >            cmp #(fc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2355 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2357 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2358 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
235a : 48              >            pha         ;use stack to load status
235b : a97f            >            lda #$7f     ;precharge accu
235d : 28              >            plp
                        
235e : d91802                   cmp abs1,y
                                tst_a $7f,fzc
2361 : 08              >            php         ;save flags
2362 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2364 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2366 : 68              >            pla         ;load status
2367 : 48              >            pha
                       >            cmp_flag fzc
2368 : 0908            >            ora #decmode        ;ignore decimal mode bit
236a : c93b            >            cmp #(fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
236c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
236e : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
236f : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2371 : 48              >            pha         ;use stack to load status
2372 : a97e            >            lda #$7e     ;precharge accu
2374 : 28              >            plp
                        
2375 : d91802                   cmp abs1,y
                                tst_a $7e,fn
2378 : 08              >            php         ;save flags
2379 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
237b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
237d : 68              >            pla         ;load status
237e : 48              >            pha
                       >            cmp_flag fn
237f : 0908            >            ora #decmode        ;ignore decimal mode bit
2381 : c9b8            >            cmp #(fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2383 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2385 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2386 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2388 : 48              >            pha         ;use stack to load status
2389 : a980            >            lda #$80     ;precharge accu
238b : 28              >            plp
                        
238c : d91802                   cmp abs1,y
                                tst_a $80,~fnz
238f : 08              >            php         ;save flags
2390 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2392 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2394 : 68              >            pla         ;load status
2395 : 48              >            pha
                       >            cmp_flag ~fnz
2396 : 0908            >            ora #decmode        ;ignore decimal mode bit
2398 : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
239a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
239c : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
239d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
239f : 48              >            pha         ;use stack to load status
23a0 : a97f            >            lda #$7f     ;precharge accu
23a2 : 28              >            plp
                        
23a3 : d91802                   cmp abs1,y
                                tst_a $7f,~fn
23a6 : 08              >            php         ;save flags
23a7 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
23a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23ab : 68              >            pla         ;load status
23ac : 48              >            pha
                       >            cmp_flag ~fn
23ad : 0908            >            ora #decmode        ;ignore decimal mode bit
23af : c97b            >            cmp #(~fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
23b1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23b3 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
23b4 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
23b6 : 48              >            pha         ;use stack to load status
23b7 : a97e            >            lda #$7e     ;precharge accu
23b9 : 28              >            plp
                        
23ba : d91802                   cmp abs1,y
                                tst_a $7e,~fzc
23bd : 08              >            php         ;save flags
23be : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
23c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23c2 : 68              >            pla         ;load status
23c3 : 48              >            pha
                       >            cmp_flag ~fzc
23c4 : 0908            >            ora #decmode        ;ignore decimal mode bit
23c6 : c9f8            >            cmp #(~fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
23c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23ca : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
23cb : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
23cd : 48              >            pha         ;use stack to load status
23ce : a980            >            lda #$80     ;precharge accu
23d0 : 28              >            plp
                        
23d1 : c126                     cmp (ind1,x)
                                tst_a $80,fc
23d3 : 08              >            php         ;save flags
23d4 : c980            >            cmp #$80     ;test result
                       >            trap_ne
23d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23d8 : 68              >            pla         ;load status
23d9 : 48              >            pha
                       >            cmp_flag fc
23da : 0908            >            ora #decmode        ;ignore decimal mode bit
23dc : c939            >            cmp #(fc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
23de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23e0 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
23e1 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
23e3 : 48              >            pha         ;use stack to load status
23e4 : a97f            >            lda #$7f     ;precharge accu
23e6 : 28              >            plp
                        
23e7 : c126                     cmp (ind1,x)
                                tst_a $7f,fzc
23e9 : 08              >            php         ;save flags
23ea : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
23ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23ee : 68              >            pla         ;load status
23ef : 48              >            pha
                       >            cmp_flag fzc
23f0 : 0908            >            ora #decmode        ;ignore decimal mode bit
23f2 : c93b            >            cmp #(fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
23f4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23f6 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
23f7 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
23f9 : 48              >            pha         ;use stack to load status
23fa : a97e            >            lda #$7e     ;precharge accu
23fc : 28              >            plp
                        
23fd : c126                     cmp (ind1,x)
                                tst_a $7e,fn
23ff : 08              >            php         ;save flags
2400 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2402 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2404 : 68              >            pla         ;load status
2405 : 48              >            pha
                       >            cmp_flag fn
2406 : 0908            >            ora #decmode        ;ignore decimal mode bit
2408 : c9b8            >            cmp #(fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
240a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
240c : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
240d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
240f : 48              >            pha         ;use stack to load status
2410 : a980            >            lda #$80     ;precharge accu
2412 : 28              >            plp
                        
2413 : c126                     cmp (ind1,x)
                                tst_a $80,~fnz
2415 : 08              >            php         ;save flags
2416 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2418 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
241a : 68              >            pla         ;load status
241b : 48              >            pha
                       >            cmp_flag ~fnz
241c : 0908            >            ora #decmode        ;ignore decimal mode bit
241e : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2420 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2422 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2423 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2425 : 48              >            pha         ;use stack to load status
2426 : a97f            >            lda #$7f     ;precharge accu
2428 : 28              >            plp
                        
2429 : c126                     cmp (ind1,x)
                                tst_a $7f,~fn
242b : 08              >            php         ;save flags
242c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
242e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2430 : 68              >            pla         ;load status
2431 : 48              >            pha
                       >            cmp_flag ~fn
2432 : 0908            >            ora #decmode        ;ignore decimal mode bit
2434 : c97b            >            cmp #(~fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2436 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2438 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2439 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
243b : 48              >            pha         ;use stack to load status
243c : a97e            >            lda #$7e     ;precharge accu
243e : 28              >            plp
                        
243f : c126                     cmp (ind1,x)
                                tst_a $7e,~fzc
2441 : 08              >            php         ;save flags
2442 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2444 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2446 : 68              >            pla         ;load status
2447 : 48              >            pha
                       >            cmp_flag ~fzc
2448 : 0908            >            ora #decmode        ;ignore decimal mode bit
244a : c9f8            >            cmp #(~fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
244c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
244e : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
244f : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2451 : 48              >            pha         ;use stack to load status
2452 : a980            >            lda #$80     ;precharge accu
2454 : 28              >            plp
                        
2455 : d126                     cmp (ind1),y
                                tst_a $80,fc
2457 : 08              >            php         ;save flags
2458 : c980            >            cmp #$80     ;test result
                       >            trap_ne
245a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
245c : 68              >            pla         ;load status
245d : 48              >            pha
                       >            cmp_flag fc
245e : 0908            >            ora #decmode        ;ignore decimal mode bit
2460 : c939            >            cmp #(fc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2462 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2464 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2465 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2467 : 48              >            pha         ;use stack to load status
2468 : a97f            >            lda #$7f     ;precharge accu
246a : 28              >            plp
                        
246b : d126                     cmp (ind1),y
                                tst_a $7f,fzc
246d : 08              >            php         ;save flags
246e : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2470 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2472 : 68              >            pla         ;load status
2473 : 48              >            pha
                       >            cmp_flag fzc
2474 : 0908            >            ora #decmode        ;ignore decimal mode bit
2476 : c93b            >            cmp #(fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
2478 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
247a : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
247b : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
247d : 48              >            pha         ;use stack to load status
247e : a97e            >            lda #$7e     ;precharge accu
2480 : 28              >            plp
                        
2481 : d126                     cmp (ind1),y
                                tst_a $7e,fn
2483 : 08              >            php         ;save flags
2484 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2486 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2488 : 68              >            pla         ;load status
2489 : 48              >            pha
                       >            cmp_flag fn
248a : 0908            >            ora #decmode        ;ignore decimal mode bit
248c : c9b8            >            cmp #(fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
248e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2490 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2491 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2493 : 48              >            pha         ;use stack to load status
2494 : a980            >            lda #$80     ;precharge accu
2496 : 28              >            plp
                        
2497 : d126                     cmp (ind1),y
                                tst_a $80,~fnz
2499 : 08              >            php         ;save flags
249a : c980            >            cmp #$80     ;test result
                       >            trap_ne
249c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
249e : 68              >            pla         ;load status
249f : 48              >            pha
                       >            cmp_flag ~fnz
24a0 : 0908            >            ora #decmode        ;ignore decimal mode bit
24a2 : c979            >            cmp #(~fnz|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
24a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24a6 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
24a7 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
24a9 : 48              >            pha         ;use stack to load status
24aa : a97f            >            lda #$7f     ;precharge accu
24ac : 28              >            plp
                        
24ad : d126                     cmp (ind1),y
                                tst_a $7f,~fn
24af : 08              >            php         ;save flags
24b0 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
24b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24b4 : 68              >            pla         ;load status
24b5 : 48              >            pha
                       >            cmp_flag ~fn
24b6 : 0908            >            ora #decmode        ;ignore decimal mode bit
24b8 : c97b            >            cmp #(~fn|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
24ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24bc : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
24bd : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
24bf : 48              >            pha         ;use stack to load status
24c0 : a97e            >            lda #$7e     ;precharge accu
24c2 : 28              >            plp
                        
24c3 : d126                     cmp (ind1),y
                                tst_a $7e,~fzc
24c5 : 08              >            php         ;save flags
24c6 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
24c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24ca : 68              >            pla         ;load status
24cb : 48              >            pha
                       >            cmp_flag ~fzc
24cc : 0908            >            ora #decmode        ;ignore decimal mode bit
24ce : c9f8            >            cmp #(~fzc|faod)&m8i  ;I_flag is always enabled + always on bits
                       >
                       >            trap_ne
24d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24d2 : 28              >            plp         ;restore status
                        
                                next_test
24d3 : ad0002          >            lda test_case   ;previous test
24d6 : c91c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
24d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001d =                 >test_num = test_num + 1
24da : a91d            >            lda #test_num   ;*** next tests' number
24dc : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing shifts - ASL LSR ROL ROR all addressing modes
                        ; shifts - accumulator
24df : a205                     ldx #5
24e1 :                  tasl
                                set_ax zps,0
                       >            load_flag 0
24e1 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
24e3 : 48              >            pha         ;use stack to load status
24e4 : b513            >            lda zps,x    ;precharge accu
24e6 : 28              >            plp
                        
24e7 : 0a                       asl a
                                tst_ax rASL,fASL,0
24e8 : 08              >            php         ;save flags
24e9 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
24ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24ee : 68              >            pla         ;load status
                       >            eor_flag 0
24ef : 0908            >            ora #decmode        ;ignore decimal mode bit
24f1 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
24f3 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
24f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24f8 : ca                       dex
24f9 : 10e6                     bpl tasl
24fb : a205                     ldx #5
24fd :                  tasl1
                                set_ax zps,$ff
                       >            load_flag $ff
24fd : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
24ff : 48              >            pha         ;use stack to load status
2500 : b513            >            lda zps,x    ;precharge accu
2502 : 28              >            plp
                        
2503 : 0a                       asl a
                                tst_ax rASL,fASL,$ff-fnzc
2504 : 08              >            php         ;save flags
2505 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
2508 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
250a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
250b : 0908            >            ora #decmode        ;ignore decimal mode bit
250d : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
250f : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
2512 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2514 : ca                       dex
2515 : 10e6                     bpl tasl1
                        
2517 : a205                     ldx #5
2519 :                  tlsr
                                set_ax zps,0
                       >            load_flag 0
2519 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
251b : 48              >            pha         ;use stack to load status
251c : b513            >            lda zps,x    ;precharge accu
251e : 28              >            plp
                        
251f : 4a                       lsr a
                                tst_ax rLSR,fLSR,0
2520 : 08              >            php         ;save flags
2521 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
2524 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2526 : 68              >            pla         ;load status
                       >            eor_flag 0
2527 : 0908            >            ora #decmode        ;ignore decimal mode bit
2529 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
252b : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
252e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2530 : ca                       dex
2531 : 10e6                     bpl tlsr
2533 : a205                     ldx #5
2535 :                  tlsr1
                                set_ax zps,$ff
                       >            load_flag $ff
2535 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2537 : 48              >            pha         ;use stack to load status
2538 : b513            >            lda zps,x    ;precharge accu
253a : 28              >            plp
                        
253b : 4a                       lsr a
                                tst_ax rLSR,fLSR,$ff-fnzc
253c : 08              >            php         ;save flags
253d : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
2540 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2542 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2543 : 0908            >            ora #decmode        ;ignore decimal mode bit
2545 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2547 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
254a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
254c : ca                       dex
254d : 10e6                     bpl tlsr1
                        
254f : a205                     ldx #5
2551 :                  trol
                                set_ax zps,0
                       >            load_flag 0
2551 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2553 : 48              >            pha         ;use stack to load status
2554 : b513            >            lda zps,x    ;precharge accu
2556 : 28              >            plp
                        
2557 : 2a                       rol a
                                tst_ax rROL,fROL,0
2558 : 08              >            php         ;save flags
2559 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
255c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
255e : 68              >            pla         ;load status
                       >            eor_flag 0
255f : 0908            >            ora #decmode        ;ignore decimal mode bit
2561 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2563 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
2566 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2568 : ca                       dex
2569 : 10e6                     bpl trol
256b : a205                     ldx #5
256d :                  trol1
                                set_ax zps,$ff-fc
                       >            load_flag $ff-fc
256d : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
256f : 48              >            pha         ;use stack to load status
2570 : b513            >            lda zps,x    ;precharge accu
2572 : 28              >            plp
                        
2573 : 2a                       rol a
                                tst_ax rROL,fROL,$ff-fnzc
2574 : 08              >            php         ;save flags
2575 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2578 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
257a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
257b : 0908            >            ora #decmode        ;ignore decimal mode bit
257d : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
257f : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
2582 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2584 : ca                       dex
2585 : 10e6                     bpl trol1
                        
2587 : a205                     ldx #5
2589 :                  trolc
                                set_ax zps,fc
                       >            load_flag fc
2589 : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
258b : 48              >            pha         ;use stack to load status
258c : b513            >            lda zps,x    ;precharge accu
258e : 28              >            plp
                        
258f : 2a                       rol a
                                tst_ax rROLc,fROLc,0
2590 : 08              >            php         ;save flags
2591 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
2594 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2596 : 68              >            pla         ;load status
                       >            eor_flag 0
2597 : 0908            >            ora #decmode        ;ignore decimal mode bit
2599 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
259b : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
259e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25a0 : ca                       dex
25a1 : 10e6                     bpl trolc
25a3 : a205                     ldx #5
25a5 :                  trolc1
                                set_ax zps,$ff
                       >            load_flag $ff
25a5 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
25a7 : 48              >            pha         ;use stack to load status
25a8 : b513            >            lda zps,x    ;precharge accu
25aa : 28              >            plp
                        
25ab : 2a                       rol a
                                tst_ax rROLc,fROLc,$ff-fnzc
25ac : 08              >            php         ;save flags
25ad : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
25b0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25b2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25b3 : 0908            >            ora #decmode        ;ignore decimal mode bit
25b5 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
25b7 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
25ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25bc : ca                       dex
25bd : 10e6                     bpl trolc1
                        
25bf : a205                     ldx #5
25c1 :                  tror
                                set_ax zps,0
                       >            load_flag 0
25c1 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
25c3 : 48              >            pha         ;use stack to load status
25c4 : b513            >            lda zps,x    ;precharge accu
25c6 : 28              >            plp
                        
25c7 : 6a                       ror a
                                tst_ax rROR,fROR,0
25c8 : 08              >            php         ;save flags
25c9 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
25cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25ce : 68              >            pla         ;load status
                       >            eor_flag 0
25cf : 0908            >            ora #decmode        ;ignore decimal mode bit
25d1 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
25d3 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
25d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25d8 : ca                       dex
25d9 : 10e6                     bpl tror
25db : a205                     ldx #5
25dd :                  tror1
                                set_ax zps,$ff-fc
                       >            load_flag $ff-fc
25dd : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
25df : 48              >            pha         ;use stack to load status
25e0 : b513            >            lda zps,x    ;precharge accu
25e2 : 28              >            plp
                        
25e3 : 6a                       ror a
                                tst_ax rROR,fROR,$ff-fnzc
25e4 : 08              >            php         ;save flags
25e5 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
25e8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25ea : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25eb : 0908            >            ora #decmode        ;ignore decimal mode bit
25ed : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
25ef : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
25f2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25f4 : ca                       dex
25f5 : 10e6                     bpl tror1
                        
25f7 : a205                     ldx #5
25f9 :                  trorc
                                set_ax zps,fc
                       >            load_flag fc
25f9 : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
25fb : 48              >            pha         ;use stack to load status
25fc : b513            >            lda zps,x    ;precharge accu
25fe : 28              >            plp
                        
25ff : 6a                       ror a
                                tst_ax rRORc,fRORc,0
2600 : 08              >            php         ;save flags
2601 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2604 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2606 : 68              >            pla         ;load status
                       >            eor_flag 0
2607 : 0908            >            ora #decmode        ;ignore decimal mode bit
2609 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
260b : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
260e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2610 : ca                       dex
2611 : 10e6                     bpl trorc
2613 : a205                     ldx #5
2615 :                  trorc1
                                set_ax zps,$ff
                       >            load_flag $ff
2615 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2617 : 48              >            pha         ;use stack to load status
2618 : b513            >            lda zps,x    ;precharge accu
261a : 28              >            plp
                        
261b : 6a                       ror a
                                tst_ax rRORc,fRORc,$ff-fnzc
261c : 08              >            php         ;save flags
261d : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2620 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2622 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2623 : 0908            >            ora #decmode        ;ignore decimal mode bit
2625 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2627 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
262a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
262c : ca                       dex
262d : 10e6                     bpl trorc1
                                next_test
262f : ad0002          >            lda test_case   ;previous test
2632 : c91d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2634 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001e =                 >test_num = test_num + 1
2636 : a91e            >            lda #test_num   ;*** next tests' number
2638 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zeropage
263b : a205                     ldx #5
263d :                  tasl2
                                set_z zps,0
                       >            load_flag 0
263d : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
263f : 48              >            pha         ;use stack to load status
2640 : b513            >            lda zps,x    ;load to zeropage
2642 : 850c            >            sta zpt
2644 : 28              >            plp
                        
2645 : 060c                     asl zpt
                                tst_z rASL,fASL,0
2647 : 08              >            php         ;save flags
2648 : a50c            >            lda zpt
264a : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
264d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
264f : 68              >            pla         ;load status
                       >            eor_flag 0
2650 : 0908            >            ora #decmode        ;ignore decimal mode bit
2652 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2654 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2657 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2659 : ca                       dex
265a : 10e1                     bpl tasl2
265c : a205                     ldx #5
265e :                  tasl3
                                set_z zps,$ff
                       >            load_flag $ff
265e : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2660 : 48              >            pha         ;use stack to load status
2661 : b513            >            lda zps,x    ;load to zeropage
2663 : 850c            >            sta zpt
2665 : 28              >            plp
                        
2666 : 060c                     asl zpt
                                tst_z rASL,fASL,$ff-fnzc
2668 : 08              >            php         ;save flags
2669 : a50c            >            lda zpt
266b : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
266e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2670 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2671 : 0908            >            ora #decmode        ;ignore decimal mode bit
2673 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2675 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2678 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
267a : ca                       dex
267b : 10e1                     bpl tasl3
                        
267d : a205                     ldx #5
267f :                  tlsr2
                                set_z zps,0
                       >            load_flag 0
267f : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2681 : 48              >            pha         ;use stack to load status
2682 : b513            >            lda zps,x    ;load to zeropage
2684 : 850c            >            sta zpt
2686 : 28              >            plp
                        
2687 : 460c                     lsr zpt
                                tst_z rLSR,fLSR,0
2689 : 08              >            php         ;save flags
268a : a50c            >            lda zpt
268c : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
268f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2691 : 68              >            pla         ;load status
                       >            eor_flag 0
2692 : 0908            >            ora #decmode        ;ignore decimal mode bit
2694 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2696 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2699 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
269b : ca                       dex
269c : 10e1                     bpl tlsr2
269e : a205                     ldx #5
26a0 :                  tlsr3
                                set_z zps,$ff
                       >            load_flag $ff
26a0 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
26a2 : 48              >            pha         ;use stack to load status
26a3 : b513            >            lda zps,x    ;load to zeropage
26a5 : 850c            >            sta zpt
26a7 : 28              >            plp
                        
26a8 : 460c                     lsr zpt
                                tst_z rLSR,fLSR,$ff-fnzc
26aa : 08              >            php         ;save flags
26ab : a50c            >            lda zpt
26ad : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
26b0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26b2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26b3 : 0908            >            ora #decmode        ;ignore decimal mode bit
26b5 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
26b7 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
26ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26bc : ca                       dex
26bd : 10e1                     bpl tlsr3
                        
26bf : a205                     ldx #5
26c1 :                  trol2
                                set_z zps,0
                       >            load_flag 0
26c1 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
26c3 : 48              >            pha         ;use stack to load status
26c4 : b513            >            lda zps,x    ;load to zeropage
26c6 : 850c            >            sta zpt
26c8 : 28              >            plp
                        
26c9 : 260c                     rol zpt
                                tst_z rROL,fROL,0
26cb : 08              >            php         ;save flags
26cc : a50c            >            lda zpt
26ce : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
26d1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26d3 : 68              >            pla         ;load status
                       >            eor_flag 0
26d4 : 0908            >            ora #decmode        ;ignore decimal mode bit
26d6 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
26d8 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
26db : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26dd : ca                       dex
26de : 10e1                     bpl trol2
26e0 : a205                     ldx #5
26e2 :                  trol3
                                set_z zps,$ff-fc
                       >            load_flag $ff-fc
26e2 : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
26e4 : 48              >            pha         ;use stack to load status
26e5 : b513            >            lda zps,x    ;load to zeropage
26e7 : 850c            >            sta zpt
26e9 : 28              >            plp
                        
26ea : 260c                     rol zpt
                                tst_z rROL,fROL,$ff-fnzc
26ec : 08              >            php         ;save flags
26ed : a50c            >            lda zpt
26ef : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
26f2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26f4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26f5 : 0908            >            ora #decmode        ;ignore decimal mode bit
26f7 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
26f9 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
26fc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26fe : ca                       dex
26ff : 10e1                     bpl trol3
                        
2701 : a205                     ldx #5
2703 :                  trolc2
                                set_z zps,fc
                       >            load_flag fc
2703 : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
2705 : 48              >            pha         ;use stack to load status
2706 : b513            >            lda zps,x    ;load to zeropage
2708 : 850c            >            sta zpt
270a : 28              >            plp
                        
270b : 260c                     rol zpt
                                tst_z rROLc,fROLc,0
270d : 08              >            php         ;save flags
270e : a50c            >            lda zpt
2710 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
2713 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2715 : 68              >            pla         ;load status
                       >            eor_flag 0
2716 : 0908            >            ora #decmode        ;ignore decimal mode bit
2718 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
271a : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
271d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
271f : ca                       dex
2720 : 10e1                     bpl trolc2
2722 : a205                     ldx #5
2724 :                  trolc3
                                set_z zps,$ff
                       >            load_flag $ff
2724 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2726 : 48              >            pha         ;use stack to load status
2727 : b513            >            lda zps,x    ;load to zeropage
2729 : 850c            >            sta zpt
272b : 28              >            plp
                        
272c : 260c                     rol zpt
                                tst_z rROLc,fROLc,$ff-fnzc
272e : 08              >            php         ;save flags
272f : a50c            >            lda zpt
2731 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
2734 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2736 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2737 : 0908            >            ora #decmode        ;ignore decimal mode bit
2739 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
273b : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
273e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2740 : ca                       dex
2741 : 10e1                     bpl trolc3
                        
2743 : a205                     ldx #5
2745 :                  tror2
                                set_z zps,0
                       >            load_flag 0
2745 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2747 : 48              >            pha         ;use stack to load status
2748 : b513            >            lda zps,x    ;load to zeropage
274a : 850c            >            sta zpt
274c : 28              >            plp
                        
274d : 660c                     ror zpt
                                tst_z rROR,fROR,0
274f : 08              >            php         ;save flags
2750 : a50c            >            lda zpt
2752 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2755 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2757 : 68              >            pla         ;load status
                       >            eor_flag 0
2758 : 0908            >            ora #decmode        ;ignore decimal mode bit
275a : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
275c : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
275f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2761 : ca                       dex
2762 : 10e1                     bpl tror2
2764 : a205                     ldx #5
2766 :                  tror3
                                set_z zps,$ff-fc
                       >            load_flag $ff-fc
2766 : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
2768 : 48              >            pha         ;use stack to load status
2769 : b513            >            lda zps,x    ;load to zeropage
276b : 850c            >            sta zpt
276d : 28              >            plp
                        
276e : 660c                     ror zpt
                                tst_z rROR,fROR,$ff-fnzc
2770 : 08              >            php         ;save flags
2771 : a50c            >            lda zpt
2773 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2776 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2778 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2779 : 0908            >            ora #decmode        ;ignore decimal mode bit
277b : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
277d : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
2780 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2782 : ca                       dex
2783 : 10e1                     bpl tror3
                        
2785 : a205                     ldx #5
2787 :                  trorc2
                                set_z zps,fc
                       >            load_flag fc
2787 : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
2789 : 48              >            pha         ;use stack to load status
278a : b513            >            lda zps,x    ;load to zeropage
278c : 850c            >            sta zpt
278e : 28              >            plp
                        
278f : 660c                     ror zpt
                                tst_z rRORc,fRORc,0
2791 : 08              >            php         ;save flags
2792 : a50c            >            lda zpt
2794 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2797 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2799 : 68              >            pla         ;load status
                       >            eor_flag 0
279a : 0908            >            ora #decmode        ;ignore decimal mode bit
279c : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
279e : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
27a1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27a3 : ca                       dex
27a4 : 10e1                     bpl trorc2
27a6 : a205                     ldx #5
27a8 :                  trorc3
                                set_z zps,$ff
                       >            load_flag $ff
27a8 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
27aa : 48              >            pha         ;use stack to load status
27ab : b513            >            lda zps,x    ;load to zeropage
27ad : 850c            >            sta zpt
27af : 28              >            plp
                        
27b0 : 660c                     ror zpt
                                tst_z rRORc,fRORc,$ff-fnzc
27b2 : 08              >            php         ;save flags
27b3 : a50c            >            lda zpt
27b5 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
27b8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27ba : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27bb : 0908            >            ora #decmode        ;ignore decimal mode bit
27bd : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
27bf : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
27c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27c4 : ca                       dex
27c5 : 10e1                     bpl trorc3
                                next_test
27c7 : ad0002          >            lda test_case   ;previous test
27ca : c91e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
27cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001f =                 >test_num = test_num + 1
27ce : a91f            >            lda #test_num   ;*** next tests' number
27d0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - absolute
27d3 : a205                     ldx #5
27d5 :                  tasl4
                                set_abs zps,0
                       >            load_flag 0
27d5 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
27d7 : 48              >            pha         ;use stack to load status
27d8 : b513            >            lda zps,x    ;load to memory
27da : 8d0302          >            sta abst
27dd : 28              >            plp
                        
27de : 0e0302                   asl abst
                                tst_abs rASL,fASL,0
27e1 : 08              >            php         ;save flags
27e2 : ad0302          >            lda abst
27e5 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
27e8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27ea : 68              >            pla         ;load status
                       >            eor_flag 0
27eb : 0908            >            ora #decmode        ;ignore decimal mode bit
27ed : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
27ef : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
27f2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27f4 : ca                       dex
27f5 : 10de                     bpl tasl4
27f7 : a205                     ldx #5
27f9 :                  tasl5
                                set_abs zps,$ff
                       >            load_flag $ff
27f9 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
27fb : 48              >            pha         ;use stack to load status
27fc : b513            >            lda zps,x    ;load to memory
27fe : 8d0302          >            sta abst
2801 : 28              >            plp
                        
2802 : 0e0302                   asl abst
                                tst_abs rASL,fASL,$ff-fnzc
2805 : 08              >            php         ;save flags
2806 : ad0302          >            lda abst
2809 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
280c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
280e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
280f : 0908            >            ora #decmode        ;ignore decimal mode bit
2811 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2813 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2816 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2818 : ca                       dex
2819 : 10de                     bpl tasl5
                        
281b : a205                     ldx #5
281d :                  tlsr4
                                set_abs zps,0
                       >            load_flag 0
281d : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
281f : 48              >            pha         ;use stack to load status
2820 : b513            >            lda zps,x    ;load to memory
2822 : 8d0302          >            sta abst
2825 : 28              >            plp
                        
2826 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,0
2829 : 08              >            php         ;save flags
282a : ad0302          >            lda abst
282d : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
2830 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2832 : 68              >            pla         ;load status
                       >            eor_flag 0
2833 : 0908            >            ora #decmode        ;ignore decimal mode bit
2835 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2837 : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
283a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
283c : ca                       dex
283d : 10de                     bpl tlsr4
283f : a205                     ldx #5
2841 :                  tlsr5
                                set_abs zps,$ff
                       >            load_flag $ff
2841 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2843 : 48              >            pha         ;use stack to load status
2844 : b513            >            lda zps,x    ;load to memory
2846 : 8d0302          >            sta abst
2849 : 28              >            plp
                        
284a : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,$ff-fnzc
284d : 08              >            php         ;save flags
284e : ad0302          >            lda abst
2851 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
2854 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2856 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2857 : 0908            >            ora #decmode        ;ignore decimal mode bit
2859 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
285b : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
285e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2860 : ca                       dex
2861 : 10de                     bpl tlsr5
                        
2863 : a205                     ldx #5
2865 :                  trol4
                                set_abs zps,0
                       >            load_flag 0
2865 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2867 : 48              >            pha         ;use stack to load status
2868 : b513            >            lda zps,x    ;load to memory
286a : 8d0302          >            sta abst
286d : 28              >            plp
                        
286e : 2e0302                   rol abst
                                tst_abs rROL,fROL,0
2871 : 08              >            php         ;save flags
2872 : ad0302          >            lda abst
2875 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2878 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
287a : 68              >            pla         ;load status
                       >            eor_flag 0
287b : 0908            >            ora #decmode        ;ignore decimal mode bit
287d : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
287f : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2882 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2884 : ca                       dex
2885 : 10de                     bpl trol4
2887 : a205                     ldx #5
2889 :                  trol5
                                set_abs zps,$ff-fc
                       >            load_flag $ff-fc
2889 : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
288b : 48              >            pha         ;use stack to load status
288c : b513            >            lda zps,x    ;load to memory
288e : 8d0302          >            sta abst
2891 : 28              >            plp
                        
2892 : 2e0302                   rol abst
                                tst_abs rROL,fROL,$ff-fnzc
2895 : 08              >            php         ;save flags
2896 : ad0302          >            lda abst
2899 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
289c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
289e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
289f : 0908            >            ora #decmode        ;ignore decimal mode bit
28a1 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
28a3 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
28a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28a8 : ca                       dex
28a9 : 10de                     bpl trol5
                        
28ab : a205                     ldx #5
28ad :                  trolc4
                                set_abs zps,fc
                       >            load_flag fc
28ad : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
28af : 48              >            pha         ;use stack to load status
28b0 : b513            >            lda zps,x    ;load to memory
28b2 : 8d0302          >            sta abst
28b5 : 28              >            plp
                        
28b6 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,0
28b9 : 08              >            php         ;save flags
28ba : ad0302          >            lda abst
28bd : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
28c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28c2 : 68              >            pla         ;load status
                       >            eor_flag 0
28c3 : 0908            >            ora #decmode        ;ignore decimal mode bit
28c5 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
28c7 : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
28ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28cc : ca                       dex
28cd : 10de                     bpl trolc4
28cf : a205                     ldx #5
28d1 :                  trolc5
                                set_abs zps,$ff
                       >            load_flag $ff
28d1 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
28d3 : 48              >            pha         ;use stack to load status
28d4 : b513            >            lda zps,x    ;load to memory
28d6 : 8d0302          >            sta abst
28d9 : 28              >            plp
                        
28da : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,$ff-fnzc
28dd : 08              >            php         ;save flags
28de : ad0302          >            lda abst
28e1 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
28e4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28e6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
28e7 : 0908            >            ora #decmode        ;ignore decimal mode bit
28e9 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
28eb : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
28ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28f0 : ca                       dex
28f1 : 10de                     bpl trolc5
                        
28f3 : a205                     ldx #5
28f5 :                  tror4
                                set_abs zps,0
                       >            load_flag 0
28f5 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
28f7 : 48              >            pha         ;use stack to load status
28f8 : b513            >            lda zps,x    ;load to memory
28fa : 8d0302          >            sta abst
28fd : 28              >            plp
                        
28fe : 6e0302                   ror abst
                                tst_abs rROR,fROR,0
2901 : 08              >            php         ;save flags
2902 : ad0302          >            lda abst
2905 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2908 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
290a : 68              >            pla         ;load status
                       >            eor_flag 0
290b : 0908            >            ora #decmode        ;ignore decimal mode bit
290d : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
290f : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
2912 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2914 : ca                       dex
2915 : 10de                     bpl tror4
2917 : a205                     ldx #5
2919 :                  tror5
                                set_abs zps,$ff-fc
                       >            load_flag $ff-fc
2919 : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
291b : 48              >            pha         ;use stack to load status
291c : b513            >            lda zps,x    ;load to memory
291e : 8d0302          >            sta abst
2921 : 28              >            plp
                        
2922 : 6e0302                   ror abst
                                tst_abs rROR,fROR,$ff-fnzc
2925 : 08              >            php         ;save flags
2926 : ad0302          >            lda abst
2929 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
292c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
292e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
292f : 0908            >            ora #decmode        ;ignore decimal mode bit
2931 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2933 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
2936 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2938 : ca                       dex
2939 : 10de                     bpl tror5
                        
293b : a205                     ldx #5
293d :                  trorc4
                                set_abs zps,fc
                       >            load_flag fc
293d : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
293f : 48              >            pha         ;use stack to load status
2940 : b513            >            lda zps,x    ;load to memory
2942 : 8d0302          >            sta abst
2945 : 28              >            plp
                        
2946 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,0
2949 : 08              >            php         ;save flags
294a : ad0302          >            lda abst
294d : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2950 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2952 : 68              >            pla         ;load status
                       >            eor_flag 0
2953 : 0908            >            ora #decmode        ;ignore decimal mode bit
2955 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2957 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
295a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
295c : ca                       dex
295d : 10de                     bpl trorc4
295f : a205                     ldx #5
2961 :                  trorc5
                                set_abs zps,$ff
                       >            load_flag $ff
2961 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2963 : 48              >            pha         ;use stack to load status
2964 : b513            >            lda zps,x    ;load to memory
2966 : 8d0302          >            sta abst
2969 : 28              >            plp
                        
296a : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,$ff-fnzc
296d : 08              >            php         ;save flags
296e : ad0302          >            lda abst
2971 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2974 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2976 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2977 : 0908            >            ora #decmode        ;ignore decimal mode bit
2979 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
297b : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
297e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2980 : ca                       dex
2981 : 10de                     bpl trorc5
                                next_test
2983 : ad0002          >            lda test_case   ;previous test
2986 : c91f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2988 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0020 =                 >test_num = test_num + 1
298a : a920            >            lda #test_num   ;*** next tests' number
298c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zp indexed
298f : a205                     ldx #5
2991 :                  tasl6
                                set_zx zps,0
                       >            load_flag 0
2991 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2993 : 48              >            pha         ;use stack to load status
2994 : b513            >            lda zps,x    ;load to indexed zeropage
2996 : 950c            >            sta zpt,x
2998 : 28              >            plp
                        
2999 : 160c                     asl zpt,x
                                tst_zx rASL,fASL,0
299b : 08              >            php         ;save flags
299c : b50c            >            lda zpt,x
299e : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
29a1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29a3 : 68              >            pla         ;load status
                       >            eor_flag 0
29a4 : 0908            >            ora #decmode        ;ignore decimal mode bit
29a6 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
29a8 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
29ab : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29ad : ca                       dex
29ae : 10e1                     bpl tasl6
29b0 : a205                     ldx #5
29b2 :                  tasl7
                                set_zx zps,$ff
                       >            load_flag $ff
29b2 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
29b4 : 48              >            pha         ;use stack to load status
29b5 : b513            >            lda zps,x    ;load to indexed zeropage
29b7 : 950c            >            sta zpt,x
29b9 : 28              >            plp
                        
29ba : 160c                     asl zpt,x
                                tst_zx rASL,fASL,$ff-fnzc
29bc : 08              >            php         ;save flags
29bd : b50c            >            lda zpt,x
29bf : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
29c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29c4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
29c5 : 0908            >            ora #decmode        ;ignore decimal mode bit
29c7 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
29c9 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
29cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29ce : ca                       dex
29cf : 10e1                     bpl tasl7
                        
29d1 : a205                     ldx #5
29d3 :                  tlsr6
                                set_zx zps,0
                       >            load_flag 0
29d3 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
29d5 : 48              >            pha         ;use stack to load status
29d6 : b513            >            lda zps,x    ;load to indexed zeropage
29d8 : 950c            >            sta zpt,x
29da : 28              >            plp
                        
29db : 560c                     lsr zpt,x
                                tst_zx rLSR,fLSR,0
29dd : 08              >            php         ;save flags
29de : b50c            >            lda zpt,x
29e0 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
29e3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29e5 : 68              >            pla         ;load status
                       >            eor_flag 0
29e6 : 0908            >            ora #decmode        ;ignore decimal mode bit
29e8 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
29ea : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
29ed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29ef : ca                       dex
29f0 : 10e1                     bpl tlsr6
29f2 : a205                     ldx #5
29f4 :                  tlsr7
                                set_zx zps,$ff
                       >            load_flag $ff
29f4 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
29f6 : 48              >            pha         ;use stack to load status
29f7 : b513            >            lda zps,x    ;load to indexed zeropage
29f9 : 950c            >            sta zpt,x
29fb : 28              >            plp
                        
29fc : 560c                     lsr zpt,x
                                tst_zx rLSR,fLSR,$ff-fnzc
29fe : 08              >            php         ;save flags
29ff : b50c            >            lda zpt,x
2a01 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
2a04 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a06 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2a07 : 0908            >            ora #decmode        ;ignore decimal mode bit
2a09 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2a0b : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2a0e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a10 : ca                       dex
2a11 : 10e1                     bpl tlsr7
                        
2a13 : a205                     ldx #5
2a15 :                  trol6
                                set_zx zps,0
                       >            load_flag 0
2a15 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2a17 : 48              >            pha         ;use stack to load status
2a18 : b513            >            lda zps,x    ;load to indexed zeropage
2a1a : 950c            >            sta zpt,x
2a1c : 28              >            plp
                        
2a1d : 360c                     rol zpt,x
                                tst_zx rROL,fROL,0
2a1f : 08              >            php         ;save flags
2a20 : b50c            >            lda zpt,x
2a22 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2a25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a27 : 68              >            pla         ;load status
                       >            eor_flag 0
2a28 : 0908            >            ora #decmode        ;ignore decimal mode bit
2a2a : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2a2c : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2a2f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a31 : ca                       dex
2a32 : 10e1                     bpl trol6
2a34 : a205                     ldx #5
2a36 :                  trol7
                                set_zx zps,$ff-fc
                       >            load_flag $ff-fc
2a36 : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
2a38 : 48              >            pha         ;use stack to load status
2a39 : b513            >            lda zps,x    ;load to indexed zeropage
2a3b : 950c            >            sta zpt,x
2a3d : 28              >            plp
                        
2a3e : 360c                     rol zpt,x
                                tst_zx rROL,fROL,$ff-fnzc
2a40 : 08              >            php         ;save flags
2a41 : b50c            >            lda zpt,x
2a43 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2a46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a48 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2a49 : 0908            >            ora #decmode        ;ignore decimal mode bit
2a4b : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2a4d : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2a50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a52 : ca                       dex
2a53 : 10e1                     bpl trol7
                        
2a55 : a205                     ldx #5
2a57 :                  trolc6
                                set_zx zps,fc
                       >            load_flag fc
2a57 : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
2a59 : 48              >            pha         ;use stack to load status
2a5a : b513            >            lda zps,x    ;load to indexed zeropage
2a5c : 950c            >            sta zpt,x
2a5e : 28              >            plp
                        
2a5f : 360c                     rol zpt,x
                                tst_zx rROLc,fROLc,0
2a61 : 08              >            php         ;save flags
2a62 : b50c            >            lda zpt,x
2a64 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
2a67 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a69 : 68              >            pla         ;load status
                       >            eor_flag 0
2a6a : 0908            >            ora #decmode        ;ignore decimal mode bit
2a6c : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2a6e : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2a71 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a73 : ca                       dex
2a74 : 10e1                     bpl trolc6
2a76 : a205                     ldx #5
2a78 :                  trolc7
                                set_zx zps,$ff
                       >            load_flag $ff
2a78 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2a7a : 48              >            pha         ;use stack to load status
2a7b : b513            >            lda zps,x    ;load to indexed zeropage
2a7d : 950c            >            sta zpt,x
2a7f : 28              >            plp
                        
2a80 : 360c                     rol zpt,x
                                tst_zx rROLc,fROLc,$ff-fnzc
2a82 : 08              >            php         ;save flags
2a83 : b50c            >            lda zpt,x
2a85 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
2a88 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a8a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2a8b : 0908            >            ora #decmode        ;ignore decimal mode bit
2a8d : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2a8f : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2a92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a94 : ca                       dex
2a95 : 10e1                     bpl trolc7
                        
2a97 : a205                     ldx #5
2a99 :                  tror6
                                set_zx zps,0
                       >            load_flag 0
2a99 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2a9b : 48              >            pha         ;use stack to load status
2a9c : b513            >            lda zps,x    ;load to indexed zeropage
2a9e : 950c            >            sta zpt,x
2aa0 : 28              >            plp
                        
2aa1 : 760c                     ror zpt,x
                                tst_zx rROR,fROR,0
2aa3 : 08              >            php         ;save flags
2aa4 : b50c            >            lda zpt,x
2aa6 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2aa9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2aab : 68              >            pla         ;load status
                       >            eor_flag 0
2aac : 0908            >            ora #decmode        ;ignore decimal mode bit
2aae : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2ab0 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
2ab3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ab5 : ca                       dex
2ab6 : 10e1                     bpl tror6
2ab8 : a205                     ldx #5
2aba :                  tror7
                                set_zx zps,$ff-fc
                       >            load_flag $ff-fc
2aba : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
2abc : 48              >            pha         ;use stack to load status
2abd : b513            >            lda zps,x    ;load to indexed zeropage
2abf : 950c            >            sta zpt,x
2ac1 : 28              >            plp
                        
2ac2 : 760c                     ror zpt,x
                                tst_zx rROR,fROR,$ff-fnzc
2ac4 : 08              >            php         ;save flags
2ac5 : b50c            >            lda zpt,x
2ac7 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2aca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2acc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2acd : 0908            >            ora #decmode        ;ignore decimal mode bit
2acf : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2ad1 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
2ad4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ad6 : ca                       dex
2ad7 : 10e1                     bpl tror7
                        
2ad9 : a205                     ldx #5
2adb :                  trorc6
                                set_zx zps,fc
                       >            load_flag fc
2adb : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
2add : 48              >            pha         ;use stack to load status
2ade : b513            >            lda zps,x    ;load to indexed zeropage
2ae0 : 950c            >            sta zpt,x
2ae2 : 28              >            plp
                        
2ae3 : 760c                     ror zpt,x
                                tst_zx rRORc,fRORc,0
2ae5 : 08              >            php         ;save flags
2ae6 : b50c            >            lda zpt,x
2ae8 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2aeb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2aed : 68              >            pla         ;load status
                       >            eor_flag 0
2aee : 0908            >            ora #decmode        ;ignore decimal mode bit
2af0 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2af2 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2af5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2af7 : ca                       dex
2af8 : 10e1                     bpl trorc6
2afa : a205                     ldx #5
2afc :                  trorc7
                                set_zx zps,$ff
                       >            load_flag $ff
2afc : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2afe : 48              >            pha         ;use stack to load status
2aff : b513            >            lda zps,x    ;load to indexed zeropage
2b01 : 950c            >            sta zpt,x
2b03 : 28              >            plp
                        
2b04 : 760c                     ror zpt,x
                                tst_zx rRORc,fRORc,$ff-fnzc
2b06 : 08              >            php         ;save flags
2b07 : b50c            >            lda zpt,x
2b09 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2b0c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b0e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2b0f : 0908            >            ora #decmode        ;ignore decimal mode bit
2b11 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2b13 : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2b16 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b18 : ca                       dex
2b19 : 10e1                     bpl trorc7
                                next_test
2b1b : ad0002          >            lda test_case   ;previous test
2b1e : c920            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2b20 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0021 =                 >test_num = test_num + 1
2b22 : a921            >            lda #test_num   ;*** next tests' number
2b24 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; shifts - abs indexed
2b27 : a205                     ldx #5
2b29 :                  tasl8
                                set_absx zps,0
                       >            load_flag 0
2b29 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2b2b : 48              >            pha         ;use stack to load status
2b2c : b513            >            lda zps,x    ;load to indexed memory
2b2e : 9d0302          >            sta abst,x
2b31 : 28              >            plp
                        
2b32 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,0
2b35 : 08              >            php         ;save flags
2b36 : bd0302          >            lda abst,x
2b39 : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
2b3c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b3e : 68              >            pla         ;load status
                       >            eor_flag 0
2b3f : 0908            >            ora #decmode        ;ignore decimal mode bit
2b41 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2b43 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2b46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b48 : ca                       dex
2b49 : 10de                     bpl tasl8
2b4b : a205                     ldx #5
2b4d :                  tasl9
                                set_absx zps,$ff
                       >            load_flag $ff
2b4d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2b4f : 48              >            pha         ;use stack to load status
2b50 : b513            >            lda zps,x    ;load to indexed memory
2b52 : 9d0302          >            sta abst,x
2b55 : 28              >            plp
                        
2b56 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,$ff-fnzc
2b59 : 08              >            php         ;save flags
2b5a : bd0302          >            lda abst,x
2b5d : dd2102          >            cmp rASL,x    ;test result
                       >            trap_ne
2b60 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b62 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2b63 : 0908            >            ora #decmode        ;ignore decimal mode bit
2b65 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2b67 : dd3902          >            cmp fASL,x    ;test flags
                       >            trap_ne
2b6a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b6c : ca                       dex
2b6d : 10de                     bpl tasl9
                        
2b6f : a205                     ldx #5
2b71 :                  tlsr8
                                set_absx zps,0
                       >            load_flag 0
2b71 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2b73 : 48              >            pha         ;use stack to load status
2b74 : b513            >            lda zps,x    ;load to indexed memory
2b76 : 9d0302          >            sta abst,x
2b79 : 28              >            plp
                        
2b7a : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,0
2b7d : 08              >            php         ;save flags
2b7e : bd0302          >            lda abst,x
2b81 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
2b84 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b86 : 68              >            pla         ;load status
                       >            eor_flag 0
2b87 : 0908            >            ora #decmode        ;ignore decimal mode bit
2b89 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2b8b : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2b8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b90 : ca                       dex
2b91 : 10de                     bpl tlsr8
2b93 : a205                     ldx #5
2b95 :                  tlsr9
                                set_absx zps,$ff
                       >            load_flag $ff
2b95 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2b97 : 48              >            pha         ;use stack to load status
2b98 : b513            >            lda zps,x    ;load to indexed memory
2b9a : 9d0302          >            sta abst,x
2b9d : 28              >            plp
                        
2b9e : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,$ff-fnzc
2ba1 : 08              >            php         ;save flags
2ba2 : bd0302          >            lda abst,x
2ba5 : dd2d02          >            cmp rLSR,x    ;test result
                       >            trap_ne
2ba8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2baa : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2bab : 0908            >            ora #decmode        ;ignore decimal mode bit
2bad : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2baf : dd4502          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2bb2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bb4 : ca                       dex
2bb5 : 10de                     bpl tlsr9
                        
2bb7 : a205                     ldx #5
2bb9 :                  trol8
                                set_absx zps,0
                       >            load_flag 0
2bb9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2bbb : 48              >            pha         ;use stack to load status
2bbc : b513            >            lda zps,x    ;load to indexed memory
2bbe : 9d0302          >            sta abst,x
2bc1 : 28              >            plp
                        
2bc2 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,0
2bc5 : 08              >            php         ;save flags
2bc6 : bd0302          >            lda abst,x
2bc9 : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2bcc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bce : 68              >            pla         ;load status
                       >            eor_flag 0
2bcf : 0908            >            ora #decmode        ;ignore decimal mode bit
2bd1 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2bd3 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2bd6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bd8 : ca                       dex
2bd9 : 10de                     bpl trol8
2bdb : a205                     ldx #5
2bdd :                  trol9
                                set_absx zps,$ff-fc
                       >            load_flag $ff-fc
2bdd : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
2bdf : 48              >            pha         ;use stack to load status
2be0 : b513            >            lda zps,x    ;load to indexed memory
2be2 : 9d0302          >            sta abst,x
2be5 : 28              >            plp
                        
2be6 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,$ff-fnzc
2be9 : 08              >            php         ;save flags
2bea : bd0302          >            lda abst,x
2bed : dd2102          >            cmp rROL,x    ;test result
                       >            trap_ne
2bf0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bf2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2bf3 : 0908            >            ora #decmode        ;ignore decimal mode bit
2bf5 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2bf7 : dd3902          >            cmp fROL,x    ;test flags
                       >            trap_ne
2bfa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bfc : ca                       dex
2bfd : 10de                     bpl trol9
                        
2bff : a205                     ldx #5
2c01 :                  trolc8
                                set_absx zps,fc
                       >            load_flag fc
2c01 : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
2c03 : 48              >            pha         ;use stack to load status
2c04 : b513            >            lda zps,x    ;load to indexed memory
2c06 : 9d0302          >            sta abst,x
2c09 : 28              >            plp
                        
2c0a : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,0
2c0d : 08              >            php         ;save flags
2c0e : bd0302          >            lda abst,x
2c11 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
2c14 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c16 : 68              >            pla         ;load status
                       >            eor_flag 0
2c17 : 0908            >            ora #decmode        ;ignore decimal mode bit
2c19 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2c1b : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2c1e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c20 : ca                       dex
2c21 : 10de                     bpl trolc8
2c23 : a205                     ldx #5
2c25 :                  trolc9
                                set_absx zps,$ff
                       >            load_flag $ff
2c25 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2c27 : 48              >            pha         ;use stack to load status
2c28 : b513            >            lda zps,x    ;load to indexed memory
2c2a : 9d0302          >            sta abst,x
2c2d : 28              >            plp
                        
2c2e : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,$ff-fnzc
2c31 : 08              >            php         ;save flags
2c32 : bd0302          >            lda abst,x
2c35 : dd2702          >            cmp rROLc,x    ;test result
                       >            trap_ne
2c38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c3a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2c3b : 0908            >            ora #decmode        ;ignore decimal mode bit
2c3d : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2c3f : dd3f02          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2c42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c44 : ca                       dex
2c45 : 10de                     bpl trolc9
                        
2c47 : a205                     ldx #5
2c49 :                  tror8
                                set_absx zps,0
                       >            load_flag 0
2c49 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2c4b : 48              >            pha         ;use stack to load status
2c4c : b513            >            lda zps,x    ;load to indexed memory
2c4e : 9d0302          >            sta abst,x
2c51 : 28              >            plp
                        
2c52 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,0
2c55 : 08              >            php         ;save flags
2c56 : bd0302          >            lda abst,x
2c59 : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2c5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c5e : 68              >            pla         ;load status
                       >            eor_flag 0
2c5f : 0908            >            ora #decmode        ;ignore decimal mode bit
2c61 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2c63 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
2c66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c68 : ca                       dex
2c69 : 10de                     bpl tror8
2c6b : a205                     ldx #5
2c6d :                  tror9
                                set_absx zps,$ff-fc
                       >            load_flag $ff-fc
2c6d : a9fa            >            lda #$ff-fc&m8i         ;force enable interrupts (mask I)
                       >
2c6f : 48              >            pha         ;use stack to load status
2c70 : b513            >            lda zps,x    ;load to indexed memory
2c72 : 9d0302          >            sta abst,x
2c75 : 28              >            plp
                        
2c76 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,$ff-fnzc
2c79 : 08              >            php         ;save flags
2c7a : bd0302          >            lda abst,x
2c7d : dd2d02          >            cmp rROR,x    ;test result
                       >            trap_ne
2c80 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c82 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2c83 : 0908            >            ora #decmode        ;ignore decimal mode bit
2c85 : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2c87 : dd4502          >            cmp fROR,x    ;test flags
                       >            trap_ne
2c8a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c8c : ca                       dex
2c8d : 10de                     bpl tror9
                        
2c8f : a205                     ldx #5
2c91 :                  trorc8
                                set_absx zps,fc
                       >            load_flag fc
2c91 : a901            >            lda #fc&m8i         ;force enable interrupts (mask I)
                       >
2c93 : 48              >            pha         ;use stack to load status
2c94 : b513            >            lda zps,x    ;load to indexed memory
2c96 : 9d0302          >            sta abst,x
2c99 : 28              >            plp
                        
2c9a : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,0
2c9d : 08              >            php         ;save flags
2c9e : bd0302          >            lda abst,x
2ca1 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2ca4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ca6 : 68              >            pla         ;load status
                       >            eor_flag 0
2ca7 : 0908            >            ora #decmode        ;ignore decimal mode bit
2ca9 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2cab : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2cae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cb0 : ca                       dex
2cb1 : 10de                     bpl trorc8
2cb3 : a205                     ldx #5
2cb5 :                  trorc9
                                set_absx zps,$ff
                       >            load_flag $ff
2cb5 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2cb7 : 48              >            pha         ;use stack to load status
2cb8 : b513            >            lda zps,x    ;load to indexed memory
2cba : 9d0302          >            sta abst,x
2cbd : 28              >            plp
                        
2cbe : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,$ff-fnzc
2cc1 : 08              >            php         ;save flags
2cc2 : bd0302          >            lda abst,x
2cc5 : dd3302          >            cmp rRORc,x    ;test result
                       >            trap_ne
2cc8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cca : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2ccb : 0908            >            ora #decmode        ;ignore decimal mode bit
2ccd : 4978            >            eor #($ff-fnzc&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2ccf : dd4b02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2cd2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cd4 : ca                       dex
2cd5 : 10de                     bpl trorc9
                                next_test
2cd7 : ad0002          >            lda test_case   ;previous test
2cda : c921            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2cdc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0022 =                 >test_num = test_num + 1
2cde : a922            >            lda #test_num   ;*** next tests' number
2ce0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing memory increment/decrement - INC DEC all addressing modes
                        ; zeropage
2ce3 : a200                     ldx #0
2ce5 : a97e                     lda #$7e
2ce7 : 850c                     sta zpt
2ce9 :                  tinc    
                                set_stat 0
                       >            load_flag 0
2ce9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2ceb : 48              >            pha         ;use stack to load status
2cec : 28              >            plp
                        
2ced : e60c                     inc zpt
                                tst_z rINC,fINC,0
2cef : 08              >            php         ;save flags
2cf0 : a50c            >            lda zpt
2cf2 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2cf5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cf7 : 68              >            pla         ;load status
                       >            eor_flag 0
2cf8 : 0908            >            ora #decmode        ;ignore decimal mode bit
2cfa : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2cfc : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2cff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d01 : e8                       inx
2d02 : e002                     cpx #2
2d04 : d004                     bne tinc1
2d06 : a9fe                     lda #$fe
2d08 : 850c                     sta zpt
2d0a : e005             tinc1   cpx #5
2d0c : d0db                     bne tinc
2d0e : ca                       dex
2d0f : e60c                     inc zpt
2d11 :                  tdec    
                                set_stat 0
                       >            load_flag 0
2d11 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2d13 : 48              >            pha         ;use stack to load status
2d14 : 28              >            plp
                        
2d15 : c60c                     dec zpt
                                tst_z rINC,fINC,0
2d17 : 08              >            php         ;save flags
2d18 : a50c            >            lda zpt
2d1a : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2d1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d1f : 68              >            pla         ;load status
                       >            eor_flag 0
2d20 : 0908            >            ora #decmode        ;ignore decimal mode bit
2d22 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2d24 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2d27 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d29 : ca                       dex
2d2a : 300a                     bmi tdec1
2d2c : e001                     cpx #1
2d2e : d0e1                     bne tdec
2d30 : a981                     lda #$81
2d32 : 850c                     sta zpt
2d34 : d0db                     bne tdec
2d36 :                  tdec1
2d36 : a200                     ldx #0
2d38 : a97e                     lda #$7e
2d3a : 850c                     sta zpt
2d3c :                  tinc10    
                                set_stat $ff
                       >            load_flag $ff
2d3c : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2d3e : 48              >            pha         ;use stack to load status
2d3f : 28              >            plp
                        
2d40 : e60c                     inc zpt
                                tst_z rINC,fINC,$ff-fnz
2d42 : 08              >            php         ;save flags
2d43 : a50c            >            lda zpt
2d45 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2d48 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d4a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d4b : 0908            >            ora #decmode        ;ignore decimal mode bit
2d4d : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2d4f : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2d52 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d54 : e8                       inx
2d55 : e002                     cpx #2
2d57 : d004                     bne tinc11
2d59 : a9fe                     lda #$fe
2d5b : 850c                     sta zpt
2d5d : e005             tinc11  cpx #5
2d5f : d0db                     bne tinc10
2d61 : ca                       dex
2d62 : e60c                     inc zpt
2d64 :                  tdec10    
                                set_stat $ff
                       >            load_flag $ff
2d64 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2d66 : 48              >            pha         ;use stack to load status
2d67 : 28              >            plp
                        
2d68 : c60c                     dec zpt
                                tst_z rINC,fINC,$ff-fnz
2d6a : 08              >            php         ;save flags
2d6b : a50c            >            lda zpt
2d6d : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2d70 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d72 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d73 : 0908            >            ora #decmode        ;ignore decimal mode bit
2d75 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2d77 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2d7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d7c : ca                       dex
2d7d : 300a                     bmi tdec11
2d7f : e001                     cpx #1
2d81 : d0e1                     bne tdec10
2d83 : a981                     lda #$81
2d85 : 850c                     sta zpt
2d87 : d0db                     bne tdec10
2d89 :                  tdec11
                                next_test
2d89 : ad0002          >            lda test_case   ;previous test
2d8c : c922            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2d8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0023 =                 >test_num = test_num + 1
2d90 : a923            >            lda #test_num   ;*** next tests' number
2d92 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; absolute memory
2d95 : a200                     ldx #0
2d97 : a97e                     lda #$7e
2d99 : 8d0302                   sta abst
2d9c :                  tinc2    
                                set_stat 0
                       >            load_flag 0
2d9c : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2d9e : 48              >            pha         ;use stack to load status
2d9f : 28              >            plp
                        
2da0 : ee0302                   inc abst
                                tst_abs rINC,fINC,0
2da3 : 08              >            php         ;save flags
2da4 : ad0302          >            lda abst
2da7 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2daa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dac : 68              >            pla         ;load status
                       >            eor_flag 0
2dad : 0908            >            ora #decmode        ;ignore decimal mode bit
2daf : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2db1 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2db4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2db6 : e8                       inx
2db7 : e002                     cpx #2
2db9 : d005                     bne tinc3
2dbb : a9fe                     lda #$fe
2dbd : 8d0302                   sta abst
2dc0 : e005             tinc3   cpx #5
2dc2 : d0d8                     bne tinc2
2dc4 : ca                       dex
2dc5 : ee0302                   inc abst
2dc8 :                  tdec2    
                                set_stat 0
                       >            load_flag 0
2dc8 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2dca : 48              >            pha         ;use stack to load status
2dcb : 28              >            plp
                        
2dcc : ce0302                   dec abst
                                tst_abs rINC,fINC,0
2dcf : 08              >            php         ;save flags
2dd0 : ad0302          >            lda abst
2dd3 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2dd6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dd8 : 68              >            pla         ;load status
                       >            eor_flag 0
2dd9 : 0908            >            ora #decmode        ;ignore decimal mode bit
2ddb : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2ddd : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2de0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2de2 : ca                       dex
2de3 : 300b                     bmi tdec3
2de5 : e001                     cpx #1
2de7 : d0df                     bne tdec2
2de9 : a981                     lda #$81
2deb : 8d0302                   sta abst
2dee : d0d8                     bne tdec2
2df0 :                  tdec3
2df0 : a200                     ldx #0
2df2 : a97e                     lda #$7e
2df4 : 8d0302                   sta abst
2df7 :                  tinc12    
                                set_stat $ff
                       >            load_flag $ff
2df7 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2df9 : 48              >            pha         ;use stack to load status
2dfa : 28              >            plp
                        
2dfb : ee0302                   inc abst
                                tst_abs rINC,fINC,$ff-fnz
2dfe : 08              >            php         ;save flags
2dff : ad0302          >            lda abst
2e02 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2e05 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e07 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e08 : 0908            >            ora #decmode        ;ignore decimal mode bit
2e0a : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2e0c : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2e0f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e11 : e8                       inx
2e12 : e002                     cpx #2
2e14 : d005                     bne tinc13
2e16 : a9fe                     lda #$fe
2e18 : 8d0302                   sta abst
2e1b : e005             tinc13   cpx #5
2e1d : d0d8                     bne tinc12
2e1f : ca                       dex
2e20 : ee0302                   inc abst
2e23 :                  tdec12    
                                set_stat $ff
                       >            load_flag $ff
2e23 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2e25 : 48              >            pha         ;use stack to load status
2e26 : 28              >            plp
                        
2e27 : ce0302                   dec abst
                                tst_abs rINC,fINC,$ff-fnz
2e2a : 08              >            php         ;save flags
2e2b : ad0302          >            lda abst
2e2e : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2e31 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e33 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e34 : 0908            >            ora #decmode        ;ignore decimal mode bit
2e36 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2e38 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2e3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e3d : ca                       dex
2e3e : 300b                     bmi tdec13
2e40 : e001                     cpx #1
2e42 : d0df                     bne tdec12
2e44 : a981                     lda #$81
2e46 : 8d0302                   sta abst
2e49 : d0d8                     bne tdec12
2e4b :                  tdec13
                                next_test
2e4b : ad0002          >            lda test_case   ;previous test
2e4e : c923            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2e50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0024 =                 >test_num = test_num + 1
2e52 : a924            >            lda #test_num   ;*** next tests' number
2e54 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; zeropage indexed
2e57 : a200                     ldx #0
2e59 : a97e                     lda #$7e
2e5b : 950c             tinc4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
2e5d : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2e5f : 48              >            pha         ;use stack to load status
2e60 : 28              >            plp
                        
2e61 : f60c                     inc zpt,x
                                tst_zx rINC,fINC,0
2e63 : 08              >            php         ;save flags
2e64 : b50c            >            lda zpt,x
2e66 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2e69 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e6b : 68              >            pla         ;load status
                       >            eor_flag 0
2e6c : 0908            >            ora #decmode        ;ignore decimal mode bit
2e6e : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2e70 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2e73 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e75 : b50c                     lda zpt,x
2e77 : e8                       inx
2e78 : e002                     cpx #2
2e7a : d002                     bne tinc5
2e7c : a9fe                     lda #$fe
2e7e : e005             tinc5   cpx #5
2e80 : d0d9                     bne tinc4
2e82 : ca                       dex
2e83 : a902                     lda #2
2e85 : 950c             tdec4   sta zpt,x 
                                set_stat 0
                       >            load_flag 0
2e87 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2e89 : 48              >            pha         ;use stack to load status
2e8a : 28              >            plp
                        
2e8b : d60c                     dec zpt,x
                                tst_zx rINC,fINC,0
2e8d : 08              >            php         ;save flags
2e8e : b50c            >            lda zpt,x
2e90 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2e93 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e95 : 68              >            pla         ;load status
                       >            eor_flag 0
2e96 : 0908            >            ora #decmode        ;ignore decimal mode bit
2e98 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2e9a : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2e9d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e9f : b50c                     lda zpt,x
2ea1 : ca                       dex
2ea2 : 3008                     bmi tdec5
2ea4 : e001                     cpx #1
2ea6 : d0dd                     bne tdec4
2ea8 : a981                     lda #$81
2eaa : d0d9                     bne tdec4
2eac :                  tdec5
2eac : a200                     ldx #0
2eae : a97e                     lda #$7e
2eb0 : 950c             tinc14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
2eb2 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2eb4 : 48              >            pha         ;use stack to load status
2eb5 : 28              >            plp
                        
2eb6 : f60c                     inc zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2eb8 : 08              >            php         ;save flags
2eb9 : b50c            >            lda zpt,x
2ebb : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2ebe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ec0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ec1 : 0908            >            ora #decmode        ;ignore decimal mode bit
2ec3 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2ec5 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ec8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2eca : b50c                     lda zpt,x
2ecc : e8                       inx
2ecd : e002                     cpx #2
2ecf : d002                     bne tinc15
2ed1 : a9fe                     lda #$fe
2ed3 : e005             tinc15  cpx #5
2ed5 : d0d9                     bne tinc14
2ed7 : ca                       dex
2ed8 : a902                     lda #2
2eda : 950c             tdec14  sta zpt,x 
                                set_stat $ff
                       >            load_flag $ff
2edc : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2ede : 48              >            pha         ;use stack to load status
2edf : 28              >            plp
                        
2ee0 : d60c                     dec zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2ee2 : 08              >            php         ;save flags
2ee3 : b50c            >            lda zpt,x
2ee5 : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2ee8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2eea : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2eeb : 0908            >            ora #decmode        ;ignore decimal mode bit
2eed : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2eef : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ef2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ef4 : b50c                     lda zpt,x
2ef6 : ca                       dex
2ef7 : 3008                     bmi tdec15
2ef9 : e001                     cpx #1
2efb : d0dd                     bne tdec14
2efd : a981                     lda #$81
2eff : d0d9                     bne tdec14
2f01 :                  tdec15
                                next_test
2f01 : ad0002          >            lda test_case   ;previous test
2f04 : c924            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2f06 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0025 =                 >test_num = test_num + 1
2f08 : a925            >            lda #test_num   ;*** next tests' number
2f0a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; memory indexed
2f0d : a200                     ldx #0
2f0f : a97e                     lda #$7e
2f11 : 9d0302           tinc6   sta abst,x
                                set_stat 0
                       >            load_flag 0
2f14 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2f16 : 48              >            pha         ;use stack to load status
2f17 : 28              >            plp
                        
2f18 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,0
2f1b : 08              >            php         ;save flags
2f1c : bd0302          >            lda abst,x
2f1f : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2f22 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f24 : 68              >            pla         ;load status
                       >            eor_flag 0
2f25 : 0908            >            ora #decmode        ;ignore decimal mode bit
2f27 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2f29 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2f2c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f2e : bd0302                   lda abst,x
2f31 : e8                       inx
2f32 : e002                     cpx #2
2f34 : d002                     bne tinc7
2f36 : a9fe                     lda #$fe
2f38 : e005             tinc7   cpx #5
2f3a : d0d5                     bne tinc6
2f3c : ca                       dex
2f3d : a902                     lda #2
2f3f : 9d0302           tdec6   sta abst,x 
                                set_stat 0
                       >            load_flag 0
2f42 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2f44 : 48              >            pha         ;use stack to load status
2f45 : 28              >            plp
                        
2f46 : de0302                   dec abst,x
                                tst_absx rINC,fINC,0
2f49 : 08              >            php         ;save flags
2f4a : bd0302          >            lda abst,x
2f4d : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2f50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f52 : 68              >            pla         ;load status
                       >            eor_flag 0
2f53 : 0908            >            ora #decmode        ;ignore decimal mode bit
2f55 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2f57 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2f5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f5c : bd0302                   lda abst,x
2f5f : ca                       dex
2f60 : 3008                     bmi tdec7
2f62 : e001                     cpx #1
2f64 : d0d9                     bne tdec6
2f66 : a981                     lda #$81
2f68 : d0d5                     bne tdec6
2f6a :                  tdec7
2f6a : a200                     ldx #0
2f6c : a97e                     lda #$7e
2f6e : 9d0302           tinc16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
2f71 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2f73 : 48              >            pha         ;use stack to load status
2f74 : 28              >            plp
                        
2f75 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,$ff-fnz
2f78 : 08              >            php         ;save flags
2f79 : bd0302          >            lda abst,x
2f7c : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2f7f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f81 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f82 : 0908            >            ora #decmode        ;ignore decimal mode bit
2f84 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2f86 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2f89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f8b : bd0302                   lda abst,x
2f8e : e8                       inx
2f8f : e002                     cpx #2
2f91 : d002                     bne tinc17
2f93 : a9fe                     lda #$fe
2f95 : e005             tinc17  cpx #5
2f97 : d0d5                     bne tinc16
2f99 : ca                       dex
2f9a : a902                     lda #2
2f9c : 9d0302           tdec16  sta abst,x 
                                set_stat $ff
                       >            load_flag $ff
2f9f : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
2fa1 : 48              >            pha         ;use stack to load status
2fa2 : 28              >            plp
                        
2fa3 : de0302                   dec abst,x
                                tst_absx rINC,fINC,$ff-fnz
2fa6 : 08              >            php         ;save flags
2fa7 : bd0302          >            lda abst,x
2faa : dd5102          >            cmp rINC,x    ;test result
                       >            trap_ne
2fad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2faf : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2fb0 : 0908            >            ora #decmode        ;ignore decimal mode bit
2fb2 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2fb4 : dd5602          >            cmp fINC,x    ;test flags
                       >            trap_ne
2fb7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fb9 : bd0302                   lda abst,x
2fbc : ca                       dex
2fbd : 3008                     bmi tdec17
2fbf : e001                     cpx #1
2fc1 : d0d9                     bne tdec16
2fc3 : a981                     lda #$81
2fc5 : d0d5                     bne tdec16
2fc7 :                  tdec17
                                next_test
2fc7 : ad0002          >            lda test_case   ;previous test
2fca : c925            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2fcc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0026 =                 >test_num = test_num + 1
2fce : a926            >            lda #test_num   ;*** next tests' number
2fd0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA all addressing modes
                        ; AND
2fd3 : a203                     ldx #3          ;immediate
2fd5 : b51e             tand    lda zpAN,x
2fd7 : 8d0a02                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,0
                       >            load_flag 0
2fda : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
2fdc : 48              >            pha         ;use stack to load status
2fdd : bd6b02          >            lda absANa,x    ;precharge accu
2fe0 : 28              >            plp
                        
2fe1 : 200902                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,0
2fe4 : 08              >            php         ;save flags
2fe5 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fe8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fea : 68              >            pla         ;load status
                       >            eor_flag 0
2feb : 0908            >            ora #decmode        ;ignore decimal mode bit
2fed : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
2fef : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ff2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ff4 : ca                       dex
2ff5 : 10de                     bpl tand
2ff7 : a203                     ldx #3
2ff9 : b51e             tand1   lda zpAN,x
2ffb : 8d0a02                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,$ff
                       >            load_flag $ff
2ffe : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3000 : 48              >            pha         ;use stack to load status
3001 : bd6b02          >            lda absANa,x    ;precharge accu
3004 : 28              >            plp
                        
3005 : 200902                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
3008 : 08              >            php         ;save flags
3009 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
300c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
300e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
300f : 0908            >            ora #decmode        ;ignore decimal mode bit
3011 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3013 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3016 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3018 : ca                       dex
3019 : 10de                     bpl tand1
                            
301b : a203                     ldx #3      ;zp
301d : b51e             tand2   lda zpAN,x
301f : 850c                     sta zpt
                                set_ax  absANa,0
                       >            load_flag 0
3021 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
3023 : 48              >            pha         ;use stack to load status
3024 : bd6b02          >            lda absANa,x    ;precharge accu
3027 : 28              >            plp
                        
3028 : 250c                     and zpt
                                tst_ax  absrlo,absflo,0
302a : 08              >            php         ;save flags
302b : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
302e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3030 : 68              >            pla         ;load status
                       >            eor_flag 0
3031 : 0908            >            ora #decmode        ;ignore decimal mode bit
3033 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3035 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3038 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
303a : ca                       dex
303b : 10e0                     bpl tand2
303d : a203                     ldx #3
303f : b51e             tand3   lda zpAN,x
3041 : 850c                     sta zpt
                                set_ax  absANa,$ff
                       >            load_flag $ff
3043 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3045 : 48              >            pha         ;use stack to load status
3046 : bd6b02          >            lda absANa,x    ;precharge accu
3049 : 28              >            plp
                        
304a : 250c                     and zpt
                                tst_ax  absrlo,absflo,$ff-fnz
304c : 08              >            php         ;save flags
304d : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3050 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3052 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3053 : 0908            >            ora #decmode        ;ignore decimal mode bit
3055 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3057 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
305a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
305c : ca                       dex
305d : 10e0                     bpl tand3
                        
305f : a203                     ldx #3      ;abs
3061 : b51e             tand4   lda zpAN,x
3063 : 8d0302                   sta abst
                                set_ax  absANa,0
                       >            load_flag 0
3066 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
3068 : 48              >            pha         ;use stack to load status
3069 : bd6b02          >            lda absANa,x    ;precharge accu
306c : 28              >            plp
                        
306d : 2d0302                   and abst
                                tst_ax  absrlo,absflo,0
3070 : 08              >            php         ;save flags
3071 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3074 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3076 : 68              >            pla         ;load status
                       >            eor_flag 0
3077 : 0908            >            ora #decmode        ;ignore decimal mode bit
3079 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
307b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
307e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3080 : ca                       dex
3081 : 10de                     bpl tand4
3083 : a203                     ldx #3
3085 : b51e             tand5   lda zpAN,x
3087 : 8d0302                   sta abst
                                set_ax  absANa,$ff
                       >            load_flag $ff
308a : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
308c : 48              >            pha         ;use stack to load status
308d : bd6b02          >            lda absANa,x    ;precharge accu
3090 : 28              >            plp
                        
3091 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,$ff-fnz
3094 : 08              >            php         ;save flags
3095 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3098 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
309a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
309b : 0908            >            ora #decmode        ;ignore decimal mode bit
309d : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
309f : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30a2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30a4 : ca                       dex
30a5 : 1002                     bpl tand6
                        
30a7 : a203                     ldx #3      ;zp,x
30a9 :                  tand6
                                set_ax  absANa,0
                       >            load_flag 0
30a9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
30ab : 48              >            pha         ;use stack to load status
30ac : bd6b02          >            lda absANa,x    ;precharge accu
30af : 28              >            plp
                        
30b0 : 351e                     and zpAN,x
                                tst_ax  absrlo,absflo,0
30b2 : 08              >            php         ;save flags
30b3 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
30b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30b8 : 68              >            pla         ;load status
                       >            eor_flag 0
30b9 : 0908            >            ora #decmode        ;ignore decimal mode bit
30bb : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
30bd : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30c2 : ca                       dex
30c3 : 10e4                     bpl tand6
30c5 : a203                     ldx #3
30c7 :                  tand7
                                set_ax  absANa,$ff
                       >            load_flag $ff
30c7 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
30c9 : 48              >            pha         ;use stack to load status
30ca : bd6b02          >            lda absANa,x    ;precharge accu
30cd : 28              >            plp
                        
30ce : 351e                     and zpAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
30d0 : 08              >            php         ;save flags
30d1 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
30d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30d6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30d7 : 0908            >            ora #decmode        ;ignore decimal mode bit
30d9 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
30db : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30e0 : ca                       dex
30e1 : 10e4                     bpl tand7
                        
30e3 : a203                     ldx #3      ;abs,x
30e5 :                  tand8
                                set_ax  absANa,0
                       >            load_flag 0
30e5 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
30e7 : 48              >            pha         ;use stack to load status
30e8 : bd6b02          >            lda absANa,x    ;precharge accu
30eb : 28              >            plp
                        
30ec : 3d5f02                   and absAN,x
                                tst_ax  absrlo,absflo,0
30ef : 08              >            php         ;save flags
30f0 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
30f3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30f5 : 68              >            pla         ;load status
                       >            eor_flag 0
30f6 : 0908            >            ora #decmode        ;ignore decimal mode bit
30f8 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
30fa : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
30fd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30ff : ca                       dex
3100 : 10e3                     bpl tand8
3102 : a203                     ldx #3
3104 :                  tand9
                                set_ax  absANa,$ff
                       >            load_flag $ff
3104 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3106 : 48              >            pha         ;use stack to load status
3107 : bd6b02          >            lda absANa,x    ;precharge accu
310a : 28              >            plp
                        
310b : 3d5f02                   and absAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
310e : 08              >            php         ;save flags
310f : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3112 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3114 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3115 : 0908            >            ora #decmode        ;ignore decimal mode bit
3117 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3119 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
311c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
311e : ca                       dex
311f : 10e3                     bpl tand9
                        
3121 : a003                     ldy #3      ;abs,y
3123 :                  tand10
                                set_ay  absANa,0
                       >            load_flag 0
3123 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
3125 : 48              >            pha         ;use stack to load status
3126 : b96b02          >            lda absANa,y    ;precharge accu
3129 : 28              >            plp
                        
312a : 395f02                   and absAN,y
                                tst_ay  absrlo,absflo,0
312d : 08              >            php         ;save flags
312e : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3131 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3133 : 68              >            pla         ;load status
                       >            eor_flag 0
3134 : 0908            >            ora #decmode        ;ignore decimal mode bit
3136 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3138 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
313b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
313d : 88                       dey
313e : 10e3                     bpl tand10
3140 : a003                     ldy #3
3142 :                  tand11
                                set_ay  absANa,$ff
                       >            load_flag $ff
3142 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3144 : 48              >            pha         ;use stack to load status
3145 : b96b02          >            lda absANa,y    ;precharge accu
3148 : 28              >            plp
                        
3149 : 395f02                   and absAN,y
                                tst_ay  absrlo,absflo,$ff-fnz
314c : 08              >            php         ;save flags
314d : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3150 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3152 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3153 : 0908            >            ora #decmode        ;ignore decimal mode bit
3155 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3157 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
315a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
315c : 88                       dey
315d : 10e3                     bpl tand11
                        
315f : a206                     ldx #6      ;(zp,x)
3161 : a003                     ldy #3
3163 :                  tand12
                                set_ay  absANa,0
                       >            load_flag 0
3163 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
3165 : 48              >            pha         ;use stack to load status
3166 : b96b02          >            lda absANa,y    ;precharge accu
3169 : 28              >            plp
                        
316a : 213c                     and (indAN,x)
                                tst_ay  absrlo,absflo,0
316c : 08              >            php         ;save flags
316d : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3170 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3172 : 68              >            pla         ;load status
                       >            eor_flag 0
3173 : 0908            >            ora #decmode        ;ignore decimal mode bit
3175 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3177 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
317a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
317c : ca                       dex
317d : ca                       dex
317e : 88                       dey
317f : 10e2                     bpl tand12
3181 : a206                     ldx #6
3183 : a003                     ldy #3
3185 :                  tand13
                                set_ay  absANa,$ff
                       >            load_flag $ff
3185 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3187 : 48              >            pha         ;use stack to load status
3188 : b96b02          >            lda absANa,y    ;precharge accu
318b : 28              >            plp
                        
318c : 213c                     and (indAN,x)
                                tst_ay  absrlo,absflo,$ff-fnz
318e : 08              >            php         ;save flags
318f : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3192 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3194 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3195 : 0908            >            ora #decmode        ;ignore decimal mode bit
3197 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3199 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
319c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
319e : ca                       dex
319f : ca                       dex
31a0 : 88                       dey
31a1 : 10e2                     bpl tand13
                        
31a3 : a003                     ldy #3      ;(zp),y
31a5 :                  tand14
                                set_ay  absANa,0
                       >            load_flag 0
31a5 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
31a7 : 48              >            pha         ;use stack to load status
31a8 : b96b02          >            lda absANa,y    ;precharge accu
31ab : 28              >            plp
                        
31ac : 313c                     and (indAN),y
                                tst_ay  absrlo,absflo,0
31ae : 08              >            php         ;save flags
31af : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
31b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31b4 : 68              >            pla         ;load status
                       >            eor_flag 0
31b5 : 0908            >            ora #decmode        ;ignore decimal mode bit
31b7 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
31b9 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
31bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31be : 88                       dey
31bf : 10e4                     bpl tand14
31c1 : a003                     ldy #3
31c3 :                  tand15
                                set_ay  absANa,$ff
                       >            load_flag $ff
31c3 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
31c5 : 48              >            pha         ;use stack to load status
31c6 : b96b02          >            lda absANa,y    ;precharge accu
31c9 : 28              >            plp
                        
31ca : 313c                     and (indAN),y
                                tst_ay  absrlo,absflo,$ff-fnz
31cc : 08              >            php         ;save flags
31cd : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
31d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31d2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31d3 : 0908            >            ora #decmode        ;ignore decimal mode bit
31d5 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
31d7 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
31da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31dc : 88                       dey
31dd : 10e4                     bpl tand15
                                next_test
31df : ad0002          >            lda test_case   ;previous test
31e2 : c926            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
31e4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0027 =                 >test_num = test_num + 1
31e6 : a927            >            lda #test_num   ;*** next tests' number
31e8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; EOR
31eb : a203                     ldx #3          ;immediate - self modifying code
31ed : b522             teor    lda zpEO,x
31ef : 8d0d02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,0
                       >            load_flag 0
31f2 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
31f4 : 48              >            pha         ;use stack to load status
31f5 : bd6f02          >            lda absEOa,x    ;precharge accu
31f8 : 28              >            plp
                        
31f9 : 200c02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,0
31fc : 08              >            php         ;save flags
31fd : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3200 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3202 : 68              >            pla         ;load status
                       >            eor_flag 0
3203 : 0908            >            ora #decmode        ;ignore decimal mode bit
3205 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3207 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
320a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
320c : ca                       dex
320d : 10de                     bpl teor
320f : a203                     ldx #3
3211 : b522             teor1   lda zpEO,x
3213 : 8d0d02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,$ff
                       >            load_flag $ff
3216 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3218 : 48              >            pha         ;use stack to load status
3219 : bd6f02          >            lda absEOa,x    ;precharge accu
321c : 28              >            plp
                        
321d : 200c02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
3220 : 08              >            php         ;save flags
3221 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3224 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3226 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3227 : 0908            >            ora #decmode        ;ignore decimal mode bit
3229 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
322b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
322e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3230 : ca                       dex
3231 : 10de                     bpl teor1
                            
3233 : a203                     ldx #3      ;zp
3235 : b522             teor2    lda zpEO,x
3237 : 850c                     sta zpt
                                set_ax  absEOa,0
                       >            load_flag 0
3239 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
323b : 48              >            pha         ;use stack to load status
323c : bd6f02          >            lda absEOa,x    ;precharge accu
323f : 28              >            plp
                        
3240 : 450c                     eor zpt
                                tst_ax  absrlo,absflo,0
3242 : 08              >            php         ;save flags
3243 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3246 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3248 : 68              >            pla         ;load status
                       >            eor_flag 0
3249 : 0908            >            ora #decmode        ;ignore decimal mode bit
324b : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
324d : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3250 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3252 : ca                       dex
3253 : 10e0                     bpl teor2
3255 : a203                     ldx #3
3257 : b522             teor3   lda zpEO,x
3259 : 850c                     sta zpt
                                set_ax  absEOa,$ff
                       >            load_flag $ff
325b : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
325d : 48              >            pha         ;use stack to load status
325e : bd6f02          >            lda absEOa,x    ;precharge accu
3261 : 28              >            plp
                        
3262 : 450c                     eor zpt
                                tst_ax  absrlo,absflo,$ff-fnz
3264 : 08              >            php         ;save flags
3265 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3268 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
326a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
326b : 0908            >            ora #decmode        ;ignore decimal mode bit
326d : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
326f : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3272 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3274 : ca                       dex
3275 : 10e0                     bpl teor3
                        
3277 : a203                     ldx #3      ;abs
3279 : b522             teor4   lda zpEO,x
327b : 8d0302                   sta abst
                                set_ax  absEOa,0
                       >            load_flag 0
327e : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
3280 : 48              >            pha         ;use stack to load status
3281 : bd6f02          >            lda absEOa,x    ;precharge accu
3284 : 28              >            plp
                        
3285 : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,0
3288 : 08              >            php         ;save flags
3289 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
328c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
328e : 68              >            pla         ;load status
                       >            eor_flag 0
328f : 0908            >            ora #decmode        ;ignore decimal mode bit
3291 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3293 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3296 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3298 : ca                       dex
3299 : 10de                     bpl teor4
329b : a203                     ldx #3
329d : b522             teor5   lda zpEO,x
329f : 8d0302                   sta abst
                                set_ax  absEOa,$ff
                       >            load_flag $ff
32a2 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
32a4 : 48              >            pha         ;use stack to load status
32a5 : bd6f02          >            lda absEOa,x    ;precharge accu
32a8 : 28              >            plp
                        
32a9 : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,$ff-fnz
32ac : 08              >            php         ;save flags
32ad : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
32b0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32b2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
32b3 : 0908            >            ora #decmode        ;ignore decimal mode bit
32b5 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
32b7 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
32ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32bc : ca                       dex
32bd : 1002                     bpl teor6
                        
32bf : a203                     ldx #3      ;zp,x
32c1 :                  teor6
                                set_ax  absEOa,0
                       >            load_flag 0
32c1 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
32c3 : 48              >            pha         ;use stack to load status
32c4 : bd6f02          >            lda absEOa,x    ;precharge accu
32c7 : 28              >            plp
                        
32c8 : 5522                     eor zpEO,x
                                tst_ax  absrlo,absflo,0
32ca : 08              >            php         ;save flags
32cb : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
32ce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32d0 : 68              >            pla         ;load status
                       >            eor_flag 0
32d1 : 0908            >            ora #decmode        ;ignore decimal mode bit
32d3 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
32d5 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
32d8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32da : ca                       dex
32db : 10e4                     bpl teor6
32dd : a203                     ldx #3
32df :                  teor7
                                set_ax  absEOa,$ff
                       >            load_flag $ff
32df : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
32e1 : 48              >            pha         ;use stack to load status
32e2 : bd6f02          >            lda absEOa,x    ;precharge accu
32e5 : 28              >            plp
                        
32e6 : 5522                     eor zpEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
32e8 : 08              >            php         ;save flags
32e9 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
32ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32ee : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
32ef : 0908            >            ora #decmode        ;ignore decimal mode bit
32f1 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
32f3 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
32f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32f8 : ca                       dex
32f9 : 10e4                     bpl teor7
                        
32fb : a203                     ldx #3      ;abs,x
32fd :                  teor8
                                set_ax  absEOa,0
                       >            load_flag 0
32fd : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
32ff : 48              >            pha         ;use stack to load status
3300 : bd6f02          >            lda absEOa,x    ;precharge accu
3303 : 28              >            plp
                        
3304 : 5d6302                   eor absEO,x
                                tst_ax  absrlo,absflo,0
3307 : 08              >            php         ;save flags
3308 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
330b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
330d : 68              >            pla         ;load status
                       >            eor_flag 0
330e : 0908            >            ora #decmode        ;ignore decimal mode bit
3310 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3312 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3315 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3317 : ca                       dex
3318 : 10e3                     bpl teor8
331a : a203                     ldx #3
331c :                  teor9
                                set_ax  absEOa,$ff
                       >            load_flag $ff
331c : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
331e : 48              >            pha         ;use stack to load status
331f : bd6f02          >            lda absEOa,x    ;precharge accu
3322 : 28              >            plp
                        
3323 : 5d6302                   eor absEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
3326 : 08              >            php         ;save flags
3327 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
332a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
332c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
332d : 0908            >            ora #decmode        ;ignore decimal mode bit
332f : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3331 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3334 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3336 : ca                       dex
3337 : 10e3                     bpl teor9
                        
3339 : a003                     ldy #3      ;abs,y
333b :                  teor10
                                set_ay  absEOa,0
                       >            load_flag 0
333b : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
333d : 48              >            pha         ;use stack to load status
333e : b96f02          >            lda absEOa,y    ;precharge accu
3341 : 28              >            plp
                        
3342 : 596302                   eor absEO,y
                                tst_ay  absrlo,absflo,0
3345 : 08              >            php         ;save flags
3346 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3349 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
334b : 68              >            pla         ;load status
                       >            eor_flag 0
334c : 0908            >            ora #decmode        ;ignore decimal mode bit
334e : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3350 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3353 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3355 : 88                       dey
3356 : 10e3                     bpl teor10
3358 : a003                     ldy #3
335a :                  teor11
                                set_ay  absEOa,$ff
                       >            load_flag $ff
335a : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
335c : 48              >            pha         ;use stack to load status
335d : b96f02          >            lda absEOa,y    ;precharge accu
3360 : 28              >            plp
                        
3361 : 596302                   eor absEO,y
                                tst_ay  absrlo,absflo,$ff-fnz
3364 : 08              >            php         ;save flags
3365 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3368 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
336a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
336b : 0908            >            ora #decmode        ;ignore decimal mode bit
336d : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
336f : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3372 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3374 : 88                       dey
3375 : 10e3                     bpl teor11
                        
3377 : a206                     ldx #6      ;(zp,x)
3379 : a003                     ldy #3
337b :                  teor12
                                set_ay  absEOa,0
                       >            load_flag 0
337b : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
337d : 48              >            pha         ;use stack to load status
337e : b96f02          >            lda absEOa,y    ;precharge accu
3381 : 28              >            plp
                        
3382 : 4144                     eor (indEO,x)
                                tst_ay  absrlo,absflo,0
3384 : 08              >            php         ;save flags
3385 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3388 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
338a : 68              >            pla         ;load status
                       >            eor_flag 0
338b : 0908            >            ora #decmode        ;ignore decimal mode bit
338d : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
338f : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
3392 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3394 : ca                       dex
3395 : ca                       dex
3396 : 88                       dey
3397 : 10e2                     bpl teor12
3399 : a206                     ldx #6
339b : a003                     ldy #3
339d :                  teor13
                                set_ay  absEOa,$ff
                       >            load_flag $ff
339d : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
339f : 48              >            pha         ;use stack to load status
33a0 : b96f02          >            lda absEOa,y    ;precharge accu
33a3 : 28              >            plp
                        
33a4 : 4144                     eor (indEO,x)
                                tst_ay  absrlo,absflo,$ff-fnz
33a6 : 08              >            php         ;save flags
33a7 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
33aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
33ac : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
33ad : 0908            >            ora #decmode        ;ignore decimal mode bit
33af : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
33b1 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
33b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
33b6 : ca                       dex
33b7 : ca                       dex
33b8 : 88                       dey
33b9 : 10e2                     bpl teor13
                        
33bb : a003                     ldy #3      ;(zp),y
33bd :                  teor14
                                set_ay  absEOa,0
                       >            load_flag 0
33bd : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
33bf : 48              >            pha         ;use stack to load status
33c0 : b96f02          >            lda absEOa,y    ;precharge accu
33c3 : 28              >            plp
                        
33c4 : 5144                     eor (indEO),y
                                tst_ay  absrlo,absflo,0
33c6 : 08              >            php         ;save flags
33c7 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
33ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
33cc : 68              >            pla         ;load status
                       >            eor_flag 0
33cd : 0908            >            ora #decmode        ;ignore decimal mode bit
33cf : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
33d1 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
33d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
33d6 : 88                       dey
33d7 : 10e4                     bpl teor14
33d9 : a003                     ldy #3
33db :                  teor15
                                set_ay  absEOa,$ff
                       >            load_flag $ff
33db : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
33dd : 48              >            pha         ;use stack to load status
33de : b96f02          >            lda absEOa,y    ;precharge accu
33e1 : 28              >            plp
                        
33e2 : 5144                     eor (indEO),y
                                tst_ay  absrlo,absflo,$ff-fnz
33e4 : 08              >            php         ;save flags
33e5 : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
33e8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
33ea : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
33eb : 0908            >            ora #decmode        ;ignore decimal mode bit
33ed : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
33ef : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
33f2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
33f4 : 88                       dey
33f5 : 10e4                     bpl teor15
                                next_test
33f7 : ad0002          >            lda test_case   ;previous test
33fa : c927            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
33fc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0028 =                 >test_num = test_num + 1
33fe : a928            >            lda #test_num   ;*** next tests' number
3400 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; OR
3403 : a203                     ldx #3          ;immediate - self modifying code
3405 : b51a             tora    lda zpOR,x
3407 : 8d1002                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,0
                       >            load_flag 0
340a : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
340c : 48              >            pha         ;use stack to load status
340d : bd6702          >            lda absORa,x    ;precharge accu
3410 : 28              >            plp
                        
3411 : 200f02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,0
3414 : 08              >            php         ;save flags
3415 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3418 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
341a : 68              >            pla         ;load status
                       >            eor_flag 0
341b : 0908            >            ora #decmode        ;ignore decimal mode bit
341d : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
341f : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3422 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3424 : ca                       dex
3425 : 10de                     bpl tora
3427 : a203                     ldx #3
3429 : b51a             tora1   lda zpOR,x
342b : 8d1002                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,$ff
                       >            load_flag $ff
342e : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3430 : 48              >            pha         ;use stack to load status
3431 : bd6702          >            lda absORa,x    ;precharge accu
3434 : 28              >            plp
                        
3435 : 200f02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
3438 : 08              >            php         ;save flags
3439 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
343c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
343e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
343f : 0908            >            ora #decmode        ;ignore decimal mode bit
3441 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3443 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3446 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3448 : ca                       dex
3449 : 10de                     bpl tora1
                            
344b : a203                     ldx #3      ;zp
344d : b51a             tora2   lda zpOR,x
344f : 850c                     sta zpt
                                set_ax  absORa,0
                       >            load_flag 0
3451 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
3453 : 48              >            pha         ;use stack to load status
3454 : bd6702          >            lda absORa,x    ;precharge accu
3457 : 28              >            plp
                        
3458 : 050c                     ora zpt
                                tst_ax  absrlo,absflo,0
345a : 08              >            php         ;save flags
345b : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
345e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3460 : 68              >            pla         ;load status
                       >            eor_flag 0
3461 : 0908            >            ora #decmode        ;ignore decimal mode bit
3463 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3465 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3468 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
346a : ca                       dex
346b : 10e0                     bpl tora2
346d : a203                     ldx #3
346f : b51a             tora3   lda zpOR,x
3471 : 850c                     sta zpt
                                set_ax  absORa,$ff
                       >            load_flag $ff
3473 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3475 : 48              >            pha         ;use stack to load status
3476 : bd6702          >            lda absORa,x    ;precharge accu
3479 : 28              >            plp
                        
347a : 050c                     ora zpt
                                tst_ax  absrlo,absflo,$ff-fnz
347c : 08              >            php         ;save flags
347d : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3480 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3482 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3483 : 0908            >            ora #decmode        ;ignore decimal mode bit
3485 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3487 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
348a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
348c : ca                       dex
348d : 10e0                     bpl tora3
                        
348f : a203                     ldx #3      ;abs
3491 : b51a             tora4   lda zpOR,x
3493 : 8d0302                   sta abst
                                set_ax  absORa,0
                       >            load_flag 0
3496 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
3498 : 48              >            pha         ;use stack to load status
3499 : bd6702          >            lda absORa,x    ;precharge accu
349c : 28              >            plp
                        
349d : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,0
34a0 : 08              >            php         ;save flags
34a1 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
34a4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
34a6 : 68              >            pla         ;load status
                       >            eor_flag 0
34a7 : 0908            >            ora #decmode        ;ignore decimal mode bit
34a9 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
34ab : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
34ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
34b0 : ca                       dex
34b1 : 10de                     bpl tora4
34b3 : a203                     ldx #3
34b5 : b51a             tora5   lda zpOR,x
34b7 : 8d0302                   sta abst
                                set_ax  absORa,$ff
                       >            load_flag $ff
34ba : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
34bc : 48              >            pha         ;use stack to load status
34bd : bd6702          >            lda absORa,x    ;precharge accu
34c0 : 28              >            plp
                        
34c1 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,$ff-fnz
34c4 : 08              >            php         ;save flags
34c5 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
34c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
34ca : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
34cb : 0908            >            ora #decmode        ;ignore decimal mode bit
34cd : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
34cf : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
34d2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
34d4 : ca                       dex
34d5 : 1002                     bpl tora6
                        
34d7 : a203                     ldx #3      ;zp,x
34d9 :                  tora6
                                set_ax  absORa,0
                       >            load_flag 0
34d9 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
34db : 48              >            pha         ;use stack to load status
34dc : bd6702          >            lda absORa,x    ;precharge accu
34df : 28              >            plp
                        
34e0 : 151a                     ora zpOR,x
                                tst_ax  absrlo,absflo,0
34e2 : 08              >            php         ;save flags
34e3 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
34e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
34e8 : 68              >            pla         ;load status
                       >            eor_flag 0
34e9 : 0908            >            ora #decmode        ;ignore decimal mode bit
34eb : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
34ed : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
34f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
34f2 : ca                       dex
34f3 : 10e4                     bpl tora6
34f5 : a203                     ldx #3
34f7 :                  tora7
                                set_ax  absORa,$ff
                       >            load_flag $ff
34f7 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
34f9 : 48              >            pha         ;use stack to load status
34fa : bd6702          >            lda absORa,x    ;precharge accu
34fd : 28              >            plp
                        
34fe : 151a                     ora zpOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
3500 : 08              >            php         ;save flags
3501 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3504 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3506 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3507 : 0908            >            ora #decmode        ;ignore decimal mode bit
3509 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
350b : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
350e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3510 : ca                       dex
3511 : 10e4                     bpl tora7
                        
3513 : a203                     ldx #3      ;abs,x
3515 :                  tora8
                                set_ax  absORa,0
                       >            load_flag 0
3515 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
3517 : 48              >            pha         ;use stack to load status
3518 : bd6702          >            lda absORa,x    ;precharge accu
351b : 28              >            plp
                        
351c : 1d5b02                   ora absOR,x
                                tst_ax  absrlo,absflo,0
351f : 08              >            php         ;save flags
3520 : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3523 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3525 : 68              >            pla         ;load status
                       >            eor_flag 0
3526 : 0908            >            ora #decmode        ;ignore decimal mode bit
3528 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
352a : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
352d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
352f : ca                       dex
3530 : 10e3                     bpl tora8
3532 : a203                     ldx #3
3534 :                  tora9
                                set_ax  absORa,$ff
                       >            load_flag $ff
3534 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3536 : 48              >            pha         ;use stack to load status
3537 : bd6702          >            lda absORa,x    ;precharge accu
353a : 28              >            plp
                        
353b : 1d5b02                   ora absOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
353e : 08              >            php         ;save flags
353f : dd7302          >            cmp absrlo,x    ;test result
                       >            trap_ne
3542 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3544 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3545 : 0908            >            ora #decmode        ;ignore decimal mode bit
3547 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3549 : dd7702          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
354c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
354e : ca                       dex
354f : 10e3                     bpl tora9
                        
3551 : a003                     ldy #3      ;abs,y
3553 :                  tora10
                                set_ay  absORa,0
                       >            load_flag 0
3553 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
3555 : 48              >            pha         ;use stack to load status
3556 : b96702          >            lda absORa,y    ;precharge accu
3559 : 28              >            plp
                        
355a : 195b02                   ora absOR,y
                                tst_ay  absrlo,absflo,0
355d : 08              >            php         ;save flags
355e : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3561 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3563 : 68              >            pla         ;load status
                       >            eor_flag 0
3564 : 0908            >            ora #decmode        ;ignore decimal mode bit
3566 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3568 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
356b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
356d : 88                       dey
356e : 10e3                     bpl tora10
3570 : a003                     ldy #3
3572 :                  tora11
                                set_ay  absORa,$ff
                       >            load_flag $ff
3572 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3574 : 48              >            pha         ;use stack to load status
3575 : b96702          >            lda absORa,y    ;precharge accu
3578 : 28              >            plp
                        
3579 : 195b02                   ora absOR,y
                                tst_ay  absrlo,absflo,$ff-fnz
357c : 08              >            php         ;save flags
357d : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3580 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3582 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3583 : 0908            >            ora #decmode        ;ignore decimal mode bit
3585 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3587 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
358a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
358c : 88                       dey
358d : 10e3                     bpl tora11
                        
358f : a206                     ldx #6      ;(zp,x)
3591 : a003                     ldy #3
3593 :                  tora12
                                set_ay  absORa,0
                       >            load_flag 0
3593 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
3595 : 48              >            pha         ;use stack to load status
3596 : b96702          >            lda absORa,y    ;precharge accu
3599 : 28              >            plp
                        
359a : 014c                     ora (indOR,x)
                                tst_ay  absrlo,absflo,0
359c : 08              >            php         ;save flags
359d : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
35a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
35a2 : 68              >            pla         ;load status
                       >            eor_flag 0
35a3 : 0908            >            ora #decmode        ;ignore decimal mode bit
35a5 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
35a7 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
35aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
35ac : ca                       dex
35ad : ca                       dex
35ae : 88                       dey
35af : 10e2                     bpl tora12
35b1 : a206                     ldx #6
35b3 : a003                     ldy #3
35b5 :                  tora13
                                set_ay  absORa,$ff
                       >            load_flag $ff
35b5 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
35b7 : 48              >            pha         ;use stack to load status
35b8 : b96702          >            lda absORa,y    ;precharge accu
35bb : 28              >            plp
                        
35bc : 014c                     ora (indOR,x)
                                tst_ay  absrlo,absflo,$ff-fnz
35be : 08              >            php         ;save flags
35bf : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
35c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
35c4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
35c5 : 0908            >            ora #decmode        ;ignore decimal mode bit
35c7 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
35c9 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
35cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
35ce : ca                       dex
35cf : ca                       dex
35d0 : 88                       dey
35d1 : 10e2                     bpl tora13
                        
35d3 : a003                     ldy #3      ;(zp),y
35d5 :                  tora14
                                set_ay  absORa,0
                       >            load_flag 0
35d5 : a900            >            lda #0&m8i         ;force enable interrupts (mask I)
                       >
35d7 : 48              >            pha         ;use stack to load status
35d8 : b96702          >            lda absORa,y    ;precharge accu
35db : 28              >            plp
                        
35dc : 114c                     ora (indOR),y
                                tst_ay  absrlo,absflo,0
35de : 08              >            php         ;save flags
35df : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
35e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
35e4 : 68              >            pla         ;load status
                       >            eor_flag 0
35e5 : 0908            >            ora #decmode        ;ignore decimal mode bit
35e7 : 4938            >            eor #(0&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
35e9 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
35ec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
35ee : 88                       dey
35ef : 10e4                     bpl tora14
35f1 : a003                     ldy #3
35f3 :                  tora15
                                set_ay  absORa,$ff
                       >            load_flag $ff
35f3 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
35f5 : 48              >            pha         ;use stack to load status
35f6 : b96702          >            lda absORa,y    ;precharge accu
35f9 : 28              >            plp
                        
35fa : 114c                     ora (indOR),y
                                tst_ay  absrlo,absflo,$ff-fnz
35fc : 08              >            php         ;save flags
35fd : d97302          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3600 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3602 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3603 : 0908            >            ora #decmode        ;ignore decimal mode bit
3605 : 4979            >            eor #($ff-fnz&m8i|faod)  ;mask I, invert expected flags + always on bits
                       >
3607 : d97702          >            cmp absflo,y    ;test flags
                       >            trap_ne
360a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
360c : 88                       dey
360d : 10e4                     bpl tora15
                            if I_flag = 3
                                cli
                            endif                
                                next_test
360f : ad0002          >            lda test_case   ;previous test
3612 : c928            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
3614 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0029 =                 >test_num = test_num + 1
3616 : a929            >            lda #test_num   ;*** next tests' number
3618 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
361b : d8                       cld
361c : a20e                     ldx #ad2        ;for indexed test
361e : a0ff                     ldy #$ff        ;max range
3620 : a900                     lda #0          ;start with adding zeroes & no carry
3622 : 850c                     sta adfc        ;carry in - for diag
3624 : 850d                     sta ad1         ;operand 1 - accumulator
3626 : 850e                     sta ad2         ;operand 2 - memory or immediate
3628 : 8d0302                   sta ada2        ;non zp
362b : 850f                     sta adrl        ;expected result bits 0-7
362d : 8510                     sta adrh        ;expected result bit 8 (carry out)
362f : a9ff                     lda #$ff        ;complemented operand 2 for subtract
3631 : 8512                     sta sb2
3633 : 8d0402                   sta sba2        ;non zp
3636 : a902                     lda #2          ;expected Z-flag
3638 : 8511                     sta adrf
363a : 18               tadd    clc             ;test with carry clear
363b : 208636                   jsr chkadd
363e : e60c                     inc adfc        ;now with carry
3640 : e60f                     inc adrl        ;result +1
3642 : 08                       php             ;save N & Z from low result
3643 : 08                       php
3644 : 68                       pla             ;accu holds expected flags
3645 : 2982                     and #$82        ;mask N & Z
3647 : 28                       plp
3648 : d002                     bne tadd1
364a : e610                     inc adrh        ;result bit 8 - carry
364c : 0510             tadd1   ora adrh        ;merge C to expected flags
364e : 8511                     sta adrf        ;save expected flags except overflow
3650 : 38                       sec             ;test with carry set
3651 : 208636                   jsr chkadd
3654 : c60c                     dec adfc        ;same for operand +1 but no carry
3656 : e60d                     inc ad1
3658 : d0e0                     bne tadd        ;iterate op1
365a : a900                     lda #0          ;preset result to op2 when op1 = 0
365c : 8510                     sta adrh
365e : ee0302                   inc ada2
3661 : e60e                     inc ad2
3663 : 08                       php             ;save NZ as operand 2 becomes the new result
3664 : 68                       pla
3665 : 2982                     and #$82        ;mask N00000Z0
3667 : 8511                     sta adrf        ;no need to check carry as we are adding to 0
3669 : c612                     dec sb2         ;complement subtract operand 2
366b : ce0402                   dec sba2
366e : a50e                     lda ad2         
3670 : 850f                     sta adrl
3672 : d0c6                     bne tadd        ;iterate op2
                            if disable_decimal < 1
                                next_test
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                                sed 
                                ldx #ad2        ;for indexed test
                                ldy #$ff        ;max range
                                lda #$99        ;start with adding 99 to 99 with carry
                                sta ad1         ;operand 1 - accumulator
                                sta ad2         ;operand 2 - memory or immediate
                                sta ada2        ;non zp
                                sta adrl        ;expected result bits 0-7
                                lda #1          ;set carry in & out
                                sta adfc        ;carry in - for diag
                                sta adrh        ;expected result bit 8 (carry out)
                                lda #0          ;complemented operand 2 for subtract
                                sta sb2
                                sta sba2        ;non zp
                        tdad    sec             ;test with carry set
                                jsr chkdad
                                dec adfc        ;now with carry clear
                                lda adrl        ;decimal adjust result
                                bne tdad1       ;skip clear carry & preset result 99 (9A-1)
                                dec adrh
                                lda #$99
                                sta adrl
                                bne tdad3
                        tdad1   and #$f         ;lower nibble mask
                                bne tdad2       ;no decimal adjust needed
                                dec adrl        ;decimal adjust (?0-6)
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                        tdad2   dec adrl        ;result -1
                        tdad3   clc             ;test with carry clear
                                jsr chkdad
                                inc adfc        ;same for operand -1 but with carry
                                lda ad1         ;decimal adjust operand 1
                                beq tdad5       ;iterate operand 2
                                and #$f         ;lower nibble mask
                                bne tdad4       ;skip decimal adjust
                                dec ad1         ;decimal adjust (?0-6)
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                        tdad4   dec ad1         ;operand 1 -1
                                jmp tdad        ;iterate op1
                        
                        tdad5   lda #$99        ;precharge op1 max
                                sta ad1
                                lda ad2         ;decimal adjust operand 2
                                beq tdad7       ;end of iteration
                                and #$f         ;lower nibble mask
                                bne tdad6       ;skip decimal adjust
                                dec ad2         ;decimal adjust (?0-6)
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                inc sb2         ;complemented decimal adjust for subtract (?9+6)
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                        tdad6   dec ad2         ;operand 2 -1
                                inc sb2         ;complemented operand for subtract
                                lda sb2
                                sta sba2        ;copy as non zp operand
                                lda ad2
                                sta ada2        ;copy as non zp operand
                                sta adrl        ;new result since op1+carry=00+carry +op2=op2
                                inc adrh        ;result carry
                                bne tdad        ;iterate op2
                        tdad7
                                next_test
                        
                        ; decimal/binary switch test
                        ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
                        ;   tables
                                clc
                                cld
                                php
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after cld
                                clc
                                sed
                                php
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after sed
                                cld
                                plp
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after plp D=1
                                plp
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after plp D=0
                                clc
                                lda #hi bin_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo bin_rti_ret
                                pha
                                php
                                sed
                                lda #hi dec_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo dec_rti_ret
                                pha
                                php
                                cld
                                rti
                        dec_rti_ret
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after rti D=1
                                rti
                        bin_rti_ret        
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after rti D=0
                            endif
                            
3674 : ad0002                   lda test_case
3677 : c929                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
3679 : d0fe            >        bne *           ;failed not equal (non zero)
                        
367b : a9f0                     lda #$f0        ;mark opcode testing complete
367d : 8d0002                   sta test_case
                                
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
                       >            ;RAM check disabled - RAM size not set
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************
                        ; -------------       
                                success         ;if you get here everything went well
3680 : 4c8036          >        jmp *           ;test passed, no errors
                        
                        ; -------------       
                        ; S U C C E S S ************************************************
3683 : 4c0004                   jmp start       ;run again      
                        
                            if disable_decimal < 1
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                        chkdad
                        ; decimal ADC / SBC zp
                                php             ;save carry for subtract
                                lda ad1
                                adc ad2         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2         ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad flags
                                plp
                        ; decimal ADC / SBC abs
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2        ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2        ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC #
                                php             ;save carry for subtract
                                lda ad2
                                sta ex_adci+1   ;set ADC # operand
                                lda ad1
                                jsr ex_adci     ;execute ADC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda sb2
                                sta ex_sbci+1   ;set SBC # operand
                                lda ad1
                                jsr ex_sbci     ;execute SBC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC zp,x
                                php             ;save carry for subtract
                                lda ad1
                                adc 0,x         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2-ad2,x   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,x
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-ad2,x  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-ad2,x  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,y
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-$ff,y  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-$ff,y  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (zp,x)
                                php             ;save carry for subtract
                                lda ad1
                                adc (lo adi2-ad2,x) ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (lo sbi2-ad2,x) ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (abs),y
                                php             ;save carry for subtract
                                lda ad1
                                adc (adiy2),y   ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (sbiy2),y   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                rts
                            endif
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
3686 : a511             chkadd  lda adrf        ;add V-flag if overflow
3688 : 2983                     and #$83        ;keep N-----ZC / clear V
368a : 48                       pha
368b : a50d                     lda ad1         ;test sign unequal between operands
368d : 450e                     eor ad2
368f : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
3691 : a50d                     lda ad1         ;test sign equal between operands and result
3693 : 450f                     eor adrl
3695 : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
3697 : 68                       pla
3698 : 0940                     ora #$40        ;set V
369a : 48                       pha
369b : 68               ckad1   pla
369c : 8511                     sta adrf        ;save expected flags
                        ; binary ADC / SBC zp
369e : 08                       php             ;save carry for subtract
369f : a50d                     lda ad1
36a1 : 650e                     adc ad2         ;perform add
36a3 : 08                       php          
36a4 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
36a6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36a8 : 68                       pla             ;check flags
36a9 : 29c3                     and #$c3        ;mask NV----ZC
36ab : c511                     cmp adrf
                                trap_ne         ;bad flags
36ad : d0fe            >        bne *           ;failed not equal (non zero)
                        
36af : 28                       plp
36b0 : 08                       php             ;save carry for next add
36b1 : a50d                     lda ad1
36b3 : e512                     sbc sb2         ;perform subtract
36b5 : 08                       php          
36b6 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
36b8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36ba : 68                       pla             ;check flags
36bb : 29c3                     and #$c3        ;mask NV----ZC
36bd : c511                     cmp adrf
                                trap_ne         ;bad flags
36bf : d0fe            >        bne *           ;failed not equal (non zero)
                        
36c1 : 28                       plp
                        ; binary ADC / SBC abs
36c2 : 08                       php             ;save carry for subtract
36c3 : a50d                     lda ad1
36c5 : 6d0302                   adc ada2        ;perform add
36c8 : 08                       php          
36c9 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
36cb : d0fe            >        bne *           ;failed not equal (non zero)
                        
36cd : 68                       pla             ;check flags
36ce : 29c3                     and #$c3        ;mask NV----ZC
36d0 : c511                     cmp adrf
                                trap_ne         ;bad flags
36d2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36d4 : 28                       plp
36d5 : 08                       php             ;save carry for next add
36d6 : a50d                     lda ad1
36d8 : ed0402                   sbc sba2        ;perform subtract
36db : 08                       php          
36dc : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
36de : d0fe            >        bne *           ;failed not equal (non zero)
                        
36e0 : 68                       pla             ;check flags
36e1 : 29c3                     and #$c3        ;mask NV----ZC
36e3 : c511                     cmp adrf
                                trap_ne         ;bad flags
36e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36e7 : 28                       plp
                        ; binary ADC / SBC #
36e8 : 08                       php             ;save carry for subtract
36e9 : a50e                     lda ad2
36eb : 8d1302                   sta ex_adci+1   ;set ADC # operand
36ee : a50d                     lda ad1
36f0 : 201202                   jsr ex_adci     ;execute ADC # in RAM
36f3 : 08                       php          
36f4 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
36f6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
36f8 : 68                       pla             ;check flags
36f9 : 29c3                     and #$c3        ;mask NV----ZC
36fb : c511                     cmp adrf
                                trap_ne         ;bad flags
36fd : d0fe            >        bne *           ;failed not equal (non zero)
                        
36ff : 28                       plp
3700 : 08                       php             ;save carry for next add
3701 : a512                     lda sb2
3703 : 8d1602                   sta ex_sbci+1   ;set SBC # operand
3706 : a50d                     lda ad1
3708 : 201502                   jsr ex_sbci     ;execute SBC # in RAM
370b : 08                       php          
370c : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
370e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3710 : 68                       pla             ;check flags
3711 : 29c3                     and #$c3        ;mask NV----ZC
3713 : c511                     cmp adrf
                                trap_ne         ;bad flags
3715 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3717 : 28                       plp
                        ; binary ADC / SBC zp,x
3718 : 08                       php             ;save carry for subtract
3719 : a50d                     lda ad1
371b : 7500                     adc 0,x         ;perform add
371d : 08                       php          
371e : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3720 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3722 : 68                       pla             ;check flags
3723 : 29c3                     and #$c3        ;mask NV----ZC
3725 : c511                     cmp adrf
                                trap_ne         ;bad flags
3727 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3729 : 28                       plp
372a : 08                       php             ;save carry for next add
372b : a50d                     lda ad1
372d : f504                     sbc sb2-ad2,x   ;perform subtract
372f : 08                       php          
3730 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3732 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3734 : 68                       pla             ;check flags
3735 : 29c3                     and #$c3        ;mask NV----ZC
3737 : c511                     cmp adrf
                                trap_ne         ;bad flags
3739 : d0fe            >        bne *           ;failed not equal (non zero)
                        
373b : 28                       plp
                        ; binary ADC / SBC abs,x
373c : 08                       php             ;save carry for subtract
373d : a50d                     lda ad1
373f : 7df501                   adc ada2-ad2,x  ;perform add
3742 : 08                       php          
3743 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3745 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3747 : 68                       pla             ;check flags
3748 : 29c3                     and #$c3        ;mask NV----ZC
374a : c511                     cmp adrf
                                trap_ne         ;bad flags
374c : d0fe            >        bne *           ;failed not equal (non zero)
                        
374e : 28                       plp
374f : 08                       php             ;save carry for next add
3750 : a50d                     lda ad1
3752 : fdf601                   sbc sba2-ad2,x  ;perform subtract
3755 : 08                       php          
3756 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3758 : d0fe            >        bne *           ;failed not equal (non zero)
                        
375a : 68                       pla             ;check flags
375b : 29c3                     and #$c3        ;mask NV----ZC
375d : c511                     cmp adrf
                                trap_ne         ;bad flags
375f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3761 : 28                       plp
                        ; binary ADC / SBC abs,y
3762 : 08                       php             ;save carry for subtract
3763 : a50d                     lda ad1
3765 : 790401                   adc ada2-$ff,y  ;perform add
3768 : 08                       php          
3769 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
376b : d0fe            >        bne *           ;failed not equal (non zero)
                        
376d : 68                       pla             ;check flags
376e : 29c3                     and #$c3        ;mask NV----ZC
3770 : c511                     cmp adrf
                                trap_ne         ;bad flags
3772 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3774 : 28                       plp
3775 : 08                       php             ;save carry for next add
3776 : a50d                     lda ad1
3778 : f90501                   sbc sba2-$ff,y  ;perform subtract
377b : 08                       php          
377c : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
377e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3780 : 68                       pla             ;check flags
3781 : 29c3                     and #$c3        ;mask NV----ZC
3783 : c511                     cmp adrf
                                trap_ne         ;bad flags
3785 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3787 : 28                       plp
                        ; binary ADC / SBC (zp,x)
3788 : 08                       php             ;save carry for subtract
3789 : a50d                     lda ad1
378b : 6146                     adc (lo adi2-ad2,x) ;perform add
378d : 08                       php          
378e : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3790 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3792 : 68                       pla             ;check flags
3793 : 29c3                     and #$c3        ;mask NV----ZC
3795 : c511                     cmp adrf
                                trap_ne         ;bad flags
3797 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3799 : 28                       plp
379a : 08                       php             ;save carry for next add
379b : a50d                     lda ad1
379d : e148                     sbc (lo sbi2-ad2,x) ;perform subtract
379f : 08                       php          
37a0 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
37a2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
37a4 : 68                       pla             ;check flags
37a5 : 29c3                     and #$c3        ;mask NV----ZC
37a7 : c511                     cmp adrf
                                trap_ne         ;bad flags
37a9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
37ab : 28                       plp
                        ; binary ADC / SBC (abs),y
37ac : 08                       php             ;save carry for subtract
37ad : a50d                     lda ad1
37af : 7158                     adc (adiy2),y   ;perform add
37b1 : 08                       php          
37b2 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
37b4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
37b6 : 68                       pla             ;check flags
37b7 : 29c3                     and #$c3        ;mask NV----ZC
37b9 : c511                     cmp adrf
                                trap_ne         ;bad flags
37bb : d0fe            >        bne *           ;failed not equal (non zero)
                        
37bd : 28                       plp
37be : 08                       php             ;save carry for next add
37bf : a50d                     lda ad1
37c1 : f15a                     sbc (sbiy2),y   ;perform subtract
37c3 : 08                       php          
37c4 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
37c6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
37c8 : 68                       pla             ;check flags
37c9 : 29c3                     and #$c3        ;mask NV----ZC
37cb : c511                     cmp adrf
                                trap_ne         ;bad flags
37cd : d0fe            >        bne *           ;failed not equal (non zero)
                        
37cf : 28                       plp
37d0 : 60                       rts
                        
                        ; target for the jump absolute test
37d1 : 88                       dey
37d2 : 88                       dey
37d3 :                  test_far
37d3 : 08                       php             ;either SP or Y count will fail, if we do not hit
37d4 : 88                       dey
37d5 : 88                       dey
37d6 : 88                       dey
37d7 : 28                       plp
                                trap_cs         ;flags loaded?
37d8 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
37da : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
37dc : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
37de : f0fe            >        beq *           ;failed equal (zero)
                        
37e0 : c946                     cmp #'F'        ;registers loaded?
                                trap_ne
37e2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
37e4 : e041                     cpx #'A'
                                trap_ne        
37e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
37e8 : c04f                     cpy #('R'-3)
                                trap_ne
37ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
37ec : 48                       pha             ;save a,x
37ed : 8a                       txa
37ee : 48                       pha
37ef : ba                       tsx
37f0 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
37f2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
37f4 : 68                       pla             ;restore x
37f5 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
37f6 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
37f8 : 48              >            pha         ;use stack to load status
37f9 : 28              >            plp
                        
37fa : 68                       pla             ;restore a
37fb : e8                       inx             ;return registers with modifications
37fc : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
37fe : 4c3309                   jmp far_ret
                                
                        ; target for the jump indirect test
3801 : 00                       align
3802 : 0b38             ptr_tst_ind dw test_ind
3804 : 8809             ptr_ind_ret dw ind_ret
                                trap            ;runover protection
3806 : 4c0638          >        jmp *           ;failed anyway
                        
3809 : 88                       dey
380a : 88                       dey
380b :                  test_ind
380b : 08                       php             ;either SP or Y count will fail, if we do not hit
380c : 88                       dey
380d : 88                       dey
380e : 88                       dey
380f : 28                       plp
                                trap_cs         ;flags loaded?
3810 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
3812 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
3814 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
3816 : f0fe            >        beq *           ;failed equal (zero)
                        
3818 : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
381a : d0fe            >        bne *           ;failed not equal (non zero)
                        
381c : e04e                     cpx #'N'
                                trap_ne        
381e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3820 : c041                     cpy #('D'-3)
                                trap_ne
3822 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3824 : 48                       pha             ;save a,x
3825 : 8a                       txa
3826 : 48                       pha
3827 : ba                       tsx
3828 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
382a : d0fe            >        bne *           ;failed not equal (non zero)
                        
382c : 68                       pla             ;restore x
382d : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
382e : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3830 : 48              >            pha         ;use stack to load status
3831 : 28              >            plp
                        
3832 : 68                       pla             ;restore a
3833 : e8                       inx             ;return registers with modifications
3834 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
3836 : 6c0438                   jmp (ptr_ind_ret)
                                trap            ;runover protection
3839 : 4c3938          >        jmp *           ;failed anyway
                        
383c : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                        ; target for the jump subroutine test
383f : 88                       dey
3840 : 88                       dey
3841 :                  test_jsr
3841 : 08                       php             ;either SP or Y count will fail, if we do not hit
3842 : 88                       dey
3843 : 88                       dey
3844 : 88                       dey
3845 : 28                       plp
                                trap_cs         ;flags loaded?
3846 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
3848 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
384a : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
384c : f0fe            >        beq *           ;failed equal (zero)
                        
384e : c94a                     cmp #'J'        ;registers loaded?
                                trap_ne
3850 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3852 : e053                     cpx #'S'
                                trap_ne        
3854 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3856 : c04f                     cpy #('R'-3)
                                trap_ne
3858 : d0fe            >        bne *           ;failed not equal (non zero)
                        
385a : 48                       pha             ;save a,x
385b : 8a                       txa
385c : 48                       pha       
385d : ba                       tsx             ;sp -4? (return addr,a,x)
385e : e0fb                     cpx #$fb
                                trap_ne
3860 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3862 : adff01                   lda $1ff        ;propper return on stack
3865 : c909                     cmp #hi(jsr_ret)
                                trap_ne
3867 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3869 : adfe01                   lda $1fe
386c : c9be                     cmp #lo(jsr_ret)
                                trap_ne
386e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
3870 : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                       >
3872 : 48              >            pha         ;use stack to load status
3873 : 28              >            plp
                        
3874 : 68                       pla             ;pull x,a
3875 : aa                       tax
3876 : 68                       pla
3877 : e8                       inx             ;return registers with modifications
3878 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
387a : 60                       rts
                                trap            ;runover protection
387b : 4c7b38          >        jmp *           ;failed anyway
                        
387e : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
3881 :                  nmi_trap
                                trap            ;check stack for conditions at NMI
3881 : 4c8138          >        jmp *           ;failed anyway
                        
3884 : 4c0004                   jmp start       ;catastrophic error - cannot continue
3887 :                  res_trap
                                trap            ;unexpected RESET
3887 : 4c8738          >        jmp *           ;failed anyway
                        
388a : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
388d : 88                       dey
388e : 88                       dey
388f :                  irq_trap                ;BRK test or unextpected BRK or IRQ
388f : 08                       php             ;either SP or Y count will fail, if we do not hit
3890 : 88                       dey
3891 : 88                       dey
3892 : 88                       dey
                                ;next traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
3893 : c9bd                     cmp #$ff-'B'    ;BRK pass 2 registers loaded?
3895 : f046                     beq break2
3897 : c942                     cmp #'B'        ;BRK pass 1 registers loaded?
                                trap_ne
3899 : d0fe            >        bne *           ;failed not equal (non zero)
                        
389b : e052                     cpx #'R'
                                trap_ne        
389d : d0fe            >        bne *           ;failed not equal (non zero)
                        
389f : c048                     cpy #'K'-3
                                trap_ne
38a1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
38a3 : 850a                     sta irq_a       ;save registers during break test
38a5 : 860b                     stx irq_x
38a7 : ba                       tsx             ;test break on stack
38a8 : bd0201                   lda $102,x
                                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
38ab : 0908            >            ora #decmode        ;ignore decimal mode bit
38ad : c938            >            cmp #(0      |faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne         ; - no break flag on stack
38af : d0fe            >        bne *           ;failed not equal (non zero)
                        
38b1 : 68                       pla
                                cmp_flag intdis ;should have added interrupt disable
38b2 : 0908            >            ora #decmode        ;ignore decimal mode bit
38b4 : c938            >            cmp #(intdis |faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
38b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
38b8 : ba                       tsx
38b9 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
38bb : d0fe            >        bne *           ;failed not equal (non zero)
                        
38bd : adff01                   lda $1ff        ;propper return on stack
38c0 : c90a                     cmp #hi(brk_ret0)
                                trap_ne
38c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
38c4 : adfe01                   lda $1fe
38c7 : c900                     cmp #lo(brk_ret0)
                                trap_ne
38c9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag $ff
38cb : a9fb            >            lda #$ff&m8i         ;force enable interrupts (mask I)
                        
38cd : 48                       pha
38ce : a60b                     ldx irq_x
38d0 : e8                       inx             ;return registers with modifications
38d1 : a50a                     lda irq_a
38d3 : 49aa                     eor #$aa
38d5 : 28                       plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
38d6 : 40                       rti
                                trap            ;runover protection
38d7 : 4cd738          >        jmp *           ;failed anyway
                        
38da : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
38dd :                  break2                  ;BRK pass 2        
38dd : e0ad                     cpx #$ff-'R'
                                trap_ne        
38df : d0fe            >        bne *           ;failed not equal (non zero)
                        
38e1 : c0b1                     cpy #$ff-'K'-3
                                trap_ne
38e3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
38e5 : 850a                     sta irq_a       ;save registers during break test
38e7 : 860b                     stx irq_x
38e9 : ba                       tsx             ;test break on stack
38ea : bd0201                   lda $102,x
                                cmp_flag $ff    ;break test should have B=1
38ed : 0908            >            ora #decmode        ;ignore decimal mode bit
38ef : c9fb            >            cmp #($ff    |faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne         ; - no break flag on stack
38f1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
38f3 : 68                       pla
38f4 : 0908                     ora #decmode    ;ignore decmode cleared if 65c02
                                cmp_flag $ff    ;actual passed flags
38f6 : 0908            >            ora #decmode        ;ignore decimal mode bit
38f8 : c9fb            >            cmp #($ff    |faod)&m8i  ;I_flag is always enabled + always on bits
                        
                                trap_ne
38fa : d0fe            >        bne *           ;failed not equal (non zero)
                        
38fc : ba                       tsx
38fd : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
38ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
3901 : adff01                   lda $1ff        ;propper return on stack
3904 : c90a                     cmp #hi(brk_ret1)
                                trap_ne
3906 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3908 : adfe01                   lda $1fe
390b : c931                     cmp #lo(brk_ret1)
                                trap_ne
390d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag intdis
390f : a900            >            lda #intdis&m8i         ;force enable interrupts (mask I)
                        
3911 : 48                       pha      
3912 : a60b                     ldx irq_x
3914 : e8                       inx             ;return registers with modifications
3915 : a50a                     lda irq_a
3917 : 49aa                     eor #$aa
3919 : 28                       plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
391a : 40                       rti
                                trap            ;runover protection
391b : 4c1b39          >        jmp *           ;failed anyway
                        
391e : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                            if report = 1
                                include "report.i65"
                            endif
                                
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
                        zp_init
                        zps_    db  $80,1           ;additional shift pattern to test zero result & flag
                        zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        zp7f_   db  $7f             ;test pattern for compare
                        ;logical zeropage operands
                        zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
                        zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
                        zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
                        ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
                                dw  abs1+1
                                dw  abs1+2
                                dw  abs1+3
                                dw  abs7f
                        inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
                        indt_   dw  abst            ;indirect pointer to store area in absolute memory
                                dw  abst+1
                                dw  abst+2
                                dw  abst+3
                        inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
                        indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
                                dw  absAN+1
                                dw  absAN+2
                                dw  absAN+3
                        indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
                                dw  absEO+1
                                dw  absEO+2
                                dw  absEO+3
                        indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
                                dw  absOR+1
                                dw  absOR+2
                                dw  absOR+3
                        ;add/subtract indirect pointers
                        adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
                        sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
                        adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
                        sbiy2_  dw  sba2-$ff
                        zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)   
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif 
                        data_init
                        ex_and_ and #0              ;execute immediate opcodes
                                rts
                        ex_eor_ eor #0              ;execute immediate opcodes
                                rts
                        ex_ora_ ora #0              ;execute immediate opcodes
                                rts
                        ex_adc_ adc #0              ;execute immediate opcodes
                                rts
                        ex_sbc_ sbc #0              ;execute immediate opcodes
                                rts
                        ;zps    db  $80,1           ;additional shift patterns test zero result & flag
                        abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
                        abs7f_  db  $7f             ;test pattern for compare
                        ;loads
                        fLDx_   db  fn,fn,0,fz              ;expected flags for load
                        ;shifts
                        rASL_                               ;expected result ASL & ROL -carry
                        rROL_   db  0,2,$86,$04,$82,0
                        rROLc_  db  1,3,$87,$05,$83,1       ;expected result ROL +carry
                        rLSR_                               ;expected result LSR & ROR -carry
                        rROR_   db  $40,0,$61,$41,$20,0
                        rRORc_  db  $c0,$80,$e1,$c1,$a0,$80 ;expected result ROR +carry
                        fASL_                               ;expected flags for shifts
                        fROL_   db  fzc,0,fnc,fc,fn,fz      ;no carry in
                        fROLc_  db  fc,0,fnc,fc,fn,0        ;carry in 
                        fLSR_
                        fROR_   db  0,fzc,fc,0,fc,fz        ;no carry in
                        fRORc_  db  fn,fnc,fnc,fn,fnc,fn    ;carry in
                        ;increments (decrements)
                        rINC_   db  $7f,$80,$ff,0,1         ;expected result for INC/DEC
                        fINC_   db  0,fn,fn,fz,0            ;expected flags for INC/DEC
                        ;logical memory operand
                        absOR_  db  0,$1f,$71,$80           ;test pattern for OR
                        absAN_  db  $0f,$ff,$7f,$80         ;test pattern for AND
                        absEO_  db  $ff,$0f,$8f,$8f         ;test pattern for EOR
                        ;logical accu operand
                        absORa_ db  0,$f1,$1f,0             ;test pattern for OR
                        absANa_ db  $f0,$ff,$ff,$ff         ;test pattern for AND
                        absEOa_ db  $ff,$f0,$f0,$0f         ;test pattern for EOR
                        ;logical results
                        absrlo_ db  0,$ff,$7f,$80
                        absflo_ db  fz,fn,0,fn
                        data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif 
                        
                        vec_init
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                        vec_bss equ $fffa
                            endif                   ;end of RAM init data
                            
                            if (load_data_direct = 1) & (ROM_vectors = 1)  
                                org $fffa       ;vectors
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                            endif
                        
38dd =                          end start
                                    
No errors in pass 2.
Wrote binary from address $0000 through $3920.
Total size 14625 bytes.
Program start address is at $0400 (1024).
